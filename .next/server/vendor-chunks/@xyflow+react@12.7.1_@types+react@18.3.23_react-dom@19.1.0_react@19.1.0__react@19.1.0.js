"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@xyflow+react@12.7.1_@types+react@18.3.23_react-dom@19.1.0_react@19.1.0__react@19.1.0";
exports.ids = ["vendor-chunks/@xyflow+react@12.7.1_@types+react@18.3.23_react-dom@19.1.0_react@19.1.0__react@19.1.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@xyflow+react@12.7.1_@types+react@18.3.23_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@xyflow/react/dist/esm/index.js":
/*!***************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@xyflow+react@12.7.1_@types+react@18.3.23_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@xyflow/react/dist/esm/index.js ***!
  \***************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Background: () => (/* binding */ Background),\n/* harmony export */   BackgroundVariant: () => (/* binding */ BackgroundVariant),\n/* harmony export */   BaseEdge: () => (/* binding */ BaseEdge),\n/* harmony export */   BezierEdge: () => (/* binding */ BezierEdge),\n/* harmony export */   ConnectionLineType: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType),\n/* harmony export */   ConnectionMode: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionMode),\n/* harmony export */   ControlButton: () => (/* binding */ ControlButton),\n/* harmony export */   Controls: () => (/* binding */ Controls),\n/* harmony export */   EdgeLabelRenderer: () => (/* binding */ EdgeLabelRenderer),\n/* harmony export */   EdgeText: () => (/* binding */ EdgeText),\n/* harmony export */   Handle: () => (/* binding */ Handle),\n/* harmony export */   MarkerType: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.MarkerType),\n/* harmony export */   MiniMap: () => (/* binding */ MiniMap),\n/* harmony export */   NodeResizeControl: () => (/* binding */ NodeResizeControl),\n/* harmony export */   NodeResizer: () => (/* binding */ NodeResizer),\n/* harmony export */   NodeToolbar: () => (/* binding */ NodeToolbar),\n/* harmony export */   PanOnScrollMode: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.PanOnScrollMode),\n/* harmony export */   Panel: () => (/* binding */ Panel),\n/* harmony export */   Position: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position),\n/* harmony export */   ReactFlow: () => (/* binding */ index),\n/* harmony export */   ReactFlowProvider: () => (/* binding */ ReactFlowProvider),\n/* harmony export */   ResizeControlVariant: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant),\n/* harmony export */   SelectionMode: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.SelectionMode),\n/* harmony export */   SimpleBezierEdge: () => (/* binding */ SimpleBezierEdge),\n/* harmony export */   SmoothStepEdge: () => (/* binding */ SmoothStepEdge),\n/* harmony export */   StepEdge: () => (/* binding */ StepEdge),\n/* harmony export */   StraightEdge: () => (/* binding */ StraightEdge),\n/* harmony export */   ViewportPortal: () => (/* binding */ ViewportPortal),\n/* harmony export */   addEdge: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.addEdge),\n/* harmony export */   applyEdgeChanges: () => (/* binding */ applyEdgeChanges),\n/* harmony export */   applyNodeChanges: () => (/* binding */ applyNodeChanges),\n/* harmony export */   getBezierEdgeCenter: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBezierEdgeCenter),\n/* harmony export */   getBezierPath: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBezierPath),\n/* harmony export */   getConnectedEdges: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getConnectedEdges),\n/* harmony export */   getEdgeCenter: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getEdgeCenter),\n/* harmony export */   getIncomers: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getIncomers),\n/* harmony export */   getNodesBounds: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodesBounds),\n/* harmony export */   getOutgoers: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getOutgoers),\n/* harmony export */   getSimpleBezierPath: () => (/* binding */ getSimpleBezierPath),\n/* harmony export */   getSmoothStepPath: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getSmoothStepPath),\n/* harmony export */   getStraightPath: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getStraightPath),\n/* harmony export */   getViewportForBounds: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getViewportForBounds),\n/* harmony export */   isEdge: () => (/* binding */ isEdge),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   reconnectEdge: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.reconnectEdge),\n/* harmony export */   useConnection: () => (/* binding */ useConnection),\n/* harmony export */   useEdges: () => (/* binding */ useEdges),\n/* harmony export */   useEdgesState: () => (/* binding */ useEdgesState),\n/* harmony export */   useHandleConnections: () => (/* binding */ useHandleConnections),\n/* harmony export */   useInternalNode: () => (/* binding */ useInternalNode),\n/* harmony export */   useKeyPress: () => (/* binding */ useKeyPress),\n/* harmony export */   useNodeConnections: () => (/* binding */ useNodeConnections),\n/* harmony export */   useNodeId: () => (/* binding */ useNodeId),\n/* harmony export */   useNodes: () => (/* binding */ useNodes),\n/* harmony export */   useNodesData: () => (/* binding */ useNodesData),\n/* harmony export */   useNodesInitialized: () => (/* binding */ useNodesInitialized),\n/* harmony export */   useNodesState: () => (/* binding */ useNodesState),\n/* harmony export */   useOnSelectionChange: () => (/* binding */ useOnSelectionChange),\n/* harmony export */   useOnViewportChange: () => (/* binding */ useOnViewportChange),\n/* harmony export */   useReactFlow: () => (/* binding */ useReactFlow),\n/* harmony export */   useStore: () => (/* binding */ useStore),\n/* harmony export */   useStoreApi: () => (/* binding */ useStoreApi),\n/* harmony export */   useUpdateNodeInternals: () => (/* binding */ useUpdateNodeInternals),\n/* harmony export */   useViewport: () => (/* binding */ useViewport)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/.pnpm/next@15.3.4_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/.pnpm/next@15.3.4_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var classcat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! classcat */ \"(ssr)/./node_modules/.pnpm/classcat@5.0.5/node_modules/classcat/index.js\");\n/* harmony import */ var _xyflow_system__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @xyflow/system */ \"(ssr)/./node_modules/.pnpm/@xyflow+system@0.0.63/node_modules/@xyflow/system/dist/esm/index.js\");\n/* harmony import */ var zustand_traditional__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zustand/traditional */ \"(ssr)/./node_modules/.pnpm/zustand@4.5.7_@types+react@18.3.23_react@19.1.0/node_modules/zustand/esm/traditional.mjs\");\n/* harmony import */ var zustand_shallow__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! zustand/shallow */ \"(ssr)/./node_modules/.pnpm/zustand@4.5.7_@types+react@18.3.23_react@19.1.0/node_modules/zustand/esm/shallow.mjs\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/.pnpm/next@15.3.4_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_4__);\n/* __next_internal_client_entry_do_not_use__ ConnectionLineType,ConnectionMode,MarkerType,PanOnScrollMode,Position,ResizeControlVariant,SelectionMode,addEdge,getBezierEdgeCenter,getBezierPath,getConnectedEdges,getEdgeCenter,getIncomers,getNodesBounds,getOutgoers,getSmoothStepPath,getStraightPath,getViewportForBounds,reconnectEdge,Background,BackgroundVariant,BaseEdge,BezierEdge,ControlButton,Controls,EdgeLabelRenderer,EdgeText,Handle,MiniMap,NodeResizeControl,NodeResizer,NodeToolbar,Panel,ReactFlow,ReactFlowProvider,SimpleBezierEdge,SmoothStepEdge,StepEdge,StraightEdge,ViewportPortal,applyEdgeChanges,applyNodeChanges,getSimpleBezierPath,isEdge,isNode,useConnection,useEdges,useEdgesState,useHandleConnections,useInternalNode,useKeyPress,useNodeConnections,useNodeId,useNodes,useNodesData,useNodesInitialized,useNodesState,useOnSelectionChange,useOnViewportChange,useReactFlow,useStore,useStoreApi,useUpdateNodeInternals,useViewport auto */ \n\n\n\n\n\n\n\nconst StoreContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nconst Provider$1 = StoreContext.Provider;\nconst zustandErrorMessage = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error001']();\n/**\n * This hook can be used to subscribe to internal state changes of the React Flow\n * component. The `useStore` hook is re-exported from the [Zustand](https://github.com/pmndrs/zustand)\n * state management library, so you should check out their docs for more details.\n *\n * @public\n * @param selector - A selector function that returns a slice of the flow's internal state.\n * Extracting or transforming just the state you need is a good practice to avoid unnecessary\n * re-renders.\n * @param equalityFn - A function to compare the previous and next value. This is incredibly useful\n * for preventing unnecessary re-renders. Good sensible defaults are using `Object.is` or importing\n * `zustand/shallow`, but you can be as granular as you like.\n * @returns The selected state slice.\n *\n * @example\n * ```ts\n * const nodes = useStore((state) => state.nodes);\n * ```\n *\n * @remarks This hook should only be used if there is no other way to access the internal\n * state. For many of the common use cases, there are dedicated hooks available\n * such as {@link useReactFlow}, {@link useViewport}, etc.\n */ function useStore(selector, equalityFn) {\n    const store = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(StoreContext);\n    if (store === null) {\n        throw new Error(zustandErrorMessage);\n    }\n    return (0,zustand_traditional__WEBPACK_IMPORTED_MODULE_5__.useStoreWithEqualityFn)(store, selector, equalityFn);\n}\n/**\n * In some cases, you might need to access the store directly. This hook returns the store object which can be used on demand to access the state or dispatch actions.\n *\n * @returns The store object.\n * @example\n * ```ts\n * const store = useStoreApi();\n * ```\n *\n * @remarks This hook should only be used if there is no other way to access the internal\n * state. For many of the common use cases, there are dedicated hooks available\n * such as {@link useReactFlow}, {@link useViewport}, etc.\n */ function useStoreApi() {\n    const store = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(StoreContext);\n    if (store === null) {\n        throw new Error(zustandErrorMessage);\n    }\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"useStoreApi.useMemo\": ()=>({\n                getState: store.getState,\n                setState: store.setState,\n                subscribe: store.subscribe\n            })\n    }[\"useStoreApi.useMemo\"], [\n        store\n    ]);\n}\nconst style = {\n    display: 'none'\n};\nconst ariaLiveStyle = {\n    position: 'absolute',\n    width: 1,\n    height: 1,\n    margin: -1,\n    border: 0,\n    padding: 0,\n    overflow: 'hidden',\n    clip: 'rect(0px, 0px, 0px, 0px)',\n    clipPath: 'inset(100%)'\n};\nconst ARIA_NODE_DESC_KEY = 'react-flow__node-desc';\nconst ARIA_EDGE_DESC_KEY = 'react-flow__edge-desc';\nconst ARIA_LIVE_MESSAGE = 'react-flow__aria-live';\nconst ariaLiveSelector = (s)=>s.ariaLiveMessage;\nconst ariaLabelConfigSelector = (s)=>s.ariaLabelConfig;\nfunction AriaLiveMessage({ rfId }) {\n    const ariaLiveMessage = useStore(ariaLiveSelector);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        id: `${ARIA_LIVE_MESSAGE}-${rfId}`,\n        \"aria-live\": \"assertive\",\n        \"aria-atomic\": \"true\",\n        style: ariaLiveStyle,\n        children: ariaLiveMessage\n    });\n}\nfunction A11yDescriptions({ rfId, disableKeyboardA11y }) {\n    const ariaLabelConfig = useStore(ariaLabelConfigSelector);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                id: `${ARIA_NODE_DESC_KEY}-${rfId}`,\n                style: style,\n                children: disableKeyboardA11y ? ariaLabelConfig['node.a11yDescription.default'] : ariaLabelConfig['node.a11yDescription.keyboardDisabled']\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                id: `${ARIA_EDGE_DESC_KEY}-${rfId}`,\n                style: style,\n                children: ariaLabelConfig['edge.a11yDescription.default']\n            }),\n            !disableKeyboardA11y && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(AriaLiveMessage, {\n                rfId: rfId\n            })\n        ]\n    });\n}\nconst selector$n = (s)=>s.userSelectionActive ? 'none' : 'all';\n/**\n * The `<Panel />` component helps you position content above the viewport.\n * It is used internally by the [`<MiniMap />`](/api-reference/components/minimap)\n * and [`<Controls />`](/api-reference/components/controls) components.\n *\n * @public\n *\n * @example\n * ```jsx\n *import { ReactFlow, Background, Panel } from '@xyflow/react';\n *\n *export default function Flow() {\n *  return (\n *    <ReactFlow nodes={[]} fitView>\n *      <Panel position=\"top-left\">top-left</Panel>\n *      <Panel position=\"top-center\">top-center</Panel>\n *      <Panel position=\"top-right\">top-right</Panel>\n *      <Panel position=\"bottom-left\">bottom-left</Panel>\n *      <Panel position=\"bottom-center\">bottom-center</Panel>\n *      <Panel position=\"bottom-right\">bottom-right</Panel>\n *    </ReactFlow>\n *  );\n *}\n *```\n */ const Panel = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(({ position = 'top-left', children, className, style, ...rest }, ref)=>{\n    const pointerEvents = useStore(selector$n);\n    const positionClasses = `${position}`.split('-');\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__panel',\n            className,\n            ...positionClasses\n        ]),\n        style: {\n            ...style,\n            pointerEvents\n        },\n        ref: ref,\n        ...rest,\n        children: children\n    });\n});\nPanel.displayName = 'Panel';\nfunction Attribution({ proOptions, position = 'bottom-right' }) {\n    if (proOptions?.hideAttribution) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Panel, {\n        position: position,\n        className: \"react-flow__attribution\",\n        \"data-message\": \"Please only hide this attribution when you are subscribed to React Flow Pro: https://pro.reactflow.dev\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n            href: \"https://reactflow.dev\",\n            target: \"_blank\",\n            rel: \"noopener noreferrer\",\n            \"aria-label\": \"React Flow attribution\",\n            children: \"React Flow\"\n        })\n    });\n}\nconst selector$m = (s)=>{\n    const selectedNodes = [];\n    const selectedEdges = [];\n    for (const [, node] of s.nodeLookup){\n        if (node.selected) {\n            selectedNodes.push(node.internals.userNode);\n        }\n    }\n    for (const [, edge] of s.edgeLookup){\n        if (edge.selected) {\n            selectedEdges.push(edge);\n        }\n    }\n    return {\n        selectedNodes,\n        selectedEdges\n    };\n};\nconst selectId = (obj)=>obj.id;\nfunction areEqual(a, b) {\n    return (0,zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow)(a.selectedNodes.map(selectId), b.selectedNodes.map(selectId)) && (0,zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow)(a.selectedEdges.map(selectId), b.selectedEdges.map(selectId));\n}\nfunction SelectionListenerInner({ onSelectionChange }) {\n    const store = useStoreApi();\n    const { selectedNodes, selectedEdges } = useStore(selector$m, areEqual);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"SelectionListenerInner.useEffect\": ()=>{\n            const params = {\n                nodes: selectedNodes,\n                edges: selectedEdges\n            };\n            onSelectionChange?.(params);\n            store.getState().onSelectionChangeHandlers.forEach({\n                \"SelectionListenerInner.useEffect\": (fn)=>fn(params)\n            }[\"SelectionListenerInner.useEffect\"]);\n        }\n    }[\"SelectionListenerInner.useEffect\"], [\n        selectedNodes,\n        selectedEdges,\n        onSelectionChange\n    ]);\n    return null;\n}\nconst changeSelector = (s)=>!!s.onSelectionChangeHandlers;\nfunction SelectionListener({ onSelectionChange }) {\n    const storeHasSelectionChangeHandlers = useStore(changeSelector);\n    if (onSelectionChange || storeHasSelectionChangeHandlers) {\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SelectionListenerInner, {\n            onSelectionChange: onSelectionChange\n        });\n    }\n    return null;\n}\nconst defaultNodeOrigin = [\n    0,\n    0\n];\nconst defaultViewport = {\n    x: 0,\n    y: 0,\n    zoom: 1\n};\n/*\n * This component helps us to update the store with the values coming from the user.\n * We distinguish between values we can update directly with `useDirectStoreUpdater` (like `snapGrid`)\n * and values that have a dedicated setter function in the store (like `setNodes`).\n */ // These fields exist in the global store, and we need to keep them up to date\nconst reactFlowFieldsToTrack = [\n    'nodes',\n    'edges',\n    'defaultNodes',\n    'defaultEdges',\n    'onConnect',\n    'onConnectStart',\n    'onConnectEnd',\n    'onClickConnectStart',\n    'onClickConnectEnd',\n    'nodesDraggable',\n    'autoPanOnNodeFocus',\n    'nodesConnectable',\n    'nodesFocusable',\n    'edgesFocusable',\n    'edgesReconnectable',\n    'elevateNodesOnSelect',\n    'elevateEdgesOnSelect',\n    'minZoom',\n    'maxZoom',\n    'nodeExtent',\n    'onNodesChange',\n    'onEdgesChange',\n    'elementsSelectable',\n    'connectionMode',\n    'snapGrid',\n    'snapToGrid',\n    'translateExtent',\n    'connectOnClick',\n    'defaultEdgeOptions',\n    'fitView',\n    'fitViewOptions',\n    'onNodesDelete',\n    'onEdgesDelete',\n    'onDelete',\n    'onNodeDrag',\n    'onNodeDragStart',\n    'onNodeDragStop',\n    'onSelectionDrag',\n    'onSelectionDragStart',\n    'onSelectionDragStop',\n    'onMoveStart',\n    'onMove',\n    'onMoveEnd',\n    'noPanClassName',\n    'nodeOrigin',\n    'autoPanOnConnect',\n    'autoPanOnNodeDrag',\n    'onError',\n    'connectionRadius',\n    'isValidConnection',\n    'selectNodesOnDrag',\n    'nodeDragThreshold',\n    'onBeforeDelete',\n    'debug',\n    'autoPanSpeed',\n    'paneClickDistance',\n    'ariaLabelConfig'\n];\n// rfId doesn't exist in ReactFlowProps, but it's one of the fields we want to update\nconst fieldsToTrack = [\n    ...reactFlowFieldsToTrack,\n    'rfId'\n];\nconst selector$l = (s)=>({\n        setNodes: s.setNodes,\n        setEdges: s.setEdges,\n        setMinZoom: s.setMinZoom,\n        setMaxZoom: s.setMaxZoom,\n        setTranslateExtent: s.setTranslateExtent,\n        setNodeExtent: s.setNodeExtent,\n        reset: s.reset,\n        setDefaultNodesAndEdges: s.setDefaultNodesAndEdges,\n        setPaneClickDistance: s.setPaneClickDistance\n    });\nconst initPrevValues = {\n    /*\n     * these are values that are also passed directly to other components\n     * than the StoreUpdater. We can reduce the number of setStore calls\n     * by setting the same values here as prev fields.\n     */ translateExtent: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.infiniteExtent,\n    nodeOrigin: defaultNodeOrigin,\n    minZoom: 0.5,\n    maxZoom: 2,\n    elementsSelectable: true,\n    noPanClassName: 'nopan',\n    rfId: '1',\n    paneClickDistance: 0\n};\nfunction StoreUpdater(props) {\n    const { setNodes, setEdges, setMinZoom, setMaxZoom, setTranslateExtent, setNodeExtent, reset, setDefaultNodesAndEdges, setPaneClickDistance } = useStore(selector$l, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"StoreUpdater.useEffect\": ()=>{\n            setDefaultNodesAndEdges(props.defaultNodes, props.defaultEdges);\n            return ({\n                \"StoreUpdater.useEffect\": ()=>{\n                    // when we reset the store we also need to reset the previous fields\n                    previousFields.current = initPrevValues;\n                    reset();\n                }\n            })[\"StoreUpdater.useEffect\"];\n        }\n    }[\"StoreUpdater.useEffect\"], []);\n    const previousFields = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(initPrevValues);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"StoreUpdater.useEffect\": ()=>{\n            for (const fieldName of fieldsToTrack){\n                const fieldValue = props[fieldName];\n                const previousFieldValue = previousFields.current[fieldName];\n                if (fieldValue === previousFieldValue) continue;\n                if (typeof props[fieldName] === 'undefined') continue;\n                // Custom handling with dedicated setters for some fields\n                if (fieldName === 'nodes') setNodes(fieldValue);\n                else if (fieldName === 'edges') setEdges(fieldValue);\n                else if (fieldName === 'minZoom') setMinZoom(fieldValue);\n                else if (fieldName === 'maxZoom') setMaxZoom(fieldValue);\n                else if (fieldName === 'translateExtent') setTranslateExtent(fieldValue);\n                else if (fieldName === 'nodeExtent') setNodeExtent(fieldValue);\n                else if (fieldName === 'paneClickDistance') setPaneClickDistance(fieldValue);\n                else if (fieldName === 'fitView') store.setState({\n                    fitViewQueued: fieldValue\n                });\n                else if (fieldName === 'fitViewOptions') store.setState({\n                    fitViewOptions: fieldValue\n                });\n                if (fieldName === 'ariaLabelConfig') {\n                    store.setState({\n                        ariaLabelConfig: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.mergeAriaLabelConfig)(fieldValue)\n                    });\n                } else store.setState({\n                    [fieldName]: fieldValue\n                });\n            }\n            previousFields.current = props;\n        }\n    }[\"StoreUpdater.useEffect\"], // Only re-run the effect if one of the fields we track changes\n    fieldsToTrack.map({\n        \"StoreUpdater.useEffect\": (fieldName)=>props[fieldName]\n    }[\"StoreUpdater.useEffect\"]));\n    return null;\n}\nfunction getMediaQuery() {\n    if (true) {\n        return null;\n    }\n    return window.matchMedia('(prefers-color-scheme: dark)');\n}\n/**\n * Hook for receiving the current color mode class 'dark' or 'light'.\n *\n * @internal\n * @param colorMode - The color mode to use ('dark', 'light' or 'system')\n */ function useColorModeClass(colorMode) {\n    const [colorModeClass, setColorModeClass] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(colorMode === 'system' ? null : colorMode);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useColorModeClass.useEffect\": ()=>{\n            if (colorMode !== 'system') {\n                setColorModeClass(colorMode);\n                return;\n            }\n            const mediaQuery = getMediaQuery();\n            const updateColorModeClass = {\n                \"useColorModeClass.useEffect.updateColorModeClass\": ()=>setColorModeClass(mediaQuery?.matches ? 'dark' : 'light')\n            }[\"useColorModeClass.useEffect.updateColorModeClass\"];\n            updateColorModeClass();\n            mediaQuery?.addEventListener('change', updateColorModeClass);\n            return ({\n                \"useColorModeClass.useEffect\": ()=>{\n                    mediaQuery?.removeEventListener('change', updateColorModeClass);\n                }\n            })[\"useColorModeClass.useEffect\"];\n        }\n    }[\"useColorModeClass.useEffect\"], [\n        colorMode\n    ]);\n    return colorModeClass !== null ? colorModeClass : getMediaQuery()?.matches ? 'dark' : 'light';\n}\nconst defaultDoc = typeof document !== 'undefined' ? document : null;\n/**\n * This hook lets you listen for specific key codes and tells you whether they are\n * currently pressed or not.\n *\n * @public\n * @param options - Options\n *\n * @example\n * ```tsx\n *import { useKeyPress } from '@xyflow/react';\n *\n *export default function () {\n *  const spacePressed = useKeyPress('Space');\n *  const cmdAndSPressed = useKeyPress(['Meta+s', 'Strg+s']);\n *\n *  return (\n *    <div>\n *     {spacePressed && <p>Space pressed!</p>}\n *     {cmdAndSPressed && <p>Cmd + S pressed!</p>}\n *    </div>\n *  );\n *}\n *```\n */ function useKeyPress(/**\n * The key code (string or array of strings) specifies which key(s) should trigger\n * an action.\n *\n * A **string** can represent:\n * - A **single key**, e.g. `'a'`\n * - A **key combination**, using `'+'` to separate keys, e.g. `'a+d'`\n *\n * An  **array of strings** represents **multiple possible key inputs**. For example, `['a', 'd+s']`\n * means the user can press either the single key `'a'` or the combination of `'d'` and `'s'`.\n * @default null\n */ keyCode = null, options = {\n    target: defaultDoc,\n    actInsideInputWithModifier: true\n}) {\n    const [keyPressed, setKeyPressed] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // we need to remember if a modifier key is pressed in order to track it\n    const modifierPressed = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    // we need to remember the pressed keys in order to support combinations\n    const pressedKeys = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Set([]));\n    /*\n     * keyCodes = array with single keys [['a']] or key combinations [['a', 's']]\n     * keysToWatch = array with all keys flattened ['a', 'd', 'ShiftLeft']\n     * used to check if we store event.code or event.key. When the code is in the list of keysToWatch\n     * we use the code otherwise the key. Explainer: When you press the left \"command\" key, the code is \"MetaLeft\"\n     * and the key is \"Meta\". We want users to be able to pass keys and codes so we assume that the key is meant when\n     * we can't find it in the list of keysToWatch.\n     */ const [keyCodes, keysToWatch] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"useKeyPress.useMemo\": ()=>{\n            if (keyCode !== null) {\n                const keyCodeArr = Array.isArray(keyCode) ? keyCode : [\n                    keyCode\n                ];\n                const keys = keyCodeArr.filter({\n                    \"useKeyPress.useMemo.keys\": (kc)=>typeof kc === 'string'\n                }[\"useKeyPress.useMemo.keys\"])/*\n                 * we first replace all '+' with '\\n'  which we will use to split the keys on\n                 * then we replace '\\n\\n' with '\\n+', this way we can also support the combination 'key++'\n                 * in the end we simply split on '\\n' to get the key array\n                 */ .map({\n                    \"useKeyPress.useMemo.keys\": (kc)=>kc.replace('+', '\\n').replace('\\n\\n', '\\n+').split('\\n')\n                }[\"useKeyPress.useMemo.keys\"]);\n                const keysFlat = keys.reduce({\n                    \"useKeyPress.useMemo.keysFlat\": (res, item)=>res.concat(...item)\n                }[\"useKeyPress.useMemo.keysFlat\"], []);\n                return [\n                    keys,\n                    keysFlat\n                ];\n            }\n            return [\n                [],\n                []\n            ];\n        }\n    }[\"useKeyPress.useMemo\"], [\n        keyCode\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useKeyPress.useEffect\": ()=>{\n            const target = options?.target ?? defaultDoc;\n            const actInsideInputWithModifier = options?.actInsideInputWithModifier ?? true;\n            if (keyCode !== null) {\n                const downHandler = {\n                    \"useKeyPress.useEffect.downHandler\": (event)=>{\n                        modifierPressed.current = event.ctrlKey || event.metaKey || event.shiftKey || event.altKey;\n                        const preventAction = (!modifierPressed.current || modifierPressed.current && !actInsideInputWithModifier) && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isInputDOMNode)(event);\n                        if (preventAction) {\n                            return false;\n                        }\n                        const keyOrCode = useKeyOrCode(event.code, keysToWatch);\n                        pressedKeys.current.add(event[keyOrCode]);\n                        if (isMatchingKey(keyCodes, pressedKeys.current, false)) {\n                            const target = event.composedPath?.()?.[0] || event.target;\n                            const isInteractiveElement = target?.nodeName === 'BUTTON' || target?.nodeName === 'A';\n                            if (options.preventDefault !== false && (modifierPressed.current || !isInteractiveElement)) {\n                                event.preventDefault();\n                            }\n                            setKeyPressed(true);\n                        }\n                    }\n                }[\"useKeyPress.useEffect.downHandler\"];\n                const upHandler = {\n                    \"useKeyPress.useEffect.upHandler\": (event)=>{\n                        const keyOrCode = useKeyOrCode(event.code, keysToWatch);\n                        if (isMatchingKey(keyCodes, pressedKeys.current, true)) {\n                            setKeyPressed(false);\n                            pressedKeys.current.clear();\n                        } else {\n                            pressedKeys.current.delete(event[keyOrCode]);\n                        }\n                        // fix for Mac: when cmd key is pressed, keyup is not triggered for any other key, see: https://stackoverflow.com/questions/27380018/when-cmd-key-is-kept-pressed-keyup-is-not-triggered-for-any-other-key\n                        if (event.key === 'Meta') {\n                            pressedKeys.current.clear();\n                        }\n                        modifierPressed.current = false;\n                    }\n                }[\"useKeyPress.useEffect.upHandler\"];\n                const resetHandler = {\n                    \"useKeyPress.useEffect.resetHandler\": ()=>{\n                        pressedKeys.current.clear();\n                        setKeyPressed(false);\n                    }\n                }[\"useKeyPress.useEffect.resetHandler\"];\n                target?.addEventListener('keydown', downHandler);\n                target?.addEventListener('keyup', upHandler);\n                window.addEventListener('blur', resetHandler);\n                window.addEventListener('contextmenu', resetHandler);\n                return ({\n                    \"useKeyPress.useEffect\": ()=>{\n                        target?.removeEventListener('keydown', downHandler);\n                        target?.removeEventListener('keyup', upHandler);\n                        window.removeEventListener('blur', resetHandler);\n                        window.removeEventListener('contextmenu', resetHandler);\n                    }\n                })[\"useKeyPress.useEffect\"];\n            }\n        }\n    }[\"useKeyPress.useEffect\"], [\n        keyCode,\n        setKeyPressed\n    ]);\n    return keyPressed;\n}\n// utils\nfunction isMatchingKey(keyCodes, pressedKeys, isUp) {\n    return keyCodes/*\n         * we only want to compare same sizes of keyCode definitions\n         * and pressed keys. When the user specified 'Meta' as a key somewhere\n         * this would also be truthy without this filter when user presses 'Meta' + 'r'\n         */ .filter((keys)=>isUp || keys.length === pressedKeys.size)/*\n         * since we want to support multiple possibilities only one of the\n         * combinations need to be part of the pressed keys\n         */ .some((keys)=>keys.every((k)=>pressedKeys.has(k)));\n}\nfunction useKeyOrCode(eventCode, keysToWatch) {\n    return keysToWatch.includes(eventCode) ? 'code' : 'key';\n}\n/**\n * Hook for getting viewport helper functions.\n *\n * @internal\n * @returns viewport helper functions\n */ const useViewportHelper = ()=>{\n    const store = useStoreApi();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"useViewportHelper.useMemo\": ()=>{\n            return {\n                zoomIn: ({\n                    \"useViewportHelper.useMemo\": (options)=>{\n                        const { panZoom } = store.getState();\n                        return panZoom ? panZoom.scaleBy(1.2, {\n                            duration: options?.duration\n                        }) : Promise.resolve(false);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                zoomOut: ({\n                    \"useViewportHelper.useMemo\": (options)=>{\n                        const { panZoom } = store.getState();\n                        return panZoom ? panZoom.scaleBy(1 / 1.2, {\n                            duration: options?.duration\n                        }) : Promise.resolve(false);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                zoomTo: ({\n                    \"useViewportHelper.useMemo\": (zoomLevel, options)=>{\n                        const { panZoom } = store.getState();\n                        return panZoom ? panZoom.scaleTo(zoomLevel, {\n                            duration: options?.duration\n                        }) : Promise.resolve(false);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                getZoom: ({\n                    \"useViewportHelper.useMemo\": ()=>store.getState().transform[2]\n                })[\"useViewportHelper.useMemo\"],\n                setViewport: ({\n                    \"useViewportHelper.useMemo\": async (viewport, options)=>{\n                        const { transform: [tX, tY, tZoom], panZoom } = store.getState();\n                        if (!panZoom) {\n                            return Promise.resolve(false);\n                        }\n                        await panZoom.setViewport({\n                            x: viewport.x ?? tX,\n                            y: viewport.y ?? tY,\n                            zoom: viewport.zoom ?? tZoom\n                        }, options);\n                        return Promise.resolve(true);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                getViewport: ({\n                    \"useViewportHelper.useMemo\": ()=>{\n                        const [x, y, zoom] = store.getState().transform;\n                        return {\n                            x,\n                            y,\n                            zoom\n                        };\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                setCenter: ({\n                    \"useViewportHelper.useMemo\": async (x, y, options)=>{\n                        return store.getState().setCenter(x, y, options);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                fitBounds: ({\n                    \"useViewportHelper.useMemo\": async (bounds, options)=>{\n                        const { width, height, minZoom, maxZoom, panZoom } = store.getState();\n                        const viewport = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getViewportForBounds)(bounds, width, height, minZoom, maxZoom, options?.padding ?? 0.1);\n                        if (!panZoom) {\n                            return Promise.resolve(false);\n                        }\n                        await panZoom.setViewport(viewport, {\n                            duration: options?.duration,\n                            ease: options?.ease,\n                            interpolate: options?.interpolate\n                        });\n                        return Promise.resolve(true);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                screenToFlowPosition: ({\n                    \"useViewportHelper.useMemo\": (clientPosition, options = {})=>{\n                        const { transform, snapGrid, snapToGrid, domNode } = store.getState();\n                        if (!domNode) {\n                            return clientPosition;\n                        }\n                        const { x: domX, y: domY } = domNode.getBoundingClientRect();\n                        const correctedPosition = {\n                            x: clientPosition.x - domX,\n                            y: clientPosition.y - domY\n                        };\n                        const _snapGrid = options.snapGrid ?? snapGrid;\n                        const _snapToGrid = options.snapToGrid ?? snapToGrid;\n                        return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.pointToRendererPoint)(correctedPosition, transform, _snapToGrid, _snapGrid);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                flowToScreenPosition: ({\n                    \"useViewportHelper.useMemo\": (flowPosition)=>{\n                        const { transform, domNode } = store.getState();\n                        if (!domNode) {\n                            return flowPosition;\n                        }\n                        const { x: domX, y: domY } = domNode.getBoundingClientRect();\n                        const rendererPosition = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.rendererPointToPoint)(flowPosition, transform);\n                        return {\n                            x: rendererPosition.x + domX,\n                            y: rendererPosition.y + domY\n                        };\n                    }\n                })[\"useViewportHelper.useMemo\"]\n            };\n        }\n    }[\"useViewportHelper.useMemo\"], []);\n};\n/*\n * This function applies changes to nodes or edges that are triggered by React Flow internally.\n * When you drag a node for example, React Flow will send a position change update.\n * This function then applies the changes and returns the updated elements.\n */ function applyChanges(changes, elements) {\n    const updatedElements = [];\n    /*\n     * By storing a map of changes for each element, we can a quick lookup as we\n     * iterate over the elements array!\n     */ const changesMap = new Map();\n    const addItemChanges = [];\n    for (const change of changes){\n        if (change.type === 'add') {\n            addItemChanges.push(change);\n            continue;\n        } else if (change.type === 'remove' || change.type === 'replace') {\n            /*\n             * For a 'remove' change we can safely ignore any other changes queued for\n             * the same element, it's going to be removed anyway!\n             */ changesMap.set(change.id, [\n                change\n            ]);\n        } else {\n            const elementChanges = changesMap.get(change.id);\n            if (elementChanges) {\n                /*\n                 * If we have some changes queued already, we can do a mutable update of\n                 * that array and save ourselves some copying.\n                 */ elementChanges.push(change);\n            } else {\n                changesMap.set(change.id, [\n                    change\n                ]);\n            }\n        }\n    }\n    for (const element of elements){\n        const changes = changesMap.get(element.id);\n        /*\n         * When there are no changes for an element we can just push it unmodified,\n         * no need to copy it.\n         */ if (!changes) {\n            updatedElements.push(element);\n            continue;\n        }\n        // If we have a 'remove' change queued, it'll be the only change in the array\n        if (changes[0].type === 'remove') {\n            continue;\n        }\n        if (changes[0].type === 'replace') {\n            updatedElements.push({\n                ...changes[0].item\n            });\n            continue;\n        }\n        /**\n         * For other types of changes, we want to start with a shallow copy of the\n         * object so React knows this element has changed. Sequential changes will\n         * each _mutate_ this object, so there's only ever one copy.\n         */ const updatedElement = {\n            ...element\n        };\n        for (const change of changes){\n            applyChange(change, updatedElement);\n        }\n        updatedElements.push(updatedElement);\n    }\n    /*\n     * we need to wait for all changes to be applied before adding new items\n     * to be able to add them at the correct index\n     */ if (addItemChanges.length) {\n        addItemChanges.forEach((change)=>{\n            if (change.index !== undefined) {\n                updatedElements.splice(change.index, 0, {\n                    ...change.item\n                });\n            } else {\n                updatedElements.push({\n                    ...change.item\n                });\n            }\n        });\n    }\n    return updatedElements;\n}\n// Applies a single change to an element. This is a *mutable* update.\nfunction applyChange(change, element) {\n    switch(change.type){\n        case 'select':\n            {\n                element.selected = change.selected;\n                break;\n            }\n        case 'position':\n            {\n                if (typeof change.position !== 'undefined') {\n                    element.position = change.position;\n                }\n                if (typeof change.dragging !== 'undefined') {\n                    element.dragging = change.dragging;\n                }\n                break;\n            }\n        case 'dimensions':\n            {\n                if (typeof change.dimensions !== 'undefined') {\n                    element.measured ??= {};\n                    element.measured.width = change.dimensions.width;\n                    element.measured.height = change.dimensions.height;\n                    if (change.setAttributes) {\n                        if (change.setAttributes === true || change.setAttributes === 'width') {\n                            element.width = change.dimensions.width;\n                        }\n                        if (change.setAttributes === true || change.setAttributes === 'height') {\n                            element.height = change.dimensions.height;\n                        }\n                    }\n                }\n                if (typeof change.resizing === 'boolean') {\n                    element.resizing = change.resizing;\n                }\n                break;\n            }\n    }\n}\n/**\n * Drop in function that applies node changes to an array of nodes.\n * @public\n * @param changes - Array of changes to apply.\n * @param nodes - Array of nodes to apply the changes to.\n * @returns Array of updated nodes.\n * @example\n *```tsx\n *import { useState, useCallback } from 'react';\n *import { ReactFlow, applyNodeChanges, type Node, type Edge, type OnNodesChange } from '@xyflow/react';\n *\n *export default function Flow() {\n *  const [nodes, setNodes] = useState<Node[]>([]);\n *  const [edges, setEdges] = useState<Edge[]>([]);\n *  const onNodesChange: OnNodesChange = useCallback(\n *    (changes) => {\n *      setNodes((oldNodes) => applyNodeChanges(changes, oldNodes));\n *    },\n *    [setNodes],\n *  );\n *\n *  return (\n *    <ReactFlow nodes={nodes} edges={edges} onNodesChange={onNodesChange} />\n *  );\n *}\n *```\n * @remarks Various events on the <ReactFlow /> component can produce an {@link NodeChange}\n * that describes how to update the edges of your flow in some way.\n * If you don't need any custom behaviour, this util can be used to take an array\n * of these changes and apply them to your edges.\n */ function applyNodeChanges(changes, nodes) {\n    return applyChanges(changes, nodes);\n}\n/**\n * Drop in function that applies edge changes to an array of edges.\n * @public\n * @param changes - Array of changes to apply.\n * @param edges - Array of edge to apply the changes to.\n * @returns Array of updated edges.\n * @example\n * ```tsx\n *import { useState, useCallback } from 'react';\n *import { ReactFlow, applyEdgeChanges } from '@xyflow/react';\n *\n *export default function Flow() {\n *  const [nodes, setNodes] = useState([]);\n *  const [edges, setEdges] = useState([]);\n *  const onEdgesChange = useCallback(\n *    (changes) => {\n *      setEdges((oldEdges) => applyEdgeChanges(changes, oldEdges));\n *    },\n *    [setEdges],\n *  );\n *\n *  return (\n *    <ReactFlow nodes={nodes} edges={edges} onEdgesChange={onEdgesChange} />\n *  );\n *}\n *```\n * @remarks Various events on the <ReactFlow /> component can produce an {@link EdgeChange}\n * that describes how to update the edges of your flow in some way.\n * If you don't need any custom behaviour, this util can be used to take an array\n * of these changes and apply them to your edges.\n */ function applyEdgeChanges(changes, edges) {\n    return applyChanges(changes, edges);\n}\nfunction createSelectionChange(id, selected) {\n    return {\n        id,\n        type: 'select',\n        selected\n    };\n}\nfunction getSelectionChanges(items, selectedIds = new Set(), mutateItem = false) {\n    const changes = [];\n    for (const [id, item] of items){\n        const willBeSelected = selectedIds.has(id);\n        // we don't want to set all items to selected=false on the first selection\n        if (!(item.selected === undefined && !willBeSelected) && item.selected !== willBeSelected) {\n            if (mutateItem) {\n                /*\n                 * this hack is needed for nodes. When the user dragged a node, it's selected.\n                 * When another node gets dragged, we need to deselect the previous one,\n                 * in order to have only one selected node at a time - the onNodesChange callback comes too late here :/\n                 */ item.selected = willBeSelected;\n            }\n            changes.push(createSelectionChange(item.id, willBeSelected));\n        }\n    }\n    return changes;\n}\nfunction getElementsDiffChanges({ items = [], lookup }) {\n    const changes = [];\n    const itemsLookup = new Map(items.map((item)=>[\n            item.id,\n            item\n        ]));\n    for (const [index, item] of items.entries()){\n        const lookupItem = lookup.get(item.id);\n        const storeItem = lookupItem?.internals?.userNode ?? lookupItem;\n        if (storeItem !== undefined && storeItem !== item) {\n            changes.push({\n                id: item.id,\n                item: item,\n                type: 'replace'\n            });\n        }\n        if (storeItem === undefined) {\n            changes.push({\n                item: item,\n                type: 'add',\n                index\n            });\n        }\n    }\n    for (const [id] of lookup){\n        const nextNode = itemsLookup.get(id);\n        if (nextNode === undefined) {\n            changes.push({\n                id,\n                type: 'remove'\n            });\n        }\n    }\n    return changes;\n}\nfunction elementToRemoveChange(item) {\n    return {\n        id: item.id,\n        type: 'remove'\n    };\n}\n/**\n * Test whether an object is usable as an [`Node`](/api-reference/types/node).\n * In TypeScript this is a type guard that will narrow the type of whatever you pass in to\n * [`Node`](/api-reference/types/node) if it returns `true`.\n *\n * @public\n * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Node if it returns true\n * @param element - The element to test.\n * @returns Tests whether the provided value can be used as a `Node`. If you're using TypeScript,\n * this function acts as a type guard and will narrow the type of the value to `Node` if it returns\n * `true`.\n *\n * @example\n * ```js\n *import { isNode } from '@xyflow/react';\n *\n *if (isNode(node)) {\n * // ...\n *}\n *```\n */ const isNode = (element)=>(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isNodeBase)(element);\n/**\n * Test whether an object is usable as an [`Edge`](/api-reference/types/edge).\n * In TypeScript this is a type guard that will narrow the type of whatever you pass in to\n * [`Edge`](/api-reference/types/edge) if it returns `true`.\n *\n * @public\n * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Edge if it returns true\n * @param element - The element to test\n * @returns Tests whether the provided value can be used as an `Edge`. If you're using TypeScript,\n * this function acts as a type guard and will narrow the type of the value to `Edge` if it returns\n * `true`.\n *\n * @example\n * ```js\n *import { isEdge } from '@xyflow/react';\n *\n *if (isEdge(edge)) {\n * // ...\n *}\n *```\n */ const isEdge = (element)=>(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isEdgeBase)(element);\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nfunction fixedForwardRef(render) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(render);\n}\n// we need this hook to prevent a warning when using react-flow in SSR\nconst useIsomorphicLayoutEffect =  false ? 0 : react__WEBPACK_IMPORTED_MODULE_1__.useEffect;\n/**\n * This hook returns a queue that can be used to batch updates.\n *\n * @param runQueue - a function that gets called when the queue is flushed\n * @internal\n *\n * @returns a Queue object\n */ function useQueue(runQueue) {\n    /*\n     * Because we're using a ref above, we need some way to let React know when to\n     * actually process the queue. We increment this number any time we mutate the\n     * queue, creating a new state to trigger the layout effect below.\n     * Using a boolean dirty flag here instead would lead to issues related to\n     * automatic batching. (https://github.com/xyflow/xyflow/issues/4779)\n     */ const [serial, setSerial] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(BigInt(0));\n    /*\n     * A reference of all the batched updates to process before the next render. We\n     * want a reference here so multiple synchronous calls to `setNodes` etc can be\n     * batched together.\n     */ const [queue] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        \"useQueue.useState\": ()=>createQueue({\n                \"useQueue.useState\": ()=>setSerial({\n                        \"useQueue.useState\": (n)=>n + BigInt(1)\n                    }[\"useQueue.useState\"])\n            }[\"useQueue.useState\"])\n    }[\"useQueue.useState\"]);\n    /*\n     * Layout effects are guaranteed to run before the next render which means we\n     * shouldn't run into any issues with stale state or weird issues that come from\n     * rendering things one frame later than expected (we used to use `setTimeout`).\n     */ useIsomorphicLayoutEffect({\n        \"useQueue.useIsomorphicLayoutEffect\": ()=>{\n            const queueItems = queue.get();\n            if (queueItems.length) {\n                runQueue(queueItems);\n                queue.reset();\n            }\n        }\n    }[\"useQueue.useIsomorphicLayoutEffect\"], [\n        serial\n    ]);\n    return queue;\n}\nfunction createQueue(cb) {\n    let queue = [];\n    return {\n        get: ()=>queue,\n        reset: ()=>{\n            queue = [];\n        },\n        push: (item)=>{\n            queue.push(item);\n            cb();\n        }\n    };\n}\nconst BatchContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\n/**\n * This is a context provider that holds and processes the node and edge update queues\n * that are needed to handle setNodes, addNodes, setEdges and addEdges.\n *\n * @internal\n */ function BatchProvider({ children }) {\n    const store = useStoreApi();\n    const nodeQueueHandler = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"BatchProvider.useCallback[nodeQueueHandler]\": (queueItems)=>{\n            const { nodes = [], setNodes, hasDefaultNodes, onNodesChange, nodeLookup, fitViewQueued } = store.getState();\n            /*\n         * This is essentially an `Array.reduce` in imperative clothing. Processing\n         * this queue is a relatively hot path so we'd like to avoid the overhead of\n         * array methods where we can.\n         */ let next = nodes;\n            for (const payload of queueItems){\n                next = typeof payload === 'function' ? payload(next) : payload;\n            }\n            const changes = getElementsDiffChanges({\n                items: next,\n                lookup: nodeLookup\n            });\n            if (hasDefaultNodes) {\n                setNodes(next);\n            }\n            // We only want to fire onNodesChange if there are changes to the nodes\n            if (changes.length > 0) {\n                onNodesChange?.(changes);\n            } else if (fitViewQueued) {\n                // If there are no changes to the nodes, we still need to call setNodes\n                // to trigger a re-render and fitView.\n                window.requestAnimationFrame({\n                    \"BatchProvider.useCallback[nodeQueueHandler]\": ()=>{\n                        const { fitViewQueued, nodes, setNodes } = store.getState();\n                        if (fitViewQueued) {\n                            setNodes(nodes);\n                        }\n                    }\n                }[\"BatchProvider.useCallback[nodeQueueHandler]\"]);\n            }\n        }\n    }[\"BatchProvider.useCallback[nodeQueueHandler]\"], []);\n    const nodeQueue = useQueue(nodeQueueHandler);\n    const edgeQueueHandler = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"BatchProvider.useCallback[edgeQueueHandler]\": (queueItems)=>{\n            const { edges = [], setEdges, hasDefaultEdges, onEdgesChange, edgeLookup } = store.getState();\n            let next = edges;\n            for (const payload of queueItems){\n                next = typeof payload === 'function' ? payload(next) : payload;\n            }\n            if (hasDefaultEdges) {\n                setEdges(next);\n            } else if (onEdgesChange) {\n                onEdgesChange(getElementsDiffChanges({\n                    items: next,\n                    lookup: edgeLookup\n                }));\n            }\n        }\n    }[\"BatchProvider.useCallback[edgeQueueHandler]\"], []);\n    const edgeQueue = useQueue(edgeQueueHandler);\n    const value = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"BatchProvider.useMemo[value]\": ()=>({\n                nodeQueue,\n                edgeQueue\n            })\n    }[\"BatchProvider.useMemo[value]\"], []);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BatchContext.Provider, {\n        value: value,\n        children: children\n    });\n}\nfunction useBatchContext() {\n    const batchContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(BatchContext);\n    if (!batchContext) {\n        throw new Error('useBatchContext must be used within a BatchProvider');\n    }\n    return batchContext;\n}\nconst selector$k = (s)=>!!s.panZoom;\n/**\n * This hook returns a ReactFlowInstance that can be used to update nodes and edges, manipulate the viewport, or query the current state of the flow.\n *\n * @public\n * @example\n * ```jsx\n *import { useCallback, useState } from 'react';\n *import { useReactFlow } from '@xyflow/react';\n *\n *export function NodeCounter() {\n *  const reactFlow = useReactFlow();\n *  const [count, setCount] = useState(0);\n *  const countNodes = useCallback(() => {\n *    setCount(reactFlow.getNodes().length);\n *    // you need to pass it as a dependency if you are using it with useEffect or useCallback\n *    // because at the first render, it's not initialized yet and some functions might not work.\n *  }, [reactFlow]);\n *\n *  return (\n *    <div>\n *      <button onClick={countNodes}>Update count</button>\n *      <p>There are {count} nodes in the flow.</p>\n *    </div>\n *  );\n *}\n *```\n */ function useReactFlow() {\n    const viewportHelper = useViewportHelper();\n    const store = useStoreApi();\n    const batchContext = useBatchContext();\n    const viewportInitialized = useStore(selector$k);\n    const generalHelper = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"useReactFlow.useMemo[generalHelper]\": ()=>{\n            const getInternalNode = {\n                \"useReactFlow.useMemo[generalHelper].getInternalNode\": (id)=>store.getState().nodeLookup.get(id)\n            }[\"useReactFlow.useMemo[generalHelper].getInternalNode\"];\n            const setNodes = {\n                \"useReactFlow.useMemo[generalHelper].setNodes\": (payload)=>{\n                    batchContext.nodeQueue.push(payload);\n                }\n            }[\"useReactFlow.useMemo[generalHelper].setNodes\"];\n            const setEdges = {\n                \"useReactFlow.useMemo[generalHelper].setEdges\": (payload)=>{\n                    batchContext.edgeQueue.push(payload);\n                }\n            }[\"useReactFlow.useMemo[generalHelper].setEdges\"];\n            const getNodeRect = {\n                \"useReactFlow.useMemo[generalHelper].getNodeRect\": (node)=>{\n                    const { nodeLookup, nodeOrigin } = store.getState();\n                    const nodeToUse = isNode(node) ? node : nodeLookup.get(node.id);\n                    const position = nodeToUse.parentId ? (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.evaluateAbsolutePosition)(nodeToUse.position, nodeToUse.measured, nodeToUse.parentId, nodeLookup, nodeOrigin) : nodeToUse.position;\n                    const nodeWithPosition = {\n                        ...nodeToUse,\n                        position,\n                        width: nodeToUse.measured?.width ?? nodeToUse.width,\n                        height: nodeToUse.measured?.height ?? nodeToUse.height\n                    };\n                    return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.nodeToRect)(nodeWithPosition);\n                }\n            }[\"useReactFlow.useMemo[generalHelper].getNodeRect\"];\n            const updateNode = {\n                \"useReactFlow.useMemo[generalHelper].updateNode\": (id, nodeUpdate, options = {\n                    replace: false\n                })=>{\n                    setNodes({\n                        \"useReactFlow.useMemo[generalHelper].updateNode\": (prevNodes)=>prevNodes.map({\n                                \"useReactFlow.useMemo[generalHelper].updateNode\": (node)=>{\n                                    if (node.id === id) {\n                                        const nextNode = typeof nodeUpdate === 'function' ? nodeUpdate(node) : nodeUpdate;\n                                        return options.replace && isNode(nextNode) ? nextNode : {\n                                            ...node,\n                                            ...nextNode\n                                        };\n                                    }\n                                    return node;\n                                }\n                            }[\"useReactFlow.useMemo[generalHelper].updateNode\"])\n                    }[\"useReactFlow.useMemo[generalHelper].updateNode\"]);\n                }\n            }[\"useReactFlow.useMemo[generalHelper].updateNode\"];\n            const updateEdge = {\n                \"useReactFlow.useMemo[generalHelper].updateEdge\": (id, edgeUpdate, options = {\n                    replace: false\n                })=>{\n                    setEdges({\n                        \"useReactFlow.useMemo[generalHelper].updateEdge\": (prevEdges)=>prevEdges.map({\n                                \"useReactFlow.useMemo[generalHelper].updateEdge\": (edge)=>{\n                                    if (edge.id === id) {\n                                        const nextEdge = typeof edgeUpdate === 'function' ? edgeUpdate(edge) : edgeUpdate;\n                                        return options.replace && isEdge(nextEdge) ? nextEdge : {\n                                            ...edge,\n                                            ...nextEdge\n                                        };\n                                    }\n                                    return edge;\n                                }\n                            }[\"useReactFlow.useMemo[generalHelper].updateEdge\"])\n                    }[\"useReactFlow.useMemo[generalHelper].updateEdge\"]);\n                }\n            }[\"useReactFlow.useMemo[generalHelper].updateEdge\"];\n            return {\n                getNodes: ({\n                    \"useReactFlow.useMemo[generalHelper]\": ()=>store.getState().nodes.map({\n                            \"useReactFlow.useMemo[generalHelper]\": (n)=>({\n                                    ...n\n                                })\n                        }[\"useReactFlow.useMemo[generalHelper]\"])\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                getNode: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (id)=>getInternalNode(id)?.internals.userNode\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                getInternalNode,\n                getEdges: ({\n                    \"useReactFlow.useMemo[generalHelper]\": ()=>{\n                        const { edges = [] } = store.getState();\n                        return edges.map({\n                            \"useReactFlow.useMemo[generalHelper]\": (e)=>({\n                                    ...e\n                                })\n                        }[\"useReactFlow.useMemo[generalHelper]\"]);\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                getEdge: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (id)=>store.getState().edgeLookup.get(id)\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                setNodes,\n                setEdges,\n                addNodes: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (payload)=>{\n                        const newNodes = Array.isArray(payload) ? payload : [\n                            payload\n                        ];\n                        batchContext.nodeQueue.push({\n                            \"useReactFlow.useMemo[generalHelper]\": (nodes)=>[\n                                    ...nodes,\n                                    ...newNodes\n                                ]\n                        }[\"useReactFlow.useMemo[generalHelper]\"]);\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                addEdges: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (payload)=>{\n                        const newEdges = Array.isArray(payload) ? payload : [\n                            payload\n                        ];\n                        batchContext.edgeQueue.push({\n                            \"useReactFlow.useMemo[generalHelper]\": (edges)=>[\n                                    ...edges,\n                                    ...newEdges\n                                ]\n                        }[\"useReactFlow.useMemo[generalHelper]\"]);\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                toObject: ({\n                    \"useReactFlow.useMemo[generalHelper]\": ()=>{\n                        const { nodes = [], edges = [], transform } = store.getState();\n                        const [x, y, zoom] = transform;\n                        return {\n                            nodes: nodes.map({\n                                \"useReactFlow.useMemo[generalHelper]\": (n)=>({\n                                        ...n\n                                    })\n                            }[\"useReactFlow.useMemo[generalHelper]\"]),\n                            edges: edges.map({\n                                \"useReactFlow.useMemo[generalHelper]\": (e)=>({\n                                        ...e\n                                    })\n                            }[\"useReactFlow.useMemo[generalHelper]\"]),\n                            viewport: {\n                                x,\n                                y,\n                                zoom\n                            }\n                        };\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                deleteElements: ({\n                    \"useReactFlow.useMemo[generalHelper]\": async ({ nodes: nodesToRemove = [], edges: edgesToRemove = [] })=>{\n                        const { nodes, edges, onNodesDelete, onEdgesDelete, triggerNodeChanges, triggerEdgeChanges, onDelete, onBeforeDelete } = store.getState();\n                        const { nodes: matchingNodes, edges: matchingEdges } = await (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getElementsToRemove)({\n                            nodesToRemove,\n                            edgesToRemove,\n                            nodes,\n                            edges,\n                            onBeforeDelete\n                        });\n                        const hasMatchingEdges = matchingEdges.length > 0;\n                        const hasMatchingNodes = matchingNodes.length > 0;\n                        if (hasMatchingEdges) {\n                            const edgeChanges = matchingEdges.map(elementToRemoveChange);\n                            onEdgesDelete?.(matchingEdges);\n                            triggerEdgeChanges(edgeChanges);\n                        }\n                        if (hasMatchingNodes) {\n                            const nodeChanges = matchingNodes.map(elementToRemoveChange);\n                            onNodesDelete?.(matchingNodes);\n                            triggerNodeChanges(nodeChanges);\n                        }\n                        if (hasMatchingNodes || hasMatchingEdges) {\n                            onDelete?.({\n                                nodes: matchingNodes,\n                                edges: matchingEdges\n                            });\n                        }\n                        return {\n                            deletedNodes: matchingNodes,\n                            deletedEdges: matchingEdges\n                        };\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                getIntersectingNodes: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (nodeOrRect, partially = true, nodes)=>{\n                        const isRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isRectObject)(nodeOrRect);\n                        const nodeRect = isRect ? nodeOrRect : getNodeRect(nodeOrRect);\n                        const hasNodesOption = nodes !== undefined;\n                        if (!nodeRect) {\n                            return [];\n                        }\n                        return (nodes || store.getState().nodes).filter({\n                            \"useReactFlow.useMemo[generalHelper]\": (n)=>{\n                                const internalNode = store.getState().nodeLookup.get(n.id);\n                                if (internalNode && !isRect && (n.id === nodeOrRect.id || !internalNode.internals.positionAbsolute)) {\n                                    return false;\n                                }\n                                const currNodeRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.nodeToRect)(hasNodesOption ? n : internalNode);\n                                const overlappingArea = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getOverlappingArea)(currNodeRect, nodeRect);\n                                const partiallyVisible = partially && overlappingArea > 0;\n                                return partiallyVisible || overlappingArea >= nodeRect.width * nodeRect.height;\n                            }\n                        }[\"useReactFlow.useMemo[generalHelper]\"]);\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                isNodeIntersecting: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (nodeOrRect, area, partially = true)=>{\n                        const isRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isRectObject)(nodeOrRect);\n                        const nodeRect = isRect ? nodeOrRect : getNodeRect(nodeOrRect);\n                        if (!nodeRect) {\n                            return false;\n                        }\n                        const overlappingArea = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getOverlappingArea)(nodeRect, area);\n                        const partiallyVisible = partially && overlappingArea > 0;\n                        return partiallyVisible || overlappingArea >= nodeRect.width * nodeRect.height;\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                updateNode,\n                updateNodeData: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (id, dataUpdate, options = {\n                        replace: false\n                    })=>{\n                        updateNode(id, {\n                            \"useReactFlow.useMemo[generalHelper]\": (node)=>{\n                                const nextData = typeof dataUpdate === 'function' ? dataUpdate(node) : dataUpdate;\n                                return options.replace ? {\n                                    ...node,\n                                    data: nextData\n                                } : {\n                                    ...node,\n                                    data: {\n                                        ...node.data,\n                                        ...nextData\n                                    }\n                                };\n                            }\n                        }[\"useReactFlow.useMemo[generalHelper]\"], options);\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                updateEdge,\n                updateEdgeData: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (id, dataUpdate, options = {\n                        replace: false\n                    })=>{\n                        updateEdge(id, {\n                            \"useReactFlow.useMemo[generalHelper]\": (edge)=>{\n                                const nextData = typeof dataUpdate === 'function' ? dataUpdate(edge) : dataUpdate;\n                                return options.replace ? {\n                                    ...edge,\n                                    data: nextData\n                                } : {\n                                    ...edge,\n                                    data: {\n                                        ...edge.data,\n                                        ...nextData\n                                    }\n                                };\n                            }\n                        }[\"useReactFlow.useMemo[generalHelper]\"], options);\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                getNodesBounds: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (nodes)=>{\n                        const { nodeLookup, nodeOrigin } = store.getState();\n                        return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodesBounds)(nodes, {\n                            nodeLookup,\n                            nodeOrigin\n                        });\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                getHandleConnections: ({\n                    \"useReactFlow.useMemo[generalHelper]\": ({ type, id, nodeId })=>Array.from(store.getState().connectionLookup.get(`${nodeId}-${type}${id ? `-${id}` : ''}`)?.values() ?? [])\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                getNodeConnections: ({\n                    \"useReactFlow.useMemo[generalHelper]\": ({ type, handleId, nodeId })=>Array.from(store.getState().connectionLookup.get(`${nodeId}${type ? handleId ? `-${type}-${handleId}` : `-${type}` : ''}`)?.values() ?? [])\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                fitView: ({\n                    \"useReactFlow.useMemo[generalHelper]\": async (options)=>{\n                        // We either create a new Promise or reuse the existing one\n                        // Even if fitView is called multiple times in a row, we only end up with a single Promise\n                        const fitViewResolver = store.getState().fitViewResolver ?? (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.withResolvers)();\n                        // We schedule a fitView by setting fitViewQueued and triggering a setNodes\n                        store.setState({\n                            fitViewQueued: true,\n                            fitViewOptions: options,\n                            fitViewResolver\n                        });\n                        batchContext.nodeQueue.push({\n                            \"useReactFlow.useMemo[generalHelper]\": (nodes)=>[\n                                    ...nodes\n                                ]\n                        }[\"useReactFlow.useMemo[generalHelper]\"]);\n                        return fitViewResolver.promise;\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"]\n            };\n        }\n    }[\"useReactFlow.useMemo[generalHelper]\"], []);\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"useReactFlow.useMemo\": ()=>{\n            return {\n                ...generalHelper,\n                ...viewportHelper,\n                viewportInitialized\n            };\n        }\n    }[\"useReactFlow.useMemo\"], [\n        viewportInitialized\n    ]);\n}\nconst selected = (item)=>item.selected;\nconst win$1 =  false ? 0 : undefined;\n/**\n * Hook for handling global key events.\n *\n * @internal\n */ function useGlobalKeyHandler({ deleteKeyCode, multiSelectionKeyCode }) {\n    const store = useStoreApi();\n    const { deleteElements } = useReactFlow();\n    const deleteKeyPressed = useKeyPress(deleteKeyCode, {\n        actInsideInputWithModifier: false\n    });\n    const multiSelectionKeyPressed = useKeyPress(multiSelectionKeyCode, {\n        target: win$1\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useGlobalKeyHandler.useEffect\": ()=>{\n            if (deleteKeyPressed) {\n                const { edges, nodes } = store.getState();\n                deleteElements({\n                    nodes: nodes.filter(selected),\n                    edges: edges.filter(selected)\n                });\n                store.setState({\n                    nodesSelectionActive: false\n                });\n            }\n        }\n    }[\"useGlobalKeyHandler.useEffect\"], [\n        deleteKeyPressed\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useGlobalKeyHandler.useEffect\": ()=>{\n            store.setState({\n                multiSelectionActive: multiSelectionKeyPressed\n            });\n        }\n    }[\"useGlobalKeyHandler.useEffect\"], [\n        multiSelectionKeyPressed\n    ]);\n}\n/**\n * Hook for handling resize events.\n *\n * @internal\n */ function useResizeHandler(domNode) {\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useResizeHandler.useEffect\": ()=>{\n            const updateDimensions = {\n                \"useResizeHandler.useEffect.updateDimensions\": ()=>{\n                    if (!domNode.current) {\n                        return false;\n                    }\n                    const size = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getDimensions)(domNode.current);\n                    if (size.height === 0 || size.width === 0) {\n                        store.getState().onError?.('004', _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error004']());\n                    }\n                    store.setState({\n                        width: size.width || 500,\n                        height: size.height || 500\n                    });\n                }\n            }[\"useResizeHandler.useEffect.updateDimensions\"];\n            if (domNode.current) {\n                updateDimensions();\n                window.addEventListener('resize', updateDimensions);\n                const resizeObserver = new ResizeObserver({\n                    \"useResizeHandler.useEffect\": ()=>updateDimensions()\n                }[\"useResizeHandler.useEffect\"]);\n                resizeObserver.observe(domNode.current);\n                return ({\n                    \"useResizeHandler.useEffect\": ()=>{\n                        window.removeEventListener('resize', updateDimensions);\n                        if (resizeObserver && domNode.current) {\n                            resizeObserver.unobserve(domNode.current);\n                        }\n                    }\n                })[\"useResizeHandler.useEffect\"];\n            }\n        }\n    }[\"useResizeHandler.useEffect\"], []);\n}\nconst containerStyle = {\n    position: 'absolute',\n    width: '100%',\n    height: '100%',\n    top: 0,\n    left: 0\n};\nconst selector$j = (s)=>({\n        userSelectionActive: s.userSelectionActive,\n        lib: s.lib\n    });\nfunction ZoomPane({ onPaneContextMenu, zoomOnScroll = true, zoomOnPinch = true, panOnScroll = false, panOnScrollSpeed = 0.5, panOnScrollMode = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.PanOnScrollMode.Free, zoomOnDoubleClick = true, panOnDrag = true, defaultViewport, translateExtent, minZoom, maxZoom, zoomActivationKeyCode, preventScrolling = true, children, noWheelClassName, noPanClassName, onViewportChange, isControlledViewport, paneClickDistance }) {\n    const store = useStoreApi();\n    const zoomPane = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const { userSelectionActive, lib } = useStore(selector$j, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const zoomActivationKeyPressed = useKeyPress(zoomActivationKeyCode);\n    const panZoom = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    useResizeHandler(zoomPane);\n    const onTransformChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ZoomPane.useCallback[onTransformChange]\": (transform)=>{\n            onViewportChange?.({\n                x: transform[0],\n                y: transform[1],\n                zoom: transform[2]\n            });\n            if (!isControlledViewport) {\n                store.setState({\n                    transform\n                });\n            }\n        }\n    }[\"ZoomPane.useCallback[onTransformChange]\"], [\n        onViewportChange,\n        isControlledViewport\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ZoomPane.useEffect\": ()=>{\n            if (zoomPane.current) {\n                panZoom.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYPanZoom)({\n                    domNode: zoomPane.current,\n                    minZoom,\n                    maxZoom,\n                    translateExtent,\n                    viewport: defaultViewport,\n                    paneClickDistance,\n                    onDraggingChange: {\n                        \"ZoomPane.useEffect\": (paneDragging)=>store.setState({\n                                paneDragging\n                            })\n                    }[\"ZoomPane.useEffect\"],\n                    onPanZoomStart: {\n                        \"ZoomPane.useEffect\": (event, vp)=>{\n                            const { onViewportChangeStart, onMoveStart } = store.getState();\n                            onMoveStart?.(event, vp);\n                            onViewportChangeStart?.(vp);\n                        }\n                    }[\"ZoomPane.useEffect\"],\n                    onPanZoom: {\n                        \"ZoomPane.useEffect\": (event, vp)=>{\n                            const { onViewportChange, onMove } = store.getState();\n                            onMove?.(event, vp);\n                            onViewportChange?.(vp);\n                        }\n                    }[\"ZoomPane.useEffect\"],\n                    onPanZoomEnd: {\n                        \"ZoomPane.useEffect\": (event, vp)=>{\n                            const { onViewportChangeEnd, onMoveEnd } = store.getState();\n                            onMoveEnd?.(event, vp);\n                            onViewportChangeEnd?.(vp);\n                        }\n                    }[\"ZoomPane.useEffect\"]\n                });\n                const { x, y, zoom } = panZoom.current.getViewport();\n                store.setState({\n                    panZoom: panZoom.current,\n                    transform: [\n                        x,\n                        y,\n                        zoom\n                    ],\n                    domNode: zoomPane.current.closest('.react-flow')\n                });\n                return ({\n                    \"ZoomPane.useEffect\": ()=>{\n                        panZoom.current?.destroy();\n                    }\n                })[\"ZoomPane.useEffect\"];\n            }\n        }\n    }[\"ZoomPane.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ZoomPane.useEffect\": ()=>{\n            panZoom.current?.update({\n                onPaneContextMenu,\n                zoomOnScroll,\n                zoomOnPinch,\n                panOnScroll,\n                panOnScrollSpeed,\n                panOnScrollMode,\n                zoomOnDoubleClick,\n                panOnDrag,\n                zoomActivationKeyPressed,\n                preventScrolling,\n                noPanClassName,\n                userSelectionActive,\n                noWheelClassName,\n                lib,\n                onTransformChange\n            });\n        }\n    }[\"ZoomPane.useEffect\"], [\n        onPaneContextMenu,\n        zoomOnScroll,\n        zoomOnPinch,\n        panOnScroll,\n        panOnScrollSpeed,\n        panOnScrollMode,\n        zoomOnDoubleClick,\n        panOnDrag,\n        zoomActivationKeyPressed,\n        preventScrolling,\n        noPanClassName,\n        userSelectionActive,\n        noWheelClassName,\n        lib,\n        onTransformChange\n    ]);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"react-flow__renderer\",\n        ref: zoomPane,\n        style: containerStyle,\n        children: children\n    });\n}\nconst selector$i = (s)=>({\n        userSelectionActive: s.userSelectionActive,\n        userSelectionRect: s.userSelectionRect\n    });\nfunction UserSelection() {\n    const { userSelectionActive, userSelectionRect } = useStore(selector$i, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const isActive = userSelectionActive && userSelectionRect;\n    if (!isActive) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"react-flow__selection react-flow__container\",\n        style: {\n            width: userSelectionRect.width,\n            height: userSelectionRect.height,\n            transform: `translate(${userSelectionRect.x}px, ${userSelectionRect.y}px)`\n        }\n    });\n}\nconst wrapHandler = (handler, containerRef)=>{\n    return (event)=>{\n        if (event.target !== containerRef.current) {\n            return;\n        }\n        handler?.(event);\n    };\n};\nconst selector$h = (s)=>({\n        userSelectionActive: s.userSelectionActive,\n        elementsSelectable: s.elementsSelectable,\n        connectionInProgress: s.connection.inProgress,\n        dragging: s.paneDragging\n    });\nfunction Pane({ isSelecting, selectionKeyPressed, selectionMode = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.SelectionMode.Full, panOnDrag, selectionOnDrag, onSelectionStart, onSelectionEnd, onPaneClick, onPaneContextMenu, onPaneScroll, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, children }) {\n    const store = useStoreApi();\n    const { userSelectionActive, elementsSelectable, dragging, connectionInProgress } = useStore(selector$h, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const hasActiveSelection = elementsSelectable && (isSelecting || userSelectionActive);\n    const container = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const containerBounds = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    const selectedNodeIds = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Set());\n    const selectedEdgeIds = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Set());\n    // Used to prevent click events when the user lets go of the selectionKey during a selection\n    const selectionInProgress = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const selectionStarted = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const onClick = (event)=>{\n        // We prevent click events when the user let go of the selectionKey during a selection\n        // We also prevent click events when a connection is in progress\n        if (selectionInProgress.current || connectionInProgress) {\n            selectionInProgress.current = false;\n            return;\n        }\n        onPaneClick?.(event);\n        store.getState().resetSelectedElements();\n        store.setState({\n            nodesSelectionActive: false\n        });\n    };\n    const onContextMenu = (event)=>{\n        if (Array.isArray(panOnDrag) && panOnDrag?.includes(2)) {\n            event.preventDefault();\n            return;\n        }\n        onPaneContextMenu?.(event);\n    };\n    const onWheel = onPaneScroll ? (event)=>onPaneScroll(event) : undefined;\n    const onPointerDown = (event)=>{\n        const { resetSelectedElements, domNode } = store.getState();\n        containerBounds.current = domNode?.getBoundingClientRect();\n        if (!elementsSelectable || !isSelecting || event.button !== 0 || event.target !== container.current || !containerBounds.current) {\n            return;\n        }\n        event.target?.setPointerCapture?.(event.pointerId);\n        selectionStarted.current = true;\n        selectionInProgress.current = false;\n        const { x, y } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getEventPosition)(event.nativeEvent, containerBounds.current);\n        resetSelectedElements();\n        store.setState({\n            userSelectionRect: {\n                width: 0,\n                height: 0,\n                startX: x,\n                startY: y,\n                x,\n                y\n            }\n        });\n        onSelectionStart?.(event);\n    };\n    const onPointerMove = (event)=>{\n        const { userSelectionRect, transform, nodeLookup, edgeLookup, connectionLookup, triggerNodeChanges, triggerEdgeChanges, defaultEdgeOptions } = store.getState();\n        if (!containerBounds.current || !userSelectionRect) {\n            return;\n        }\n        selectionInProgress.current = true;\n        const { x: mouseX, y: mouseY } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getEventPosition)(event.nativeEvent, containerBounds.current);\n        const { startX, startY } = userSelectionRect;\n        const nextUserSelectRect = {\n            startX,\n            startY,\n            x: mouseX < startX ? mouseX : startX,\n            y: mouseY < startY ? mouseY : startY,\n            width: Math.abs(mouseX - startX),\n            height: Math.abs(mouseY - startY)\n        };\n        const prevSelectedNodeIds = selectedNodeIds.current;\n        const prevSelectedEdgeIds = selectedEdgeIds.current;\n        selectedNodeIds.current = new Set((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodesInside)(nodeLookup, nextUserSelectRect, transform, selectionMode === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.SelectionMode.Partial, true).map((node)=>node.id));\n        selectedEdgeIds.current = new Set();\n        const edgesSelectable = defaultEdgeOptions?.selectable ?? true;\n        // We look for all edges connected to the selected nodes\n        for (const nodeId of selectedNodeIds.current){\n            const connections = connectionLookup.get(nodeId);\n            if (!connections) continue;\n            for (const { edgeId } of connections.values()){\n                const edge = edgeLookup.get(edgeId);\n                if (edge && (edge.selectable ?? edgesSelectable)) {\n                    selectedEdgeIds.current.add(edgeId);\n                }\n            }\n        }\n        if (!(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.areSetsEqual)(prevSelectedNodeIds, selectedNodeIds.current)) {\n            const changes = getSelectionChanges(nodeLookup, selectedNodeIds.current, true);\n            triggerNodeChanges(changes);\n        }\n        if (!(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.areSetsEqual)(prevSelectedEdgeIds, selectedEdgeIds.current)) {\n            const changes = getSelectionChanges(edgeLookup, selectedEdgeIds.current);\n            triggerEdgeChanges(changes);\n        }\n        store.setState({\n            userSelectionRect: nextUserSelectRect,\n            userSelectionActive: true,\n            nodesSelectionActive: false\n        });\n    };\n    const onPointerUp = (event)=>{\n        if (event.button !== 0 || !selectionStarted.current) {\n            return;\n        }\n        event.target?.releasePointerCapture?.(event.pointerId);\n        const { userSelectionRect } = store.getState();\n        /*\n         * We only want to trigger click functions when in selection mode if\n         * the user did not move the mouse.\n         */ if (!userSelectionActive && userSelectionRect && event.target === container.current) {\n            onClick?.(event);\n        }\n        store.setState({\n            userSelectionActive: false,\n            userSelectionRect: null,\n            nodesSelectionActive: selectedNodeIds.current.size > 0\n        });\n        onSelectionEnd?.(event);\n        /*\n         * If the user kept holding the selectionKey during the selection,\n         * we need to reset the selectionInProgress, so the next click event is not prevented\n         */ if (selectionKeyPressed || selectionOnDrag) {\n            selectionInProgress.current = false;\n        }\n        selectionStarted.current = false;\n    };\n    const draggable = panOnDrag === true || Array.isArray(panOnDrag) && panOnDrag.includes(0);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__pane',\n            {\n                draggable,\n                dragging,\n                selection: isSelecting\n            }\n        ]),\n        onClick: hasActiveSelection ? undefined : wrapHandler(onClick, container),\n        onContextMenu: wrapHandler(onContextMenu, container),\n        onWheel: wrapHandler(onWheel, container),\n        onPointerEnter: hasActiveSelection ? undefined : onPaneMouseEnter,\n        onPointerDown: hasActiveSelection ? onPointerDown : onPaneMouseMove,\n        onPointerMove: hasActiveSelection ? onPointerMove : onPaneMouseMove,\n        onPointerUp: hasActiveSelection ? onPointerUp : undefined,\n        onPointerLeave: onPaneMouseLeave,\n        ref: container,\n        style: containerStyle,\n        children: [\n            children,\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(UserSelection, {})\n        ]\n    });\n}\n/*\n * this handler is called by\n * 1. the click handler when node is not draggable or selectNodesOnDrag = false\n * or\n * 2. the on drag start handler when node is draggable and selectNodesOnDrag = true\n */ function handleNodeClick({ id, store, unselect = false, nodeRef }) {\n    const { addSelectedNodes, unselectNodesAndEdges, multiSelectionActive, nodeLookup, onError } = store.getState();\n    const node = nodeLookup.get(id);\n    if (!node) {\n        onError?.('012', _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error012'](id));\n        return;\n    }\n    store.setState({\n        nodesSelectionActive: false\n    });\n    if (!node.selected) {\n        addSelectedNodes([\n            id\n        ]);\n    } else if (unselect || node.selected && multiSelectionActive) {\n        unselectNodesAndEdges({\n            nodes: [\n                node\n            ],\n            edges: []\n        });\n        requestAnimationFrame(()=>nodeRef?.current?.blur());\n    }\n}\n/**\n * Hook for calling XYDrag helper from @xyflow/system.\n *\n * @internal\n */ function useDrag({ nodeRef, disabled = false, noDragClassName, handleSelector, nodeId, isSelectable, nodeClickDistance }) {\n    const store = useStoreApi();\n    const [dragging, setDragging] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const xyDrag = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useDrag.useEffect\": ()=>{\n            xyDrag.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYDrag)({\n                getStoreItems: {\n                    \"useDrag.useEffect\": ()=>store.getState()\n                }[\"useDrag.useEffect\"],\n                onNodeMouseDown: {\n                    \"useDrag.useEffect\": (id)=>{\n                        handleNodeClick({\n                            id,\n                            store,\n                            nodeRef\n                        });\n                    }\n                }[\"useDrag.useEffect\"],\n                onDragStart: {\n                    \"useDrag.useEffect\": ()=>{\n                        setDragging(true);\n                    }\n                }[\"useDrag.useEffect\"],\n                onDragStop: {\n                    \"useDrag.useEffect\": ()=>{\n                        setDragging(false);\n                    }\n                }[\"useDrag.useEffect\"]\n            });\n        }\n    }[\"useDrag.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useDrag.useEffect\": ()=>{\n            if (disabled) {\n                xyDrag.current?.destroy();\n            } else if (nodeRef.current) {\n                xyDrag.current?.update({\n                    noDragClassName,\n                    handleSelector,\n                    domNode: nodeRef.current,\n                    isSelectable,\n                    nodeId,\n                    nodeClickDistance\n                });\n                return ({\n                    \"useDrag.useEffect\": ()=>{\n                        xyDrag.current?.destroy();\n                    }\n                })[\"useDrag.useEffect\"];\n            }\n        }\n    }[\"useDrag.useEffect\"], [\n        noDragClassName,\n        handleSelector,\n        disabled,\n        isSelectable,\n        nodeRef,\n        nodeId\n    ]);\n    return dragging;\n}\nconst selectedAndDraggable = (nodesDraggable)=>(n)=>n.selected && (n.draggable || nodesDraggable && typeof n.draggable === 'undefined');\n/**\n * Hook for updating node positions by passing a direction and factor\n *\n * @internal\n * @returns function for updating node positions\n */ function useMoveSelectedNodes() {\n    const store = useStoreApi();\n    const moveSelectedNodes = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"useMoveSelectedNodes.useCallback[moveSelectedNodes]\": (params)=>{\n            const { nodeExtent, snapToGrid, snapGrid, nodesDraggable, onError, updateNodePositions, nodeLookup, nodeOrigin } = store.getState();\n            const nodeUpdates = new Map();\n            const isSelected = selectedAndDraggable(nodesDraggable);\n            /*\n         * by default a node moves 5px on each key press\n         * if snap grid is enabled, we use that for the velocity\n         */ const xVelo = snapToGrid ? snapGrid[0] : 5;\n            const yVelo = snapToGrid ? snapGrid[1] : 5;\n            const xDiff = params.direction.x * xVelo * params.factor;\n            const yDiff = params.direction.y * yVelo * params.factor;\n            for (const [, node] of nodeLookup){\n                if (!isSelected(node)) {\n                    continue;\n                }\n                let nextPosition = {\n                    x: node.internals.positionAbsolute.x + xDiff,\n                    y: node.internals.positionAbsolute.y + yDiff\n                };\n                if (snapToGrid) {\n                    nextPosition = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.snapPosition)(nextPosition, snapGrid);\n                }\n                const { position, positionAbsolute } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.calculateNodePosition)({\n                    nodeId: node.id,\n                    nextPosition,\n                    nodeLookup,\n                    nodeExtent,\n                    nodeOrigin,\n                    onError\n                });\n                node.position = position;\n                node.internals.positionAbsolute = positionAbsolute;\n                nodeUpdates.set(node.id, node);\n            }\n            updateNodePositions(nodeUpdates);\n        }\n    }[\"useMoveSelectedNodes.useCallback[moveSelectedNodes]\"], []);\n    return moveSelectedNodes;\n}\nconst NodeIdContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nconst Provider = NodeIdContext.Provider;\nNodeIdContext.Consumer;\n/**\n * You can use this hook to get the id of the node it is used inside. It is useful\n * if you need the node's id deeper in the render tree but don't want to manually\n * drill down the id as a prop.\n *\n * @public\n * @returns The id for a node in the flow.\n *\n * @example\n *```jsx\n *import { useNodeId } from '@xyflow/react';\n *\n *export default function CustomNode() {\n *  return (\n *    <div>\n *      <span>This node has an id of </span>\n *      <NodeIdDisplay />\n *    </div>\n *  );\n *}\n *\n *function NodeIdDisplay() {\n *  const nodeId = useNodeId();\n *\n *  return <span>{nodeId}</span>;\n *}\n *```\n */ const useNodeId = ()=>{\n    const nodeId = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(NodeIdContext);\n    return nodeId;\n};\nconst selector$g = (s)=>({\n        connectOnClick: s.connectOnClick,\n        noPanClassName: s.noPanClassName,\n        rfId: s.rfId\n    });\nconst connectingSelector = (nodeId, handleId, type)=>(state)=>{\n        const { connectionClickStartHandle: clickHandle, connectionMode, connection } = state;\n        const { fromHandle, toHandle, isValid } = connection;\n        const connectingTo = toHandle?.nodeId === nodeId && toHandle?.id === handleId && toHandle?.type === type;\n        return {\n            connectingFrom: fromHandle?.nodeId === nodeId && fromHandle?.id === handleId && fromHandle?.type === type,\n            connectingTo,\n            clickConnecting: clickHandle?.nodeId === nodeId && clickHandle?.id === handleId && clickHandle?.type === type,\n            isPossibleEndHandle: connectionMode === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionMode.Strict ? fromHandle?.type !== type : nodeId !== fromHandle?.nodeId || handleId !== fromHandle?.id,\n            connectionInProcess: !!fromHandle,\n            clickConnectionInProcess: !!clickHandle,\n            valid: connectingTo && isValid\n        };\n    };\nfunction HandleComponent({ type = 'source', position = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top, isValidConnection, isConnectable = true, isConnectableStart = true, isConnectableEnd = true, id, onConnect, children, className, onMouseDown, onTouchStart, ...rest }, ref) {\n    const handleId = id || null;\n    const isTarget = type === 'target';\n    const store = useStoreApi();\n    const nodeId = useNodeId();\n    const { connectOnClick, noPanClassName, rfId } = useStore(selector$g, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const { connectingFrom, connectingTo, clickConnecting, isPossibleEndHandle, connectionInProcess, clickConnectionInProcess, valid } = useStore(connectingSelector(nodeId, handleId, type), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    if (!nodeId) {\n        store.getState().onError?.('010', _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error010']());\n    }\n    const onConnectExtended = (params)=>{\n        const { defaultEdgeOptions, onConnect: onConnectAction, hasDefaultEdges } = store.getState();\n        const edgeParams = {\n            ...defaultEdgeOptions,\n            ...params\n        };\n        if (hasDefaultEdges) {\n            const { edges, setEdges } = store.getState();\n            setEdges((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.addEdge)(edgeParams, edges));\n        }\n        onConnectAction?.(edgeParams);\n        onConnect?.(edgeParams);\n    };\n    const onPointerDown = (event)=>{\n        if (!nodeId) {\n            return;\n        }\n        const isMouseTriggered = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isMouseEvent)(event.nativeEvent);\n        if (isConnectableStart && (isMouseTriggered && event.button === 0 || !isMouseTriggered)) {\n            const currentStore = store.getState();\n            _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYHandle.onPointerDown(event.nativeEvent, {\n                autoPanOnConnect: currentStore.autoPanOnConnect,\n                connectionMode: currentStore.connectionMode,\n                connectionRadius: currentStore.connectionRadius,\n                domNode: currentStore.domNode,\n                nodeLookup: currentStore.nodeLookup,\n                lib: currentStore.lib,\n                isTarget,\n                handleId,\n                nodeId,\n                flowId: currentStore.rfId,\n                panBy: currentStore.panBy,\n                cancelConnection: currentStore.cancelConnection,\n                onConnectStart: currentStore.onConnectStart,\n                onConnectEnd: currentStore.onConnectEnd,\n                updateConnection: currentStore.updateConnection,\n                onConnect: onConnectExtended,\n                isValidConnection: isValidConnection || currentStore.isValidConnection,\n                getTransform: ()=>store.getState().transform,\n                getFromHandle: ()=>store.getState().connection.fromHandle,\n                autoPanSpeed: currentStore.autoPanSpeed\n            });\n        }\n        if (isMouseTriggered) {\n            onMouseDown?.(event);\n        } else {\n            onTouchStart?.(event);\n        }\n    };\n    const onClick = (event)=>{\n        const { onClickConnectStart, onClickConnectEnd, connectionClickStartHandle, connectionMode, isValidConnection: isValidConnectionStore, lib, rfId: flowId, nodeLookup, connection: connectionState } = store.getState();\n        if (!nodeId || !connectionClickStartHandle && !isConnectableStart) {\n            return;\n        }\n        if (!connectionClickStartHandle) {\n            onClickConnectStart?.(event.nativeEvent, {\n                nodeId,\n                handleId,\n                handleType: type\n            });\n            store.setState({\n                connectionClickStartHandle: {\n                    nodeId,\n                    type,\n                    id: handleId\n                }\n            });\n            return;\n        }\n        const doc = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getHostForElement)(event.target);\n        const isValidConnectionHandler = isValidConnection || isValidConnectionStore;\n        const { connection, isValid } = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYHandle.isValid(event.nativeEvent, {\n            handle: {\n                nodeId,\n                id: handleId,\n                type\n            },\n            connectionMode,\n            fromNodeId: connectionClickStartHandle.nodeId,\n            fromHandleId: connectionClickStartHandle.id || null,\n            fromType: connectionClickStartHandle.type,\n            isValidConnection: isValidConnectionHandler,\n            flowId,\n            doc,\n            lib,\n            nodeLookup\n        });\n        if (isValid && connection) {\n            onConnectExtended(connection);\n        }\n        const connectionClone = structuredClone(connectionState);\n        delete connectionClone.inProgress;\n        connectionClone.toPosition = connectionClone.toHandle ? connectionClone.toHandle.position : null;\n        onClickConnectEnd?.(event, connectionClone);\n        store.setState({\n            connectionClickStartHandle: null\n        });\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        \"data-handleid\": handleId,\n        \"data-nodeid\": nodeId,\n        \"data-handlepos\": position,\n        \"data-id\": `${rfId}-${nodeId}-${handleId}-${type}`,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__handle',\n            `react-flow__handle-${position}`,\n            'nodrag',\n            noPanClassName,\n            className,\n            {\n                source: !isTarget,\n                target: isTarget,\n                connectable: isConnectable,\n                connectablestart: isConnectableStart,\n                connectableend: isConnectableEnd,\n                clickconnecting: clickConnecting,\n                connectingfrom: connectingFrom,\n                connectingto: connectingTo,\n                valid,\n                /*\n                 * shows where you can start a connection from\n                 * and where you can end it while connecting\n                 */ connectionindicator: isConnectable && (!connectionInProcess || isPossibleEndHandle) && (connectionInProcess || clickConnectionInProcess ? isConnectableEnd : isConnectableStart)\n            }\n        ]),\n        onMouseDown: onPointerDown,\n        onTouchStart: onPointerDown,\n        onClick: connectOnClick ? onClick : undefined,\n        ref: ref,\n        ...rest,\n        children: children\n    });\n}\n/**\n * The `<Handle />` component is used in your [custom nodes](/learn/customization/custom-nodes)\n * to define connection points.\n *\n *@public\n *\n *@example\n *\n *```jsx\n *import { Handle, Position } from '@xyflow/react';\n *\n *export function CustomNode({ data }) {\n *  return (\n *    <>\n *      <div style={{ padding: '10px 20px' }}>\n *        {data.label}\n *      </div>\n *\n *      <Handle type=\"target\" position={Position.Left} />\n *      <Handle type=\"source\" position={Position.Right} />\n *    </>\n *  );\n *};\n *```\n */ const Handle = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(fixedForwardRef(HandleComponent));\nfunction InputNode({ data, isConnectable, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            data?.label,\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {\n                type: \"source\",\n                position: sourcePosition,\n                isConnectable: isConnectable\n            })\n        ]\n    });\n}\nfunction DefaultNode({ data, isConnectable, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {\n                type: \"target\",\n                position: targetPosition,\n                isConnectable: isConnectable\n            }),\n            data?.label,\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {\n                type: \"source\",\n                position: sourcePosition,\n                isConnectable: isConnectable\n            })\n        ]\n    });\n}\nfunction GroupNode() {\n    return null;\n}\nfunction OutputNode({ data, isConnectable, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {\n                type: \"target\",\n                position: targetPosition,\n                isConnectable: isConnectable\n            }),\n            data?.label\n        ]\n    });\n}\nconst arrowKeyDiffs = {\n    ArrowUp: {\n        x: 0,\n        y: -1\n    },\n    ArrowDown: {\n        x: 0,\n        y: 1\n    },\n    ArrowLeft: {\n        x: -1,\n        y: 0\n    },\n    ArrowRight: {\n        x: 1,\n        y: 0\n    }\n};\nconst builtinNodeTypes = {\n    input: InputNode,\n    default: DefaultNode,\n    output: OutputNode,\n    group: GroupNode\n};\nfunction getNodeInlineStyleDimensions(node) {\n    if (node.internals.handleBounds === undefined) {\n        return {\n            width: node.width ?? node.initialWidth ?? node.style?.width,\n            height: node.height ?? node.initialHeight ?? node.style?.height\n        };\n    }\n    return {\n        width: node.width ?? node.style?.width,\n        height: node.height ?? node.style?.height\n    };\n}\nconst selector$f = (s)=>{\n    const { width, height, x, y } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getInternalNodesBounds)(s.nodeLookup, {\n        filter: (node)=>!!node.selected\n    });\n    return {\n        width: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isNumeric)(width) ? width : null,\n        height: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isNumeric)(height) ? height : null,\n        userSelectionActive: s.userSelectionActive,\n        transformString: `translate(${s.transform[0]}px,${s.transform[1]}px) scale(${s.transform[2]}) translate(${x}px,${y}px)`\n    };\n};\nfunction NodesSelection({ onSelectionContextMenu, noPanClassName, disableKeyboardA11y }) {\n    const store = useStoreApi();\n    const { width, height, transformString, userSelectionActive } = useStore(selector$f, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const moveSelectedNodes = useMoveSelectedNodes();\n    const nodeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"NodesSelection.useEffect\": ()=>{\n            if (!disableKeyboardA11y) {\n                nodeRef.current?.focus({\n                    preventScroll: true\n                });\n            }\n        }\n    }[\"NodesSelection.useEffect\"], [\n        disableKeyboardA11y\n    ]);\n    useDrag({\n        nodeRef\n    });\n    if (userSelectionActive || !width || !height) {\n        return null;\n    }\n    const onContextMenu = onSelectionContextMenu ? (event)=>{\n        const selectedNodes = store.getState().nodes.filter((n)=>n.selected);\n        onSelectionContextMenu(event, selectedNodes);\n    } : undefined;\n    const onKeyDown = (event)=>{\n        if (Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event.key)) {\n            event.preventDefault();\n            moveSelectedNodes({\n                direction: arrowKeyDiffs[event.key],\n                factor: event.shiftKey ? 4 : 1\n            });\n        }\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__nodesselection',\n            'react-flow__container',\n            noPanClassName\n        ]),\n        style: {\n            transform: transformString\n        },\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n            ref: nodeRef,\n            className: \"react-flow__nodesselection-rect\",\n            onContextMenu: onContextMenu,\n            tabIndex: disableKeyboardA11y ? undefined : -1,\n            onKeyDown: disableKeyboardA11y ? undefined : onKeyDown,\n            style: {\n                width,\n                height\n            }\n        })\n    });\n}\nconst win =  false ? 0 : undefined;\nconst selector$e = (s)=>{\n    return {\n        nodesSelectionActive: s.nodesSelectionActive,\n        userSelectionActive: s.userSelectionActive\n    };\n};\nfunction FlowRendererComponent({ children, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneContextMenu, onPaneScroll, paneClickDistance, deleteKeyCode, selectionKeyCode, selectionOnDrag, selectionMode, onSelectionStart, onSelectionEnd, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, elementsSelectable, zoomOnScroll, zoomOnPinch, panOnScroll: _panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag: _panOnDrag, defaultViewport, translateExtent, minZoom, maxZoom, preventScrolling, onSelectionContextMenu, noWheelClassName, noPanClassName, disableKeyboardA11y, onViewportChange, isControlledViewport }) {\n    const { nodesSelectionActive, userSelectionActive } = useStore(selector$e);\n    const selectionKeyPressed = useKeyPress(selectionKeyCode, {\n        target: win\n    });\n    const panActivationKeyPressed = useKeyPress(panActivationKeyCode, {\n        target: win\n    });\n    const panOnDrag = panActivationKeyPressed || _panOnDrag;\n    const panOnScroll = panActivationKeyPressed || _panOnScroll;\n    const _selectionOnDrag = selectionOnDrag && panOnDrag !== true;\n    const isSelecting = selectionKeyPressed || userSelectionActive || _selectionOnDrag;\n    useGlobalKeyHandler({\n        deleteKeyCode,\n        multiSelectionKeyCode\n    });\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ZoomPane, {\n        onPaneContextMenu: onPaneContextMenu,\n        elementsSelectable: elementsSelectable,\n        zoomOnScroll: zoomOnScroll,\n        zoomOnPinch: zoomOnPinch,\n        panOnScroll: panOnScroll,\n        panOnScrollSpeed: panOnScrollSpeed,\n        panOnScrollMode: panOnScrollMode,\n        zoomOnDoubleClick: zoomOnDoubleClick,\n        panOnDrag: !selectionKeyPressed && panOnDrag,\n        defaultViewport: defaultViewport,\n        translateExtent: translateExtent,\n        minZoom: minZoom,\n        maxZoom: maxZoom,\n        zoomActivationKeyCode: zoomActivationKeyCode,\n        preventScrolling: preventScrolling,\n        noWheelClassName: noWheelClassName,\n        noPanClassName: noPanClassName,\n        onViewportChange: onViewportChange,\n        isControlledViewport: isControlledViewport,\n        paneClickDistance: paneClickDistance,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Pane, {\n            onSelectionStart: onSelectionStart,\n            onSelectionEnd: onSelectionEnd,\n            onPaneClick: onPaneClick,\n            onPaneMouseEnter: onPaneMouseEnter,\n            onPaneMouseMove: onPaneMouseMove,\n            onPaneMouseLeave: onPaneMouseLeave,\n            onPaneContextMenu: onPaneContextMenu,\n            onPaneScroll: onPaneScroll,\n            panOnDrag: panOnDrag,\n            isSelecting: !!isSelecting,\n            selectionMode: selectionMode,\n            selectionKeyPressed: selectionKeyPressed,\n            selectionOnDrag: _selectionOnDrag,\n            children: [\n                children,\n                nodesSelectionActive && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodesSelection, {\n                    onSelectionContextMenu: onSelectionContextMenu,\n                    noPanClassName: noPanClassName,\n                    disableKeyboardA11y: disableKeyboardA11y\n                })\n            ]\n        })\n    });\n}\nFlowRendererComponent.displayName = 'FlowRenderer';\nconst FlowRenderer = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(FlowRendererComponent);\nconst selector$d = (onlyRenderVisible)=>(s)=>{\n        return onlyRenderVisible ? (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodesInside)(s.nodeLookup, {\n            x: 0,\n            y: 0,\n            width: s.width,\n            height: s.height\n        }, s.transform, true).map((node)=>node.id) : Array.from(s.nodeLookup.keys());\n    };\n/**\n * Hook for getting the visible node ids from the store.\n *\n * @internal\n * @param onlyRenderVisible\n * @returns array with visible node ids\n */ function useVisibleNodeIds(onlyRenderVisible) {\n    const nodeIds = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(selector$d(onlyRenderVisible), [\n        onlyRenderVisible\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return nodeIds;\n}\nconst selector$c = (s)=>s.updateNodeInternals;\nfunction useResizeObserver() {\n    const updateNodeInternals = useStore(selector$c);\n    const [resizeObserver] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        \"useResizeObserver.useState\": ()=>{\n            if (typeof ResizeObserver === 'undefined') {\n                return null;\n            }\n            return new ResizeObserver({\n                \"useResizeObserver.useState\": (entries)=>{\n                    const updates = new Map();\n                    entries.forEach({\n                        \"useResizeObserver.useState\": (entry)=>{\n                            const id = entry.target.getAttribute('data-id');\n                            updates.set(id, {\n                                id,\n                                nodeElement: entry.target,\n                                force: true\n                            });\n                        }\n                    }[\"useResizeObserver.useState\"]);\n                    updateNodeInternals(updates);\n                }\n            }[\"useResizeObserver.useState\"]);\n        }\n    }[\"useResizeObserver.useState\"]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useResizeObserver.useEffect\": ()=>{\n            return ({\n                \"useResizeObserver.useEffect\": ()=>{\n                    resizeObserver?.disconnect();\n                }\n            })[\"useResizeObserver.useEffect\"];\n        }\n    }[\"useResizeObserver.useEffect\"], [\n        resizeObserver\n    ]);\n    return resizeObserver;\n}\n/**\n * Hook to handle the resize observation + internal updates for the passed node.\n *\n * @internal\n * @returns nodeRef - reference to the node element\n */ function useNodeObserver({ node, nodeType, hasDimensions, resizeObserver }) {\n    const store = useStoreApi();\n    const nodeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const observedNode = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const prevSourcePosition = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(node.sourcePosition);\n    const prevTargetPosition = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(node.targetPosition);\n    const prevType = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(nodeType);\n    const isInitialized = hasDimensions && !!node.internals.handleBounds;\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useNodeObserver.useEffect\": ()=>{\n            if (nodeRef.current && !node.hidden && (!isInitialized || observedNode.current !== nodeRef.current)) {\n                if (observedNode.current) {\n                    resizeObserver?.unobserve(observedNode.current);\n                }\n                resizeObserver?.observe(nodeRef.current);\n                observedNode.current = nodeRef.current;\n            }\n        }\n    }[\"useNodeObserver.useEffect\"], [\n        isInitialized,\n        node.hidden\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useNodeObserver.useEffect\": ()=>{\n            return ({\n                \"useNodeObserver.useEffect\": ()=>{\n                    if (observedNode.current) {\n                        resizeObserver?.unobserve(observedNode.current);\n                        observedNode.current = null;\n                    }\n                }\n            })[\"useNodeObserver.useEffect\"];\n        }\n    }[\"useNodeObserver.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useNodeObserver.useEffect\": ()=>{\n            if (nodeRef.current) {\n                /*\n             * when the user programmatically changes the source or handle position, we need to update the internals\n             * to make sure the edges are updated correctly\n             */ const typeChanged = prevType.current !== nodeType;\n                const sourcePosChanged = prevSourcePosition.current !== node.sourcePosition;\n                const targetPosChanged = prevTargetPosition.current !== node.targetPosition;\n                if (typeChanged || sourcePosChanged || targetPosChanged) {\n                    prevType.current = nodeType;\n                    prevSourcePosition.current = node.sourcePosition;\n                    prevTargetPosition.current = node.targetPosition;\n                    store.getState().updateNodeInternals(new Map([\n                        [\n                            node.id,\n                            {\n                                id: node.id,\n                                nodeElement: nodeRef.current,\n                                force: true\n                            }\n                        ]\n                    ]));\n                }\n            }\n        }\n    }[\"useNodeObserver.useEffect\"], [\n        node.id,\n        nodeType,\n        node.sourcePosition,\n        node.targetPosition\n    ]);\n    return nodeRef;\n}\nfunction NodeWrapper({ id, onClick, onMouseEnter, onMouseMove, onMouseLeave, onContextMenu, onDoubleClick, nodesDraggable, elementsSelectable, nodesConnectable, nodesFocusable, resizeObserver, noDragClassName, noPanClassName, disableKeyboardA11y, rfId, nodeTypes, nodeClickDistance, onError }) {\n    const { node, internals, isParent } = useStore({\n        \"NodeWrapper.useStore\": (s)=>{\n            const node = s.nodeLookup.get(id);\n            const isParent = s.parentLookup.has(id);\n            return {\n                node,\n                internals: node.internals,\n                isParent\n            };\n        }\n    }[\"NodeWrapper.useStore\"], zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    let nodeType = node.type || 'default';\n    let NodeComponent = nodeTypes?.[nodeType] || builtinNodeTypes[nodeType];\n    if (NodeComponent === undefined) {\n        onError?.('003', _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error003'](nodeType));\n        nodeType = 'default';\n        NodeComponent = builtinNodeTypes.default;\n    }\n    const isDraggable = !!(node.draggable || nodesDraggable && typeof node.draggable === 'undefined');\n    const isSelectable = !!(node.selectable || elementsSelectable && typeof node.selectable === 'undefined');\n    const isConnectable = !!(node.connectable || nodesConnectable && typeof node.connectable === 'undefined');\n    const isFocusable = !!(node.focusable || nodesFocusable && typeof node.focusable === 'undefined');\n    const store = useStoreApi();\n    const hasDimensions = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.nodeHasDimensions)(node);\n    const nodeRef = useNodeObserver({\n        node,\n        nodeType,\n        hasDimensions,\n        resizeObserver\n    });\n    const dragging = useDrag({\n        nodeRef,\n        disabled: node.hidden || !isDraggable,\n        noDragClassName,\n        handleSelector: node.dragHandle,\n        nodeId: id,\n        isSelectable,\n        nodeClickDistance\n    });\n    const moveSelectedNodes = useMoveSelectedNodes();\n    if (node.hidden) {\n        return null;\n    }\n    const nodeDimensions = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodeDimensions)(node);\n    const inlineDimensions = getNodeInlineStyleDimensions(node);\n    const hasPointerEvents = isSelectable || isDraggable || onClick || onMouseEnter || onMouseMove || onMouseLeave;\n    const onMouseEnterHandler = onMouseEnter ? (event)=>onMouseEnter(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onMouseMoveHandler = onMouseMove ? (event)=>onMouseMove(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onMouseLeaveHandler = onMouseLeave ? (event)=>onMouseLeave(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onContextMenuHandler = onContextMenu ? (event)=>onContextMenu(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onDoubleClickHandler = onDoubleClick ? (event)=>onDoubleClick(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onSelectNodeHandler = (event)=>{\n        const { selectNodesOnDrag, nodeDragThreshold } = store.getState();\n        if (isSelectable && (!selectNodesOnDrag || !isDraggable || nodeDragThreshold > 0)) {\n            /*\n             * this handler gets called by XYDrag on drag start when selectNodesOnDrag=true\n             * here we only need to call it when selectNodesOnDrag=false\n             */ handleNodeClick({\n                id,\n                store,\n                nodeRef\n            });\n        }\n        if (onClick) {\n            onClick(event, {\n                ...internals.userNode\n            });\n        }\n    };\n    const onKeyDown = (event)=>{\n        if ((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isInputDOMNode)(event.nativeEvent) || disableKeyboardA11y) {\n            return;\n        }\n        if (_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.elementSelectionKeys.includes(event.key) && isSelectable) {\n            const unselect = event.key === 'Escape';\n            handleNodeClick({\n                id,\n                store,\n                unselect,\n                nodeRef\n            });\n        } else if (isDraggable && node.selected && Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event.key)) {\n            // prevent default scrolling behavior on arrow key press when node is moved\n            event.preventDefault();\n            const { ariaLabelConfig } = store.getState();\n            store.setState({\n                ariaLiveMessage: ariaLabelConfig['node.a11yDescription.ariaLiveMessage']({\n                    direction: event.key.replace('Arrow', '').toLowerCase(),\n                    x: ~~internals.positionAbsolute.x,\n                    y: ~~internals.positionAbsolute.y\n                })\n            });\n            moveSelectedNodes({\n                direction: arrowKeyDiffs[event.key],\n                factor: event.shiftKey ? 4 : 1\n            });\n        }\n    };\n    const onFocus = ()=>{\n        if (disableKeyboardA11y || !nodeRef.current?.matches(':focus-visible')) {\n            return;\n        }\n        const { transform, width, height, autoPanOnNodeFocus, setCenter } = store.getState();\n        if (!autoPanOnNodeFocus) {\n            return;\n        }\n        const withinViewport = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodesInside)(new Map([\n            [\n                id,\n                node\n            ]\n        ]), {\n            x: 0,\n            y: 0,\n            width,\n            height\n        }, transform, true).length > 0;\n        if (!withinViewport) {\n            setCenter(node.position.x + nodeDimensions.width / 2, node.position.y + nodeDimensions.height / 2, {\n                zoom: transform[2]\n            });\n        }\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__node',\n            `react-flow__node-${nodeType}`,\n            {\n                // this is overwritable by passing `nopan` as a class name\n                [noPanClassName]: isDraggable\n            },\n            node.className,\n            {\n                selected: node.selected,\n                selectable: isSelectable,\n                parent: isParent,\n                draggable: isDraggable,\n                dragging\n            }\n        ]),\n        ref: nodeRef,\n        style: {\n            zIndex: internals.z,\n            transform: `translate(${internals.positionAbsolute.x}px,${internals.positionAbsolute.y}px)`,\n            pointerEvents: hasPointerEvents ? 'all' : 'none',\n            visibility: hasDimensions ? 'visible' : 'hidden',\n            ...node.style,\n            ...inlineDimensions\n        },\n        \"data-id\": id,\n        \"data-testid\": `rf__node-${id}`,\n        onMouseEnter: onMouseEnterHandler,\n        onMouseMove: onMouseMoveHandler,\n        onMouseLeave: onMouseLeaveHandler,\n        onContextMenu: onContextMenuHandler,\n        onClick: onSelectNodeHandler,\n        onDoubleClick: onDoubleClickHandler,\n        onKeyDown: isFocusable ? onKeyDown : undefined,\n        tabIndex: isFocusable ? 0 : undefined,\n        onFocus: isFocusable ? onFocus : undefined,\n        role: node.ariaRole ?? (isFocusable ? 'group' : undefined),\n        \"aria-roledescription\": \"node\",\n        \"aria-describedby\": disableKeyboardA11y ? undefined : `${ARIA_NODE_DESC_KEY}-${rfId}`,\n        \"aria-label\": node.ariaLabel,\n        ...node.domAttributes,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Provider, {\n            value: id,\n            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeComponent, {\n                id: id,\n                data: node.data,\n                type: nodeType,\n                positionAbsoluteX: internals.positionAbsolute.x,\n                positionAbsoluteY: internals.positionAbsolute.y,\n                selected: node.selected ?? false,\n                selectable: isSelectable,\n                draggable: isDraggable,\n                deletable: node.deletable ?? true,\n                isConnectable: isConnectable,\n                sourcePosition: node.sourcePosition,\n                targetPosition: node.targetPosition,\n                dragging: dragging,\n                dragHandle: node.dragHandle,\n                zIndex: internals.z,\n                parentId: node.parentId,\n                ...nodeDimensions\n            })\n        })\n    });\n}\nconst selector$b = (s)=>({\n        nodesDraggable: s.nodesDraggable,\n        nodesConnectable: s.nodesConnectable,\n        nodesFocusable: s.nodesFocusable,\n        elementsSelectable: s.elementsSelectable,\n        onError: s.onError\n    });\nfunction NodeRendererComponent(props) {\n    const { nodesDraggable, nodesConnectable, nodesFocusable, elementsSelectable, onError } = useStore(selector$b, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const nodeIds = useVisibleNodeIds(props.onlyRenderVisibleElements);\n    const resizeObserver = useResizeObserver();\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"react-flow__nodes\",\n        style: containerStyle,\n        children: nodeIds.map((nodeId)=>{\n            return(/*\n             * The split of responsibilities between NodeRenderer and\n             * NodeComponentWrapper may appear weird. However, its designed to\n             * minimize the cost of updates when individual nodes change.\n             *\n             * For example, when youre dragging a single node, that node gets\n             * updated multiple times per second. If `NodeRenderer` were to update\n             * every time, it would have to re-run the `nodes.map()` loop every\n             * time. This gets pricey with hundreds of nodes, especially if every\n             * loop cycle does more than just rendering a JSX element!\n             *\n             * As a result of this choice, we took the following implementation\n             * decisions:\n             * - NodeRenderer subscribes *only* to node IDs  and therefore\n             *   rerender *only* when visible nodes are added or removed.\n             * - NodeRenderer performs all operations the result of which can be\n             *   shared between nodes (such as creating the `ResizeObserver`\n             *   instance, or subscribing to `selector`). This means extra prop\n             *   drilling into `NodeComponentWrapper`, but it means we need to run\n             *   these operations only once  instead of once per node.\n             * - Any operations that youd normally write inside `nodes.map` are\n             *   moved into `NodeComponentWrapper`. This ensures they are\n             *   memorized  so if `NodeRenderer` *has* to rerender, it only\n             *   needs to regenerate the list of nodes, nothing else.\n             */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeWrapper, {\n                id: nodeId,\n                nodeTypes: props.nodeTypes,\n                nodeExtent: props.nodeExtent,\n                onClick: props.onNodeClick,\n                onMouseEnter: props.onNodeMouseEnter,\n                onMouseMove: props.onNodeMouseMove,\n                onMouseLeave: props.onNodeMouseLeave,\n                onContextMenu: props.onNodeContextMenu,\n                onDoubleClick: props.onNodeDoubleClick,\n                noDragClassName: props.noDragClassName,\n                noPanClassName: props.noPanClassName,\n                rfId: props.rfId,\n                disableKeyboardA11y: props.disableKeyboardA11y,\n                resizeObserver: resizeObserver,\n                nodesDraggable: nodesDraggable,\n                nodesConnectable: nodesConnectable,\n                nodesFocusable: nodesFocusable,\n                elementsSelectable: elementsSelectable,\n                nodeClickDistance: props.nodeClickDistance,\n                onError: onError\n            }, nodeId));\n        })\n    });\n}\nNodeRendererComponent.displayName = 'NodeRenderer';\nconst NodeRenderer = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(NodeRendererComponent);\n/**\n * Hook for getting the visible edge ids from the store.\n *\n * @internal\n * @param onlyRenderVisible\n * @returns array with visible edge ids\n */ function useVisibleEdgeIds(onlyRenderVisible) {\n    const edgeIds = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"useVisibleEdgeIds.useStore[edgeIds]\": (s)=>{\n            if (!onlyRenderVisible) {\n                return s.edges.map({\n                    \"useVisibleEdgeIds.useStore[edgeIds]\": (edge)=>edge.id\n                }[\"useVisibleEdgeIds.useStore[edgeIds]\"]);\n            }\n            const visibleEdgeIds = [];\n            if (s.width && s.height) {\n                for (const edge of s.edges){\n                    const sourceNode = s.nodeLookup.get(edge.source);\n                    const targetNode = s.nodeLookup.get(edge.target);\n                    if (sourceNode && targetNode && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isEdgeVisible)({\n                        sourceNode,\n                        targetNode,\n                        width: s.width,\n                        height: s.height,\n                        transform: s.transform\n                    })) {\n                        visibleEdgeIds.push(edge.id);\n                    }\n                }\n            }\n            return visibleEdgeIds;\n        }\n    }[\"useVisibleEdgeIds.useStore[edgeIds]\"], [\n        onlyRenderVisible\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return edgeIds;\n}\nconst ArrowSymbol = ({ color = 'none', strokeWidth = 1 })=>{\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"polyline\", {\n        style: {\n            stroke: color,\n            strokeWidth\n        },\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\",\n        fill: \"none\",\n        points: \"-5,-4 0,0 -5,4\"\n    });\n};\nconst ArrowClosedSymbol = ({ color = 'none', strokeWidth = 1 })=>{\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"polyline\", {\n        style: {\n            stroke: color,\n            fill: color,\n            strokeWidth\n        },\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\",\n        points: \"-5,-4 0,0 -5,4 -5,-4\"\n    });\n};\nconst MarkerSymbols = {\n    [_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.MarkerType.Arrow]: ArrowSymbol,\n    [_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.MarkerType.ArrowClosed]: ArrowClosedSymbol\n};\nfunction useMarkerSymbol(type) {\n    const store = useStoreApi();\n    const symbol = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"useMarkerSymbol.useMemo[symbol]\": ()=>{\n            const symbolExists = Object.prototype.hasOwnProperty.call(MarkerSymbols, type);\n            if (!symbolExists) {\n                store.getState().onError?.('009', _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error009'](type));\n                return null;\n            }\n            return MarkerSymbols[type];\n        }\n    }[\"useMarkerSymbol.useMemo[symbol]\"], [\n        type\n    ]);\n    return symbol;\n}\nconst Marker = ({ id, type, color, width = 12.5, height = 12.5, markerUnits = 'strokeWidth', strokeWidth, orient = 'auto-start-reverse' })=>{\n    const Symbol = useMarkerSymbol(type);\n    if (!Symbol) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"marker\", {\n        className: \"react-flow__arrowhead\",\n        id: id,\n        markerWidth: `${width}`,\n        markerHeight: `${height}`,\n        viewBox: \"-10 -10 20 20\",\n        markerUnits: markerUnits,\n        orient: orient,\n        refX: \"0\",\n        refY: \"0\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Symbol, {\n            color: color,\n            strokeWidth: strokeWidth\n        })\n    });\n};\n/*\n * when you have multiple flows on a page and you hide the first one, the other ones have no markers anymore\n * when they do have markers with the same ids. To prevent this the user can pass a unique id to the react flow wrapper\n * that we can then use for creating our unique marker ids\n */ const MarkerDefinitions = ({ defaultColor, rfId })=>{\n    const edges = useStore({\n        \"MarkerDefinitions.useStore[edges]\": (s)=>s.edges\n    }[\"MarkerDefinitions.useStore[edges]\"]);\n    const defaultEdgeOptions = useStore({\n        \"MarkerDefinitions.useStore[defaultEdgeOptions]\": (s)=>s.defaultEdgeOptions\n    }[\"MarkerDefinitions.useStore[defaultEdgeOptions]\"]);\n    const markers = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"MarkerDefinitions.useMemo[markers]\": ()=>{\n            const markers = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.createMarkerIds)(edges, {\n                id: rfId,\n                defaultColor,\n                defaultMarkerStart: defaultEdgeOptions?.markerStart,\n                defaultMarkerEnd: defaultEdgeOptions?.markerEnd\n            });\n            return markers;\n        }\n    }[\"MarkerDefinitions.useMemo[markers]\"], [\n        edges,\n        defaultEdgeOptions,\n        rfId,\n        defaultColor\n    ]);\n    if (!markers.length) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        className: \"react-flow__marker\",\n        \"aria-hidden\": \"true\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"defs\", {\n            children: markers.map((marker)=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Marker, {\n                    id: marker.id,\n                    type: marker.type,\n                    color: marker.color,\n                    width: marker.width,\n                    height: marker.height,\n                    markerUnits: marker.markerUnits,\n                    strokeWidth: marker.strokeWidth,\n                    orient: marker.orient\n                }, marker.id))\n        })\n    });\n};\nMarkerDefinitions.displayName = 'MarkerDefinitions';\nvar MarkerDefinitions$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(MarkerDefinitions);\nfunction EdgeTextComponent({ x, y, label, labelStyle, labelShowBg = true, labelBgStyle, labelBgPadding = [\n    2,\n    4\n], labelBgBorderRadius = 2, children, className, ...rest }) {\n    const [edgeTextBbox, setEdgeTextBbox] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        x: 1,\n        y: 0,\n        width: 0,\n        height: 0\n    });\n    const edgeTextClasses = (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n        'react-flow__edge-textwrapper',\n        className\n    ]);\n    const edgeTextRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"EdgeTextComponent.useEffect\": ()=>{\n            if (edgeTextRef.current) {\n                const textBbox = edgeTextRef.current.getBBox();\n                setEdgeTextBbox({\n                    x: textBbox.x,\n                    y: textBbox.y,\n                    width: textBbox.width,\n                    height: textBbox.height\n                });\n            }\n        }\n    }[\"EdgeTextComponent.useEffect\"], [\n        label\n    ]);\n    if (!label) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", {\n        transform: `translate(${x - edgeTextBbox.width / 2} ${y - edgeTextBbox.height / 2})`,\n        className: edgeTextClasses,\n        visibility: edgeTextBbox.width ? 'visible' : 'hidden',\n        ...rest,\n        children: [\n            labelShowBg && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"rect\", {\n                width: edgeTextBbox.width + 2 * labelBgPadding[0],\n                x: -labelBgPadding[0],\n                y: -labelBgPadding[1],\n                height: edgeTextBbox.height + 2 * labelBgPadding[1],\n                className: \"react-flow__edge-textbg\",\n                style: labelBgStyle,\n                rx: labelBgBorderRadius,\n                ry: labelBgBorderRadius\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"text\", {\n                className: \"react-flow__edge-text\",\n                y: edgeTextBbox.height / 2,\n                dy: \"0.3em\",\n                ref: edgeTextRef,\n                style: labelStyle,\n                children: label\n            }),\n            children\n        ]\n    });\n}\nEdgeTextComponent.displayName = 'EdgeText';\n/**\n * You can use the `<EdgeText />` component as a helper component to display text\n * within your custom edges.\n *\n * @public\n *\n * @example\n * ```jsx\n * import { EdgeText } from '@xyflow/react';\n *\n * export function CustomEdgeLabel({ label }) {\n *   return (\n *     <EdgeText\n *       x={100}\n *       y={100}\n *       label={label}\n *       labelStyle={{ fill: 'white' }}\n *       labelShowBg\n *       labelBgStyle={{ fill: 'red' }}\n *       labelBgPadding={[2, 4]}\n *       labelBgBorderRadius={2}\n *     />\n *   );\n * }\n *```\n */ const EdgeText = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(EdgeTextComponent);\n/**\n * The `<BaseEdge />` component gets used internally for all the edges. It can be\n * used inside a custom edge and handles the invisible helper edge and the edge label\n * for you.\n *\n * @public\n * @example\n * ```jsx\n *import { BaseEdge } from '@xyflow/react';\n *\n *export function CustomEdge({ sourceX, sourceY, targetX, targetY, ...props }) {\n *  const [edgePath] = getStraightPath({\n *    sourceX,\n *    sourceY,\n *    targetX,\n *    targetY,\n *  });\n *\n *  return <BaseEdge path={edgePath} {...props} />;\n *}\n *```\n *\n * @remarks If you want to use an edge marker with the [`<BaseEdge />`](/api-reference/components/base-edge) component,\n * you can pass the `markerStart` or `markerEnd` props passed to your custom edge\n * through to the [`<BaseEdge />`](/api-reference/components/base-edge) component.\n * You can see all the props passed to a custom edge by looking at the [`EdgeProps`](/api-reference/types/edge-props) type.\n */ function BaseEdge({ path, labelX, labelY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, interactionWidth = 20, ...props }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                ...props,\n                d: path,\n                fill: \"none\",\n                className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n                    'react-flow__edge-path',\n                    props.className\n                ])\n            }),\n            interactionWidth && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                d: path,\n                fill: \"none\",\n                strokeOpacity: 0,\n                strokeWidth: interactionWidth,\n                className: \"react-flow__edge-interaction\"\n            }),\n            label && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isNumeric)(labelX) && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isNumeric)(labelY) ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeText, {\n                x: labelX,\n                y: labelY,\n                label: label,\n                labelStyle: labelStyle,\n                labelShowBg: labelShowBg,\n                labelBgStyle: labelBgStyle,\n                labelBgPadding: labelBgPadding,\n                labelBgBorderRadius: labelBgBorderRadius\n            }) : null\n        ]\n    });\n}\nfunction getControl({ pos, x1, y1, x2, y2 }) {\n    if (pos === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Left || pos === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Right) {\n        return [\n            0.5 * (x1 + x2),\n            y1\n        ];\n    }\n    return [\n        x1,\n        0.5 * (y1 + y2)\n    ];\n}\n/**\n * The `getSimpleBezierPath` util returns everything you need to render a simple\n * bezier edge between two nodes.\n * @public\n * @returns\n * - `path`: the path to use in an SVG `<path>` element.\n * - `labelX`: the `x` position you can use to render a label for this edge.\n * - `labelY`: the `y` position you can use to render a label for this edge.\n * - `offsetX`: the absolute difference between the source `x` position and the `x` position of the\n * middle of this path.\n * - `offsetY`: the absolute difference between the source `y` position and the `y` position of the\n * middle of this path.\n */ function getSimpleBezierPath({ sourceX, sourceY, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom, targetX, targetY, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top }) {\n    const [sourceControlX, sourceControlY] = getControl({\n        pos: sourcePosition,\n        x1: sourceX,\n        y1: sourceY,\n        x2: targetX,\n        y2: targetY\n    });\n    const [targetControlX, targetControlY] = getControl({\n        pos: targetPosition,\n        x1: targetX,\n        y1: targetY,\n        x2: sourceX,\n        y2: sourceY\n    });\n    const [labelX, labelY, offsetX, offsetY] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBezierEdgeCenter)({\n        sourceX,\n        sourceY,\n        targetX,\n        targetY,\n        sourceControlX,\n        sourceControlY,\n        targetControlX,\n        targetControlY\n    });\n    return [\n        `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,\n        labelX,\n        labelY,\n        offsetX,\n        offsetY\n    ];\n}\nfunction createSimpleBezierEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ id, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, interactionWidth })=>{\n        const [path, labelX, labelY] = getSimpleBezierPath({\n            sourceX,\n            sourceY,\n            sourcePosition,\n            targetX,\n            targetY,\n            targetPosition\n        });\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {\n            id: _id,\n            path: path,\n            labelX: labelX,\n            labelY: labelY,\n            label: label,\n            labelStyle: labelStyle,\n            labelShowBg: labelShowBg,\n            labelBgStyle: labelBgStyle,\n            labelBgPadding: labelBgPadding,\n            labelBgBorderRadius: labelBgBorderRadius,\n            style: style,\n            markerEnd: markerEnd,\n            markerStart: markerStart,\n            interactionWidth: interactionWidth\n        });\n    });\n}\nconst SimpleBezierEdge = createSimpleBezierEdge({\n    isInternal: false\n});\nconst SimpleBezierEdgeInternal = createSimpleBezierEdge({\n    isInternal: true\n});\nSimpleBezierEdge.displayName = 'SimpleBezierEdge';\nSimpleBezierEdgeInternal.displayName = 'SimpleBezierEdgeInternal';\nfunction createSmoothStepEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ id, sourceX, sourceY, targetX, targetY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top, markerEnd, markerStart, pathOptions, interactionWidth })=>{\n        const [path, labelX, labelY] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getSmoothStepPath)({\n            sourceX,\n            sourceY,\n            sourcePosition,\n            targetX,\n            targetY,\n            targetPosition,\n            borderRadius: pathOptions?.borderRadius,\n            offset: pathOptions?.offset\n        });\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {\n            id: _id,\n            path: path,\n            labelX: labelX,\n            labelY: labelY,\n            label: label,\n            labelStyle: labelStyle,\n            labelShowBg: labelShowBg,\n            labelBgStyle: labelBgStyle,\n            labelBgPadding: labelBgPadding,\n            labelBgBorderRadius: labelBgBorderRadius,\n            style: style,\n            markerEnd: markerEnd,\n            markerStart: markerStart,\n            interactionWidth: interactionWidth\n        });\n    });\n}\n/**\n * Component that can be used inside a custom edge to render a smooth step edge.\n *\n * @public\n * @example\n *\n * ```tsx\n * import { SmoothStepEdge } from '@xyflow/react';\n *\n * function CustomEdge({ sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition }) {\n *   return (\n *     <SmoothStepEdge\n *       sourceX={sourceX}\n *       sourceY={sourceY}\n *       targetX={targetX}\n *       targetY={targetY}\n *       sourcePosition={sourcePosition}\n *       targetPosition={targetPosition}\n *     />\n *   );\n * }\n * ```\n */ const SmoothStepEdge = createSmoothStepEdge({\n    isInternal: false\n});\n/**\n * @internal\n */ const SmoothStepEdgeInternal = createSmoothStepEdge({\n    isInternal: true\n});\nSmoothStepEdge.displayName = 'SmoothStepEdge';\nSmoothStepEdgeInternal.displayName = 'SmoothStepEdgeInternal';\nfunction createStepEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ id, ...props })=>{\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SmoothStepEdge, {\n            ...props,\n            id: _id,\n            pathOptions: (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n                \"createStepEdge.useMemo\": ()=>({\n                        borderRadius: 0,\n                        offset: props.pathOptions?.offset\n                    })\n            }[\"createStepEdge.useMemo\"], [\n                props.pathOptions?.offset\n            ])\n        });\n    });\n}\n/**\n * Component that can be used inside a custom edge to render a step edge.\n *\n * @public\n * @example\n *\n * ```tsx\n * import { StepEdge } from '@xyflow/react';\n *\n * function CustomEdge({ sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition }) {\n *   return (\n *     <StepEdge\n *       sourceX={sourceX}\n *       sourceY={sourceY}\n *       targetX={targetX}\n *       targetY={targetY}\n *       sourcePosition={sourcePosition}\n *       targetPosition={targetPosition}\n *     />\n *   );\n * }\n * ```\n */ const StepEdge = createStepEdge({\n    isInternal: false\n});\n/**\n * @internal\n */ const StepEdgeInternal = createStepEdge({\n    isInternal: true\n});\nStepEdge.displayName = 'StepEdge';\nStepEdgeInternal.displayName = 'StepEdgeInternal';\nfunction createStraightEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ id, sourceX, sourceY, targetX, targetY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, interactionWidth })=>{\n        const [path, labelX, labelY] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getStraightPath)({\n            sourceX,\n            sourceY,\n            targetX,\n            targetY\n        });\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {\n            id: _id,\n            path: path,\n            labelX: labelX,\n            labelY: labelY,\n            label: label,\n            labelStyle: labelStyle,\n            labelShowBg: labelShowBg,\n            labelBgStyle: labelBgStyle,\n            labelBgPadding: labelBgPadding,\n            labelBgBorderRadius: labelBgBorderRadius,\n            style: style,\n            markerEnd: markerEnd,\n            markerStart: markerStart,\n            interactionWidth: interactionWidth\n        });\n    });\n}\n/**\n * Component that can be used inside a custom edge to render a straight line.\n *\n * @public\n * @example\n *\n * ```tsx\n * import { StraightEdge } from '@xyflow/react';\n *\n * function CustomEdge({ sourceX, sourceY, targetX, targetY }) {\n *   return (\n *     <StraightEdge\n *       sourceX={sourceX}\n *       sourceY={sourceY}\n *       targetX={targetX}\n *       targetY={targetY}\n *     />\n *   );\n * }\n * ```\n */ const StraightEdge = createStraightEdge({\n    isInternal: false\n});\n/**\n * @internal\n */ const StraightEdgeInternal = createStraightEdge({\n    isInternal: true\n});\nStraightEdge.displayName = 'StraightEdge';\nStraightEdgeInternal.displayName = 'StraightEdgeInternal';\nfunction createBezierEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ id, sourceX, sourceY, targetX, targetY, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, pathOptions, interactionWidth })=>{\n        const [path, labelX, labelY] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBezierPath)({\n            sourceX,\n            sourceY,\n            sourcePosition,\n            targetX,\n            targetY,\n            targetPosition,\n            curvature: pathOptions?.curvature\n        });\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {\n            id: _id,\n            path: path,\n            labelX: labelX,\n            labelY: labelY,\n            label: label,\n            labelStyle: labelStyle,\n            labelShowBg: labelShowBg,\n            labelBgStyle: labelBgStyle,\n            labelBgPadding: labelBgPadding,\n            labelBgBorderRadius: labelBgBorderRadius,\n            style: style,\n            markerEnd: markerEnd,\n            markerStart: markerStart,\n            interactionWidth: interactionWidth\n        });\n    });\n}\n/**\n * Component that can be used inside a custom edge to render a bezier curve.\n *\n * @public\n * @example\n *\n * ```tsx\n * import { BezierEdge } from '@xyflow/react';\n *\n * function CustomEdge({ sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition }) {\n *   return (\n *     <BezierEdge\n *       sourceX={sourceX}\n *       sourceY={sourceY}\n *       targetX={targetX}\n *       targetY={targetY}\n *       sourcePosition={sourcePosition}\n *       targetPosition={targetPosition}\n *     />\n *   );\n * }\n * ```\n */ const BezierEdge = createBezierEdge({\n    isInternal: false\n});\n/**\n * @internal\n */ const BezierEdgeInternal = createBezierEdge({\n    isInternal: true\n});\nBezierEdge.displayName = 'BezierEdge';\nBezierEdgeInternal.displayName = 'BezierEdgeInternal';\nconst builtinEdgeTypes = {\n    default: BezierEdgeInternal,\n    straight: StraightEdgeInternal,\n    step: StepEdgeInternal,\n    smoothstep: SmoothStepEdgeInternal,\n    simplebezier: SimpleBezierEdgeInternal\n};\nconst nullPosition = {\n    sourceX: null,\n    sourceY: null,\n    targetX: null,\n    targetY: null,\n    sourcePosition: null,\n    targetPosition: null\n};\nconst shiftX = (x, shift, position)=>{\n    if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Left) return x - shift;\n    if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Right) return x + shift;\n    return x;\n};\nconst shiftY = (y, shift, position)=>{\n    if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top) return y - shift;\n    if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom) return y + shift;\n    return y;\n};\nconst EdgeUpdaterClassName = 'react-flow__edgeupdater';\n/**\n * @internal\n */ function EdgeAnchor({ position, centerX, centerY, radius = 10, onMouseDown, onMouseEnter, onMouseOut, type }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n        onMouseDown: onMouseDown,\n        onMouseEnter: onMouseEnter,\n        onMouseOut: onMouseOut,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            EdgeUpdaterClassName,\n            `${EdgeUpdaterClassName}-${type}`\n        ]),\n        cx: shiftX(centerX, radius, position),\n        cy: shiftY(centerY, radius, position),\n        r: radius,\n        stroke: \"transparent\",\n        fill: \"transparent\"\n    });\n}\nfunction EdgeUpdateAnchors({ isReconnectable, reconnectRadius, edge, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, onReconnect, onReconnectStart, onReconnectEnd, setReconnecting, setUpdateHover }) {\n    const store = useStoreApi();\n    const handleEdgeUpdater = (event, oppositeHandle)=>{\n        // avoid triggering edge updater if mouse btn is not left\n        if (event.button !== 0) {\n            return;\n        }\n        const { autoPanOnConnect, domNode, isValidConnection, connectionMode, connectionRadius, lib, onConnectStart, onConnectEnd, cancelConnection, nodeLookup, rfId: flowId, panBy, updateConnection } = store.getState();\n        const isTarget = oppositeHandle.type === 'target';\n        setReconnecting(true);\n        onReconnectStart?.(event, edge, oppositeHandle.type);\n        const _onReconnectEnd = (evt, connectionState)=>{\n            setReconnecting(false);\n            onReconnectEnd?.(evt, edge, oppositeHandle.type, connectionState);\n        };\n        const onConnectEdge = (connection)=>onReconnect?.(edge, connection);\n        _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYHandle.onPointerDown(event.nativeEvent, {\n            autoPanOnConnect,\n            connectionMode,\n            connectionRadius,\n            domNode,\n            handleId: oppositeHandle.id,\n            nodeId: oppositeHandle.nodeId,\n            nodeLookup,\n            isTarget,\n            edgeUpdaterType: oppositeHandle.type,\n            lib,\n            flowId,\n            cancelConnection,\n            panBy,\n            isValidConnection,\n            onConnect: onConnectEdge,\n            onConnectStart,\n            onConnectEnd,\n            onReconnectEnd: _onReconnectEnd,\n            updateConnection,\n            getTransform: ()=>store.getState().transform,\n            getFromHandle: ()=>store.getState().connection.fromHandle\n        });\n    };\n    const onReconnectSourceMouseDown = (event)=>handleEdgeUpdater(event, {\n            nodeId: edge.target,\n            id: edge.targetHandle ?? null,\n            type: 'target'\n        });\n    const onReconnectTargetMouseDown = (event)=>handleEdgeUpdater(event, {\n            nodeId: edge.source,\n            id: edge.sourceHandle ?? null,\n            type: 'source'\n        });\n    const onReconnectMouseEnter = ()=>setUpdateHover(true);\n    const onReconnectMouseOut = ()=>setUpdateHover(false);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (isReconnectable === true || isReconnectable === 'source') && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeAnchor, {\n                position: sourcePosition,\n                centerX: sourceX,\n                centerY: sourceY,\n                radius: reconnectRadius,\n                onMouseDown: onReconnectSourceMouseDown,\n                onMouseEnter: onReconnectMouseEnter,\n                onMouseOut: onReconnectMouseOut,\n                type: \"source\"\n            }),\n            (isReconnectable === true || isReconnectable === 'target') && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeAnchor, {\n                position: targetPosition,\n                centerX: targetX,\n                centerY: targetY,\n                radius: reconnectRadius,\n                onMouseDown: onReconnectTargetMouseDown,\n                onMouseEnter: onReconnectMouseEnter,\n                onMouseOut: onReconnectMouseOut,\n                type: \"target\"\n            })\n        ]\n    });\n}\nfunction EdgeWrapper({ id, edgesFocusable, edgesReconnectable, elementsSelectable, onClick, onDoubleClick, onContextMenu, onMouseEnter, onMouseMove, onMouseLeave, reconnectRadius, onReconnect, onReconnectStart, onReconnectEnd, rfId, edgeTypes, noPanClassName, onError, disableKeyboardA11y }) {\n    let edge = useStore({\n        \"EdgeWrapper.useStore[edge]\": (s)=>s.edgeLookup.get(id)\n    }[\"EdgeWrapper.useStore[edge]\"]);\n    const defaultEdgeOptions = useStore({\n        \"EdgeWrapper.useStore[defaultEdgeOptions]\": (s)=>s.defaultEdgeOptions\n    }[\"EdgeWrapper.useStore[defaultEdgeOptions]\"]);\n    edge = defaultEdgeOptions ? {\n        ...defaultEdgeOptions,\n        ...edge\n    } : edge;\n    let edgeType = edge.type || 'default';\n    let EdgeComponent = edgeTypes?.[edgeType] || builtinEdgeTypes[edgeType];\n    if (EdgeComponent === undefined) {\n        onError?.('011', _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error011'](edgeType));\n        edgeType = 'default';\n        EdgeComponent = builtinEdgeTypes.default;\n    }\n    const isFocusable = !!(edge.focusable || edgesFocusable && typeof edge.focusable === 'undefined');\n    const isReconnectable = typeof onReconnect !== 'undefined' && (edge.reconnectable || edgesReconnectable && typeof edge.reconnectable === 'undefined');\n    const isSelectable = !!(edge.selectable || elementsSelectable && typeof edge.selectable === 'undefined');\n    const edgeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [updateHover, setUpdateHover] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [reconnecting, setReconnecting] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const store = useStoreApi();\n    const { zIndex, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition } = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"EdgeWrapper.useStore.useCallback\": (store)=>{\n            const sourceNode = store.nodeLookup.get(edge.source);\n            const targetNode = store.nodeLookup.get(edge.target);\n            if (!sourceNode || !targetNode) {\n                return {\n                    zIndex: edge.zIndex,\n                    ...nullPosition\n                };\n            }\n            const edgePosition = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getEdgePosition)({\n                id,\n                sourceNode,\n                targetNode,\n                sourceHandle: edge.sourceHandle || null,\n                targetHandle: edge.targetHandle || null,\n                connectionMode: store.connectionMode,\n                onError\n            });\n            const zIndex = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getElevatedEdgeZIndex)({\n                selected: edge.selected,\n                zIndex: edge.zIndex,\n                sourceNode,\n                targetNode,\n                elevateOnSelect: store.elevateEdgesOnSelect\n            });\n            return {\n                zIndex,\n                ...edgePosition || nullPosition\n            };\n        }\n    }[\"EdgeWrapper.useStore.useCallback\"], [\n        edge.source,\n        edge.target,\n        edge.sourceHandle,\n        edge.targetHandle,\n        edge.selected,\n        edge.zIndex\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const markerStartUrl = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"EdgeWrapper.useMemo[markerStartUrl]\": ()=>edge.markerStart ? `url('#${(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getMarkerId)(edge.markerStart, rfId)}')` : undefined\n    }[\"EdgeWrapper.useMemo[markerStartUrl]\"], [\n        edge.markerStart,\n        rfId\n    ]);\n    const markerEndUrl = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"EdgeWrapper.useMemo[markerEndUrl]\": ()=>edge.markerEnd ? `url('#${(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getMarkerId)(edge.markerEnd, rfId)}')` : undefined\n    }[\"EdgeWrapper.useMemo[markerEndUrl]\"], [\n        edge.markerEnd,\n        rfId\n    ]);\n    if (edge.hidden || sourceX === null || sourceY === null || targetX === null || targetY === null) {\n        return null;\n    }\n    const onEdgeClick = (event)=>{\n        const { addSelectedEdges, unselectNodesAndEdges, multiSelectionActive } = store.getState();\n        if (isSelectable) {\n            store.setState({\n                nodesSelectionActive: false\n            });\n            if (edge.selected && multiSelectionActive) {\n                unselectNodesAndEdges({\n                    nodes: [],\n                    edges: [\n                        edge\n                    ]\n                });\n                edgeRef.current?.blur();\n            } else {\n                addSelectedEdges([\n                    id\n                ]);\n            }\n        }\n        if (onClick) {\n            onClick(event, edge);\n        }\n    };\n    const onEdgeDoubleClick = onDoubleClick ? (event)=>{\n        onDoubleClick(event, {\n            ...edge\n        });\n    } : undefined;\n    const onEdgeContextMenu = onContextMenu ? (event)=>{\n        onContextMenu(event, {\n            ...edge\n        });\n    } : undefined;\n    const onEdgeMouseEnter = onMouseEnter ? (event)=>{\n        onMouseEnter(event, {\n            ...edge\n        });\n    } : undefined;\n    const onEdgeMouseMove = onMouseMove ? (event)=>{\n        onMouseMove(event, {\n            ...edge\n        });\n    } : undefined;\n    const onEdgeMouseLeave = onMouseLeave ? (event)=>{\n        onMouseLeave(event, {\n            ...edge\n        });\n    } : undefined;\n    const onKeyDown = (event)=>{\n        if (!disableKeyboardA11y && _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.elementSelectionKeys.includes(event.key) && isSelectable) {\n            const { unselectNodesAndEdges, addSelectedEdges } = store.getState();\n            const unselect = event.key === 'Escape';\n            if (unselect) {\n                edgeRef.current?.blur();\n                unselectNodesAndEdges({\n                    edges: [\n                        edge\n                    ]\n                });\n            } else {\n                addSelectedEdges([\n                    id\n                ]);\n            }\n        }\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        style: {\n            zIndex\n        },\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", {\n            className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n                'react-flow__edge',\n                `react-flow__edge-${edgeType}`,\n                edge.className,\n                noPanClassName,\n                {\n                    selected: edge.selected,\n                    animated: edge.animated,\n                    inactive: !isSelectable && !onClick,\n                    updating: updateHover,\n                    selectable: isSelectable\n                }\n            ]),\n            onClick: onEdgeClick,\n            onDoubleClick: onEdgeDoubleClick,\n            onContextMenu: onEdgeContextMenu,\n            onMouseEnter: onEdgeMouseEnter,\n            onMouseMove: onEdgeMouseMove,\n            onMouseLeave: onEdgeMouseLeave,\n            onKeyDown: isFocusable ? onKeyDown : undefined,\n            tabIndex: isFocusable ? 0 : undefined,\n            role: edge.ariaRole ?? (isFocusable ? 'group' : 'img'),\n            \"aria-roledescription\": \"edge\",\n            \"data-id\": id,\n            \"data-testid\": `rf__edge-${id}`,\n            \"aria-label\": edge.ariaLabel === null ? undefined : edge.ariaLabel || `Edge from ${edge.source} to ${edge.target}`,\n            \"aria-describedby\": isFocusable ? `${ARIA_EDGE_DESC_KEY}-${rfId}` : undefined,\n            ref: edgeRef,\n            ...edge.domAttributes,\n            children: [\n                !reconnecting && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeComponent, {\n                    id: id,\n                    source: edge.source,\n                    target: edge.target,\n                    type: edge.type,\n                    selected: edge.selected,\n                    animated: edge.animated,\n                    selectable: isSelectable,\n                    deletable: edge.deletable ?? true,\n                    label: edge.label,\n                    labelStyle: edge.labelStyle,\n                    labelShowBg: edge.labelShowBg,\n                    labelBgStyle: edge.labelBgStyle,\n                    labelBgPadding: edge.labelBgPadding,\n                    labelBgBorderRadius: edge.labelBgBorderRadius,\n                    sourceX: sourceX,\n                    sourceY: sourceY,\n                    targetX: targetX,\n                    targetY: targetY,\n                    sourcePosition: sourcePosition,\n                    targetPosition: targetPosition,\n                    data: edge.data,\n                    style: edge.style,\n                    sourceHandleId: edge.sourceHandle,\n                    targetHandleId: edge.targetHandle,\n                    markerStart: markerStartUrl,\n                    markerEnd: markerEndUrl,\n                    pathOptions: 'pathOptions' in edge ? edge.pathOptions : undefined,\n                    interactionWidth: edge.interactionWidth\n                }),\n                isReconnectable && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeUpdateAnchors, {\n                    edge: edge,\n                    isReconnectable: isReconnectable,\n                    reconnectRadius: reconnectRadius,\n                    onReconnect: onReconnect,\n                    onReconnectStart: onReconnectStart,\n                    onReconnectEnd: onReconnectEnd,\n                    sourceX: sourceX,\n                    sourceY: sourceY,\n                    targetX: targetX,\n                    targetY: targetY,\n                    sourcePosition: sourcePosition,\n                    targetPosition: targetPosition,\n                    setUpdateHover: setUpdateHover,\n                    setReconnecting: setReconnecting\n                })\n            ]\n        })\n    });\n}\nconst selector$a = (s)=>({\n        edgesFocusable: s.edgesFocusable,\n        edgesReconnectable: s.edgesReconnectable,\n        elementsSelectable: s.elementsSelectable,\n        connectionMode: s.connectionMode,\n        onError: s.onError\n    });\nfunction EdgeRendererComponent({ defaultMarkerColor, onlyRenderVisibleElements, rfId, edgeTypes, noPanClassName, onReconnect, onEdgeContextMenu, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, onEdgeClick, reconnectRadius, onEdgeDoubleClick, onReconnectStart, onReconnectEnd, disableKeyboardA11y }) {\n    const { edgesFocusable, edgesReconnectable, elementsSelectable, onError } = useStore(selector$a, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const edgeIds = useVisibleEdgeIds(onlyRenderVisibleElements);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n        className: \"react-flow__edges\",\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(MarkerDefinitions$1, {\n                defaultColor: defaultMarkerColor,\n                rfId: rfId\n            }),\n            edgeIds.map((id)=>{\n                return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeWrapper, {\n                    id: id,\n                    edgesFocusable: edgesFocusable,\n                    edgesReconnectable: edgesReconnectable,\n                    elementsSelectable: elementsSelectable,\n                    noPanClassName: noPanClassName,\n                    onReconnect: onReconnect,\n                    onContextMenu: onEdgeContextMenu,\n                    onMouseEnter: onEdgeMouseEnter,\n                    onMouseMove: onEdgeMouseMove,\n                    onMouseLeave: onEdgeMouseLeave,\n                    onClick: onEdgeClick,\n                    reconnectRadius: reconnectRadius,\n                    onDoubleClick: onEdgeDoubleClick,\n                    onReconnectStart: onReconnectStart,\n                    onReconnectEnd: onReconnectEnd,\n                    rfId: rfId,\n                    onError: onError,\n                    edgeTypes: edgeTypes,\n                    disableKeyboardA11y: disableKeyboardA11y\n                }, id);\n            })\n        ]\n    });\n}\nEdgeRendererComponent.displayName = 'EdgeRenderer';\nconst EdgeRenderer = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(EdgeRendererComponent);\nconst selector$9 = (s)=>`translate(${s.transform[0]}px,${s.transform[1]}px) scale(${s.transform[2]})`;\nfunction Viewport({ children }) {\n    const transform = useStore(selector$9);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"react-flow__viewport xyflow__viewport react-flow__container\",\n        style: {\n            transform\n        },\n        children: children\n    });\n}\n/**\n * Hook for calling onInit handler.\n *\n * @internal\n */ function useOnInitHandler(onInit) {\n    const rfInstance = useReactFlow();\n    const isInitialized = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useOnInitHandler.useEffect\": ()=>{\n            if (!isInitialized.current && rfInstance.viewportInitialized && onInit) {\n                setTimeout({\n                    \"useOnInitHandler.useEffect\": ()=>onInit(rfInstance)\n                }[\"useOnInitHandler.useEffect\"], 1);\n                isInitialized.current = true;\n            }\n        }\n    }[\"useOnInitHandler.useEffect\"], [\n        onInit,\n        rfInstance.viewportInitialized\n    ]);\n}\nconst selector$8 = (state)=>state.panZoom?.syncViewport;\n/**\n * Hook for syncing the viewport with the panzoom instance.\n *\n * @internal\n * @param viewport\n */ function useViewportSync(viewport) {\n    const syncViewport = useStore(selector$8);\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useViewportSync.useEffect\": ()=>{\n            if (viewport) {\n                syncViewport?.(viewport);\n                store.setState({\n                    transform: [\n                        viewport.x,\n                        viewport.y,\n                        viewport.zoom\n                    ]\n                });\n            }\n        }\n    }[\"useViewportSync.useEffect\"], [\n        viewport,\n        syncViewport\n    ]);\n    return null;\n}\nfunction storeSelector$1(s) {\n    return s.connection.inProgress ? {\n        ...s.connection,\n        to: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.pointToRendererPoint)(s.connection.to, s.transform)\n    } : {\n        ...s.connection\n    };\n}\nfunction getSelector(connectionSelector) {\n    if (connectionSelector) {\n        const combinedSelector = (s)=>{\n            const connection = storeSelector$1(s);\n            return connectionSelector(connection);\n        };\n        return combinedSelector;\n    }\n    return storeSelector$1;\n}\n/**\n * The `useConnection` hook returns the current connection when there is an active\n * connection interaction. If no connection interaction is active, it returns null\n * for every property. A typical use case for this hook is to colorize handles\n * based on a certain condition (e.g. if the connection is valid or not).\n *\n * @public\n * @param connectionSelector - An optional selector function used to extract a slice of the\n * `ConnectionState` data. Using a selector can prevent component re-renders where data you don't\n * otherwise care about might change. If a selector is not provided, the entire `ConnectionState`\n * object is returned unchanged.\n * @example\n *\n * ```tsx\n *import { useConnection } from '@xyflow/react';\n *\n *function App() {\n *  const connection = useConnection();\n *\n *  return (\n *    <div> {connection ? `Someone is trying to make a connection from ${connection.fromNode} to this one.` : 'There are currently no incoming connections!'}\n *\n *   </div>\n *   );\n * }\n * ```\n *\n * @returns ConnectionState\n */ function useConnection(connectionSelector) {\n    const combinedSelector = getSelector(connectionSelector);\n    return useStore(combinedSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n}\nconst selector$7 = (s)=>({\n        nodesConnectable: s.nodesConnectable,\n        isValid: s.connection.isValid,\n        inProgress: s.connection.inProgress,\n        width: s.width,\n        height: s.height\n    });\nfunction ConnectionLineWrapper({ containerStyle, style, type, component }) {\n    const { nodesConnectable, width, height, isValid, inProgress } = useStore(selector$7, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const renderConnection = !!(width && nodesConnectable && inProgress);\n    if (!renderConnection) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        style: containerStyle,\n        width: width,\n        height: height,\n        className: \"react-flow__connectionline react-flow__container\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"g\", {\n            className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n                'react-flow__connection',\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getConnectionStatus)(isValid)\n            ]),\n            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ConnectionLine, {\n                style: style,\n                type: type,\n                CustomComponent: component,\n                isValid: isValid\n            })\n        })\n    });\n}\nconst ConnectionLine = ({ style, type = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.Bezier, CustomComponent, isValid })=>{\n    const { inProgress, from, fromNode, fromHandle, fromPosition, to, toNode, toHandle, toPosition } = useConnection();\n    if (!inProgress) {\n        return;\n    }\n    if (CustomComponent) {\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(CustomComponent, {\n            connectionLineType: type,\n            connectionLineStyle: style,\n            fromNode: fromNode,\n            fromHandle: fromHandle,\n            fromX: from.x,\n            fromY: from.y,\n            toX: to.x,\n            toY: to.y,\n            fromPosition: fromPosition,\n            toPosition: toPosition,\n            connectionStatus: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getConnectionStatus)(isValid),\n            toNode: toNode,\n            toHandle: toHandle\n        });\n    }\n    let path = '';\n    const pathParams = {\n        sourceX: from.x,\n        sourceY: from.y,\n        sourcePosition: fromPosition,\n        targetX: to.x,\n        targetY: to.y,\n        targetPosition: toPosition\n    };\n    switch(type){\n        case _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.Bezier:\n            [path] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBezierPath)(pathParams);\n            break;\n        case _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.SimpleBezier:\n            [path] = getSimpleBezierPath(pathParams);\n            break;\n        case _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.Step:\n            [path] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getSmoothStepPath)({\n                ...pathParams,\n                borderRadius: 0\n            });\n            break;\n        case _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.SmoothStep:\n            [path] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getSmoothStepPath)(pathParams);\n            break;\n        default:\n            [path] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getStraightPath)(pathParams);\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n        d: path,\n        fill: \"none\",\n        className: \"react-flow__connection-path\",\n        style: style\n    });\n};\nConnectionLine.displayName = 'ConnectionLine';\nconst emptyTypes = {};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction useNodeOrEdgeTypesWarning(nodeOrEdgeTypes = emptyTypes) {\n    const typesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(nodeOrEdgeTypes);\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useNodeOrEdgeTypesWarning.useEffect\": ()=>{\n            if (true) {\n                const usedKeys = new Set([\n                    ...Object.keys(typesRef.current),\n                    ...Object.keys(nodeOrEdgeTypes)\n                ]);\n                for (const key of usedKeys){\n                    if (typesRef.current[key] !== nodeOrEdgeTypes[key]) {\n                        store.getState().onError?.('002', _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error002']());\n                        break;\n                    }\n                }\n                typesRef.current = nodeOrEdgeTypes;\n            }\n        }\n    }[\"useNodeOrEdgeTypesWarning.useEffect\"], [\n        nodeOrEdgeTypes\n    ]);\n}\nfunction useStylesLoadedWarning() {\n    const store = useStoreApi();\n    const checked = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useStylesLoadedWarning.useEffect\": ()=>{\n            if (true) {\n                if (!checked.current) {\n                    const pane = document.querySelector('.react-flow__pane');\n                    if (pane && !(window.getComputedStyle(pane).zIndex === '1')) {\n                        store.getState().onError?.('013', _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error013']('react'));\n                    }\n                    checked.current = true;\n                }\n            }\n        }\n    }[\"useStylesLoadedWarning.useEffect\"], []);\n}\nfunction GraphViewComponent({ nodeTypes, edgeTypes, onInit, onNodeClick, onEdgeClick, onNodeDoubleClick, onEdgeDoubleClick, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, onSelectionContextMenu, onSelectionStart, onSelectionEnd, connectionLineType, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, selectionKeyCode, selectionOnDrag, selectionMode, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, deleteKeyCode, onlyRenderVisibleElements, elementsSelectable, defaultViewport, translateExtent, minZoom, maxZoom, preventScrolling, defaultMarkerColor, zoomOnScroll, zoomOnPinch, panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, paneClickDistance, nodeClickDistance, onEdgeContextMenu, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, reconnectRadius, onReconnect, onReconnectStart, onReconnectEnd, noDragClassName, noWheelClassName, noPanClassName, disableKeyboardA11y, nodeExtent, rfId, viewport, onViewportChange }) {\n    useNodeOrEdgeTypesWarning(nodeTypes);\n    useNodeOrEdgeTypesWarning(edgeTypes);\n    useStylesLoadedWarning();\n    useOnInitHandler(onInit);\n    useViewportSync(viewport);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(FlowRenderer, {\n        onPaneClick: onPaneClick,\n        onPaneMouseEnter: onPaneMouseEnter,\n        onPaneMouseMove: onPaneMouseMove,\n        onPaneMouseLeave: onPaneMouseLeave,\n        onPaneContextMenu: onPaneContextMenu,\n        onPaneScroll: onPaneScroll,\n        paneClickDistance: paneClickDistance,\n        deleteKeyCode: deleteKeyCode,\n        selectionKeyCode: selectionKeyCode,\n        selectionOnDrag: selectionOnDrag,\n        selectionMode: selectionMode,\n        onSelectionStart: onSelectionStart,\n        onSelectionEnd: onSelectionEnd,\n        multiSelectionKeyCode: multiSelectionKeyCode,\n        panActivationKeyCode: panActivationKeyCode,\n        zoomActivationKeyCode: zoomActivationKeyCode,\n        elementsSelectable: elementsSelectable,\n        zoomOnScroll: zoomOnScroll,\n        zoomOnPinch: zoomOnPinch,\n        zoomOnDoubleClick: zoomOnDoubleClick,\n        panOnScroll: panOnScroll,\n        panOnScrollSpeed: panOnScrollSpeed,\n        panOnScrollMode: panOnScrollMode,\n        panOnDrag: panOnDrag,\n        defaultViewport: defaultViewport,\n        translateExtent: translateExtent,\n        minZoom: minZoom,\n        maxZoom: maxZoom,\n        onSelectionContextMenu: onSelectionContextMenu,\n        preventScrolling: preventScrolling,\n        noDragClassName: noDragClassName,\n        noWheelClassName: noWheelClassName,\n        noPanClassName: noPanClassName,\n        disableKeyboardA11y: disableKeyboardA11y,\n        onViewportChange: onViewportChange,\n        isControlledViewport: !!viewport,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Viewport, {\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeRenderer, {\n                    edgeTypes: edgeTypes,\n                    onEdgeClick: onEdgeClick,\n                    onEdgeDoubleClick: onEdgeDoubleClick,\n                    onReconnect: onReconnect,\n                    onReconnectStart: onReconnectStart,\n                    onReconnectEnd: onReconnectEnd,\n                    onlyRenderVisibleElements: onlyRenderVisibleElements,\n                    onEdgeContextMenu: onEdgeContextMenu,\n                    onEdgeMouseEnter: onEdgeMouseEnter,\n                    onEdgeMouseMove: onEdgeMouseMove,\n                    onEdgeMouseLeave: onEdgeMouseLeave,\n                    reconnectRadius: reconnectRadius,\n                    defaultMarkerColor: defaultMarkerColor,\n                    noPanClassName: noPanClassName,\n                    disableKeyboardA11y: disableKeyboardA11y,\n                    rfId: rfId\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ConnectionLineWrapper, {\n                    style: connectionLineStyle,\n                    type: connectionLineType,\n                    component: connectionLineComponent,\n                    containerStyle: connectionLineContainerStyle\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                    className: \"react-flow__edgelabel-renderer\"\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeRenderer, {\n                    nodeTypes: nodeTypes,\n                    onNodeClick: onNodeClick,\n                    onNodeDoubleClick: onNodeDoubleClick,\n                    onNodeMouseEnter: onNodeMouseEnter,\n                    onNodeMouseMove: onNodeMouseMove,\n                    onNodeMouseLeave: onNodeMouseLeave,\n                    onNodeContextMenu: onNodeContextMenu,\n                    nodeClickDistance: nodeClickDistance,\n                    onlyRenderVisibleElements: onlyRenderVisibleElements,\n                    noPanClassName: noPanClassName,\n                    noDragClassName: noDragClassName,\n                    disableKeyboardA11y: disableKeyboardA11y,\n                    nodeExtent: nodeExtent,\n                    rfId: rfId\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                    className: \"react-flow__viewport-portal\"\n                })\n            ]\n        })\n    });\n}\nGraphViewComponent.displayName = 'GraphView';\nconst GraphView = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(GraphViewComponent);\nconst getInitialState = ({ nodes, edges, defaultNodes, defaultEdges, width, height, fitView, fitViewOptions, minZoom = 0.5, maxZoom = 2, nodeOrigin, nodeExtent } = {})=>{\n    const nodeLookup = new Map();\n    const parentLookup = new Map();\n    const connectionLookup = new Map();\n    const edgeLookup = new Map();\n    const storeEdges = defaultEdges ?? edges ?? [];\n    const storeNodes = defaultNodes ?? nodes ?? [];\n    const storeNodeOrigin = nodeOrigin ?? [\n        0,\n        0\n    ];\n    const storeNodeExtent = nodeExtent ?? _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.infiniteExtent;\n    (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.updateConnectionLookup)(connectionLookup, edgeLookup, storeEdges);\n    const nodesInitialized = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.adoptUserNodes)(storeNodes, nodeLookup, parentLookup, {\n        nodeOrigin: storeNodeOrigin,\n        nodeExtent: storeNodeExtent,\n        elevateNodesOnSelect: false\n    });\n    let transform = [\n        0,\n        0,\n        1\n    ];\n    if (fitView && width && height) {\n        const bounds = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getInternalNodesBounds)(nodeLookup, {\n            filter: (node)=>!!((node.width || node.initialWidth) && (node.height || node.initialHeight))\n        });\n        const { x, y, zoom } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getViewportForBounds)(bounds, width, height, minZoom, maxZoom, fitViewOptions?.padding ?? 0.1);\n        transform = [\n            x,\n            y,\n            zoom\n        ];\n    }\n    return {\n        rfId: '1',\n        width: 0,\n        height: 0,\n        transform,\n        nodes: storeNodes,\n        nodesInitialized,\n        nodeLookup,\n        parentLookup,\n        edges: storeEdges,\n        edgeLookup,\n        connectionLookup,\n        onNodesChange: null,\n        onEdgesChange: null,\n        hasDefaultNodes: defaultNodes !== undefined,\n        hasDefaultEdges: defaultEdges !== undefined,\n        panZoom: null,\n        minZoom,\n        maxZoom,\n        translateExtent: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.infiniteExtent,\n        nodeExtent: storeNodeExtent,\n        nodesSelectionActive: false,\n        userSelectionActive: false,\n        userSelectionRect: null,\n        connectionMode: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionMode.Strict,\n        domNode: null,\n        paneDragging: false,\n        noPanClassName: 'nopan',\n        nodeOrigin: storeNodeOrigin,\n        nodeDragThreshold: 1,\n        snapGrid: [\n            15,\n            15\n        ],\n        snapToGrid: false,\n        nodesDraggable: true,\n        nodesConnectable: true,\n        nodesFocusable: true,\n        edgesFocusable: true,\n        edgesReconnectable: true,\n        elementsSelectable: true,\n        elevateNodesOnSelect: true,\n        elevateEdgesOnSelect: false,\n        selectNodesOnDrag: true,\n        multiSelectionActive: false,\n        fitViewQueued: fitView ?? false,\n        fitViewOptions,\n        fitViewResolver: null,\n        connection: {\n            ..._xyflow_system__WEBPACK_IMPORTED_MODULE_3__.initialConnection\n        },\n        connectionClickStartHandle: null,\n        connectOnClick: true,\n        ariaLiveMessage: '',\n        autoPanOnConnect: true,\n        autoPanOnNodeDrag: true,\n        autoPanOnNodeFocus: true,\n        autoPanSpeed: 15,\n        connectionRadius: 20,\n        onError: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.devWarn,\n        isValidConnection: undefined,\n        onSelectionChangeHandlers: [],\n        lib: 'react',\n        debug: false,\n        ariaLabelConfig: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.defaultAriaLabelConfig\n    };\n};\nconst createStore = ({ nodes, edges, defaultNodes, defaultEdges, width, height, fitView, fitViewOptions, minZoom, maxZoom, nodeOrigin, nodeExtent })=>(0,zustand_traditional__WEBPACK_IMPORTED_MODULE_5__.createWithEqualityFn)((set, get)=>{\n        async function resolveFitView() {\n            const { nodeLookup, panZoom, fitViewOptions, fitViewResolver, width, height, minZoom, maxZoom } = get();\n            if (!panZoom) {\n                return;\n            }\n            await (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.fitViewport)({\n                nodes: nodeLookup,\n                width,\n                height,\n                panZoom,\n                minZoom,\n                maxZoom\n            }, fitViewOptions);\n            fitViewResolver?.resolve(true);\n            /**\n         * wait for the fitViewport to resolve before deleting the resolver,\n         * we want to reuse the old resolver if the user calls fitView again in the mean time\n         */ set({\n                fitViewResolver: null\n            });\n        }\n        return {\n            ...getInitialState({\n                nodes,\n                edges,\n                width,\n                height,\n                fitView,\n                fitViewOptions,\n                minZoom,\n                maxZoom,\n                nodeOrigin,\n                nodeExtent,\n                defaultNodes,\n                defaultEdges\n            }),\n            setNodes: (nodes)=>{\n                const { nodeLookup, parentLookup, nodeOrigin, elevateNodesOnSelect, fitViewQueued } = get();\n                /*\n             * setNodes() is called exclusively in response to user actions:\n             * - either when the `<ReactFlow nodes>` prop is updated in the controlled ReactFlow setup,\n             * - or when the user calls something like `reactFlowInstance.setNodes()` in an uncontrolled ReactFlow setup.\n             *\n             * When this happens, we take the note objects passed by the user and extend them with fields\n             * relevant for internal React Flow operations.\n             */ const nodesInitialized = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.adoptUserNodes)(nodes, nodeLookup, parentLookup, {\n                    nodeOrigin,\n                    nodeExtent,\n                    elevateNodesOnSelect,\n                    checkEquality: true\n                });\n                if (fitViewQueued && nodesInitialized) {\n                    resolveFitView();\n                    set({\n                        nodes,\n                        nodesInitialized,\n                        fitViewQueued: false,\n                        fitViewOptions: undefined\n                    });\n                } else {\n                    set({\n                        nodes,\n                        nodesInitialized\n                    });\n                }\n            },\n            setEdges: (edges)=>{\n                const { connectionLookup, edgeLookup } = get();\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.updateConnectionLookup)(connectionLookup, edgeLookup, edges);\n                set({\n                    edges\n                });\n            },\n            setDefaultNodesAndEdges: (nodes, edges)=>{\n                if (nodes) {\n                    const { setNodes } = get();\n                    setNodes(nodes);\n                    set({\n                        hasDefaultNodes: true\n                    });\n                }\n                if (edges) {\n                    const { setEdges } = get();\n                    setEdges(edges);\n                    set({\n                        hasDefaultEdges: true\n                    });\n                }\n            },\n            /*\n         * Every node gets registerd at a ResizeObserver. Whenever a node\n         * changes its dimensions, this function is called to measure the\n         * new dimensions and update the nodes.\n         */ updateNodeInternals: (updates)=>{\n                const { triggerNodeChanges, nodeLookup, parentLookup, domNode, nodeOrigin, nodeExtent, debug, fitViewQueued } = get();\n                const { changes, updatedInternals } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.updateNodeInternals)(updates, nodeLookup, parentLookup, domNode, nodeOrigin, nodeExtent);\n                if (!updatedInternals) {\n                    return;\n                }\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.updateAbsolutePositions)(nodeLookup, parentLookup, {\n                    nodeOrigin,\n                    nodeExtent\n                });\n                if (fitViewQueued) {\n                    resolveFitView();\n                    set({\n                        fitViewQueued: false,\n                        fitViewOptions: undefined\n                    });\n                } else {\n                    // we always want to trigger useStore calls whenever updateNodeInternals is called\n                    set({});\n                }\n                if (changes?.length > 0) {\n                    if (debug) {\n                        console.log('React Flow: trigger node changes', changes);\n                    }\n                    triggerNodeChanges?.(changes);\n                }\n            },\n            updateNodePositions: (nodeDragItems, dragging = false)=>{\n                const parentExpandChildren = [];\n                const changes = [];\n                const { nodeLookup, triggerNodeChanges } = get();\n                for (const [id, dragItem] of nodeDragItems){\n                    // we are using the nodelookup to be sure to use the current expandParent and parentId value\n                    const node = nodeLookup.get(id);\n                    const expandParent = !!(node?.expandParent && node?.parentId && dragItem?.position);\n                    const change = {\n                        id,\n                        type: 'position',\n                        position: expandParent ? {\n                            x: Math.max(0, dragItem.position.x),\n                            y: Math.max(0, dragItem.position.y)\n                        } : dragItem.position,\n                        dragging\n                    };\n                    if (expandParent && node.parentId) {\n                        parentExpandChildren.push({\n                            id,\n                            parentId: node.parentId,\n                            rect: {\n                                ...dragItem.internals.positionAbsolute,\n                                width: dragItem.measured.width ?? 0,\n                                height: dragItem.measured.height ?? 0\n                            }\n                        });\n                    }\n                    changes.push(change);\n                }\n                if (parentExpandChildren.length > 0) {\n                    const { parentLookup, nodeOrigin } = get();\n                    const parentExpandChanges = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleExpandParent)(parentExpandChildren, nodeLookup, parentLookup, nodeOrigin);\n                    changes.push(...parentExpandChanges);\n                }\n                triggerNodeChanges(changes);\n            },\n            triggerNodeChanges: (changes)=>{\n                const { onNodesChange, setNodes, nodes, hasDefaultNodes, debug } = get();\n                if (changes?.length) {\n                    if (hasDefaultNodes) {\n                        const updatedNodes = applyNodeChanges(changes, nodes);\n                        setNodes(updatedNodes);\n                    }\n                    if (debug) {\n                        console.log('React Flow: trigger node changes', changes);\n                    }\n                    onNodesChange?.(changes);\n                }\n            },\n            triggerEdgeChanges: (changes)=>{\n                const { onEdgesChange, setEdges, edges, hasDefaultEdges, debug } = get();\n                if (changes?.length) {\n                    if (hasDefaultEdges) {\n                        const updatedEdges = applyEdgeChanges(changes, edges);\n                        setEdges(updatedEdges);\n                    }\n                    if (debug) {\n                        console.log('React Flow: trigger edge changes', changes);\n                    }\n                    onEdgesChange?.(changes);\n                }\n            },\n            addSelectedNodes: (selectedNodeIds)=>{\n                const { multiSelectionActive, edgeLookup, nodeLookup, triggerNodeChanges, triggerEdgeChanges } = get();\n                if (multiSelectionActive) {\n                    const nodeChanges = selectedNodeIds.map((nodeId)=>createSelectionChange(nodeId, true));\n                    triggerNodeChanges(nodeChanges);\n                    return;\n                }\n                triggerNodeChanges(getSelectionChanges(nodeLookup, new Set([\n                    ...selectedNodeIds\n                ]), true));\n                triggerEdgeChanges(getSelectionChanges(edgeLookup));\n            },\n            addSelectedEdges: (selectedEdgeIds)=>{\n                const { multiSelectionActive, edgeLookup, nodeLookup, triggerNodeChanges, triggerEdgeChanges } = get();\n                if (multiSelectionActive) {\n                    const changedEdges = selectedEdgeIds.map((edgeId)=>createSelectionChange(edgeId, true));\n                    triggerEdgeChanges(changedEdges);\n                    return;\n                }\n                triggerEdgeChanges(getSelectionChanges(edgeLookup, new Set([\n                    ...selectedEdgeIds\n                ])));\n                triggerNodeChanges(getSelectionChanges(nodeLookup, new Set(), true));\n            },\n            unselectNodesAndEdges: ({ nodes, edges } = {})=>{\n                const { edges: storeEdges, nodes: storeNodes, nodeLookup, triggerNodeChanges, triggerEdgeChanges } = get();\n                const nodesToUnselect = nodes ? nodes : storeNodes;\n                const edgesToUnselect = edges ? edges : storeEdges;\n                const nodeChanges = nodesToUnselect.map((n)=>{\n                    const internalNode = nodeLookup.get(n.id);\n                    if (internalNode) {\n                        /*\n                     * we need to unselect the internal node that was selected previously before we\n                     * send the change to the user to prevent it to be selected while dragging the new node\n                     */ internalNode.selected = false;\n                    }\n                    return createSelectionChange(n.id, false);\n                });\n                const edgeChanges = edgesToUnselect.map((edge)=>createSelectionChange(edge.id, false));\n                triggerNodeChanges(nodeChanges);\n                triggerEdgeChanges(edgeChanges);\n            },\n            setMinZoom: (minZoom)=>{\n                const { panZoom, maxZoom } = get();\n                panZoom?.setScaleExtent([\n                    minZoom,\n                    maxZoom\n                ]);\n                set({\n                    minZoom\n                });\n            },\n            setMaxZoom: (maxZoom)=>{\n                const { panZoom, minZoom } = get();\n                panZoom?.setScaleExtent([\n                    minZoom,\n                    maxZoom\n                ]);\n                set({\n                    maxZoom\n                });\n            },\n            setTranslateExtent: (translateExtent)=>{\n                get().panZoom?.setTranslateExtent(translateExtent);\n                set({\n                    translateExtent\n                });\n            },\n            setPaneClickDistance: (clickDistance)=>{\n                get().panZoom?.setClickDistance(clickDistance);\n            },\n            resetSelectedElements: ()=>{\n                const { edges, nodes, triggerNodeChanges, triggerEdgeChanges, elementsSelectable } = get();\n                if (!elementsSelectable) {\n                    return;\n                }\n                const nodeChanges = nodes.reduce((res, node)=>node.selected ? [\n                        ...res,\n                        createSelectionChange(node.id, false)\n                    ] : res, []);\n                const edgeChanges = edges.reduce((res, edge)=>edge.selected ? [\n                        ...res,\n                        createSelectionChange(edge.id, false)\n                    ] : res, []);\n                triggerNodeChanges(nodeChanges);\n                triggerEdgeChanges(edgeChanges);\n            },\n            setNodeExtent: (nextNodeExtent)=>{\n                const { nodes, nodeLookup, parentLookup, nodeOrigin, elevateNodesOnSelect, nodeExtent } = get();\n                if (nextNodeExtent[0][0] === nodeExtent[0][0] && nextNodeExtent[0][1] === nodeExtent[0][1] && nextNodeExtent[1][0] === nodeExtent[1][0] && nextNodeExtent[1][1] === nodeExtent[1][1]) {\n                    return;\n                }\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.adoptUserNodes)(nodes, nodeLookup, parentLookup, {\n                    nodeOrigin,\n                    nodeExtent: nextNodeExtent,\n                    elevateNodesOnSelect,\n                    checkEquality: false\n                });\n                set({\n                    nodeExtent: nextNodeExtent\n                });\n            },\n            panBy: (delta)=>{\n                const { transform, width, height, panZoom, translateExtent } = get();\n                return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.panBy)({\n                    delta,\n                    panZoom,\n                    transform,\n                    translateExtent,\n                    width,\n                    height\n                });\n            },\n            setCenter: async (x, y, options)=>{\n                const { width, height, maxZoom, panZoom } = get();\n                if (!panZoom) {\n                    return Promise.resolve(false);\n                }\n                const nextZoom = typeof options?.zoom !== 'undefined' ? options.zoom : maxZoom;\n                await panZoom.setViewport({\n                    x: width / 2 - x * nextZoom,\n                    y: height / 2 - y * nextZoom,\n                    zoom: nextZoom\n                }, {\n                    duration: options?.duration,\n                    ease: options?.ease,\n                    interpolate: options?.interpolate\n                });\n                return Promise.resolve(true);\n            },\n            cancelConnection: ()=>{\n                set({\n                    connection: {\n                        ..._xyflow_system__WEBPACK_IMPORTED_MODULE_3__.initialConnection\n                    }\n                });\n            },\n            updateConnection: (connection)=>{\n                set({\n                    connection\n                });\n            },\n            reset: ()=>set({\n                    ...getInitialState()\n                })\n        };\n    }, Object.is);\n/**\n * The `<ReactFlowProvider />` component is a [context provider](https://react.dev/learn/passing-data-deeply-with-context#)\n * that makes it possible to access a flow's internal state outside of the\n * [`<ReactFlow />`](/api-reference/react-flow) component. Many of the hooks we\n * provide rely on this component to work.\n * @public\n *\n * @example\n * ```tsx\n *import { ReactFlow, ReactFlowProvider, useNodes } from '@xyflow/react'\n *\n *export default function Flow() {\n *  return (\n *    <ReactFlowProvider>\n *      <ReactFlow nodes={...} edges={...} />\n *      <Sidebar />\n *    </ReactFlowProvider>\n *  );\n *}\n *\n *function Sidebar() {\n *  // This hook will only work if the component it's used in is a child of a\n *  // <ReactFlowProvider />.\n *  const nodes = useNodes()\n *\n *  return <aside>do something with nodes</aside>;\n *}\n *```\n *\n * @remarks If you're using a router and want your flow's state to persist across routes,\n * it's vital that you place the `<ReactFlowProvider />` component _outside_ of\n * your router. If you have multiple flows on the same page you will need to use a separate\n * `<ReactFlowProvider />` for each flow.\n */ function ReactFlowProvider({ initialNodes: nodes, initialEdges: edges, defaultNodes, defaultEdges, initialWidth: width, initialHeight: height, initialMinZoom: minZoom, initialMaxZoom: maxZoom, initialFitViewOptions: fitViewOptions, fitView, nodeOrigin, nodeExtent, children }) {\n    const [store] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        \"ReactFlowProvider.useState\": ()=>createStore({\n                nodes,\n                edges,\n                defaultNodes,\n                defaultEdges,\n                width,\n                height,\n                fitView,\n                minZoom,\n                maxZoom,\n                fitViewOptions,\n                nodeOrigin,\n                nodeExtent\n            })\n    }[\"ReactFlowProvider.useState\"]);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Provider$1, {\n        value: store,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BatchProvider, {\n            children: children\n        })\n    });\n}\nfunction Wrapper({ children, nodes, edges, defaultNodes, defaultEdges, width, height, fitView, fitViewOptions, minZoom, maxZoom, nodeOrigin, nodeExtent }) {\n    const isWrapped = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(StoreContext);\n    if (isWrapped) {\n        /*\n         * we need to wrap it with a fragment because it's not allowed for children to be a ReactNode\n         * https://github.com/DefinitelyTyped/DefinitelyTyped/issues/18051\n         */ return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n            children: children\n        });\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ReactFlowProvider, {\n        initialNodes: nodes,\n        initialEdges: edges,\n        defaultNodes: defaultNodes,\n        defaultEdges: defaultEdges,\n        initialWidth: width,\n        initialHeight: height,\n        fitView: fitView,\n        initialFitViewOptions: fitViewOptions,\n        initialMinZoom: minZoom,\n        initialMaxZoom: maxZoom,\n        nodeOrigin: nodeOrigin,\n        nodeExtent: nodeExtent,\n        children: children\n    });\n}\nconst wrapperStyle = {\n    width: '100%',\n    height: '100%',\n    overflow: 'hidden',\n    position: 'relative',\n    zIndex: 0\n};\nfunction ReactFlow({ nodes, edges, defaultNodes, defaultEdges, className, nodeTypes, edgeTypes, onNodeClick, onEdgeClick, onInit, onMove, onMoveStart, onMoveEnd, onConnect, onConnectStart, onConnectEnd, onClickConnectStart, onClickConnectEnd, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, onNodeDoubleClick, onNodeDragStart, onNodeDrag, onNodeDragStop, onNodesDelete, onEdgesDelete, onDelete, onSelectionChange, onSelectionDragStart, onSelectionDrag, onSelectionDragStop, onSelectionContextMenu, onSelectionStart, onSelectionEnd, onBeforeDelete, connectionMode, connectionLineType = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.Bezier, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, deleteKeyCode = 'Backspace', selectionKeyCode = 'Shift', selectionOnDrag = false, selectionMode = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.SelectionMode.Full, panActivationKeyCode = 'Space', multiSelectionKeyCode = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isMacOs)() ? 'Meta' : 'Control', zoomActivationKeyCode = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isMacOs)() ? 'Meta' : 'Control', snapToGrid, snapGrid, onlyRenderVisibleElements = false, selectNodesOnDrag, nodesDraggable, autoPanOnNodeFocus, nodesConnectable, nodesFocusable, nodeOrigin = defaultNodeOrigin, edgesFocusable, edgesReconnectable, elementsSelectable = true, defaultViewport: defaultViewport$1 = defaultViewport, minZoom = 0.5, maxZoom = 2, translateExtent = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.infiniteExtent, preventScrolling = true, nodeExtent, defaultMarkerColor = '#b1b1b7', zoomOnScroll = true, zoomOnPinch = true, panOnScroll = false, panOnScrollSpeed = 0.5, panOnScrollMode = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.PanOnScrollMode.Free, zoomOnDoubleClick = true, panOnDrag = true, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, paneClickDistance = 0, nodeClickDistance = 0, children, onReconnect, onReconnectStart, onReconnectEnd, onEdgeContextMenu, onEdgeDoubleClick, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, reconnectRadius = 10, onNodesChange, onEdgesChange, noDragClassName = 'nodrag', noWheelClassName = 'nowheel', noPanClassName = 'nopan', fitView, fitViewOptions, connectOnClick, attributionPosition, proOptions, defaultEdgeOptions, elevateNodesOnSelect, elevateEdgesOnSelect, disableKeyboardA11y = false, autoPanOnConnect, autoPanOnNodeDrag, autoPanSpeed, connectionRadius, isValidConnection, onError, style, id, nodeDragThreshold, viewport, onViewportChange, width, height, colorMode = 'light', debug, onScroll, ariaLabelConfig, ...rest }, ref) {\n    const rfId = id || '1';\n    const colorModeClassName = useColorModeClass(colorMode);\n    // Undo scroll events, preventing viewport from shifting when nodes outside of it are focused\n    const wrapperOnScroll = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ReactFlow.useCallback[wrapperOnScroll]\": (e)=>{\n            e.currentTarget.scrollTo({\n                top: 0,\n                left: 0,\n                behavior: 'instant'\n            });\n            onScroll?.(e);\n        }\n    }[\"ReactFlow.useCallback[wrapperOnScroll]\"], [\n        onScroll\n    ]);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        \"data-testid\": \"rf__wrapper\",\n        ...rest,\n        onScroll: wrapperOnScroll,\n        style: {\n            ...style,\n            ...wrapperStyle\n        },\n        ref: ref,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow',\n            className,\n            colorModeClassName\n        ]),\n        id: id,\n        role: \"application\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Wrapper, {\n            nodes: nodes,\n            edges: edges,\n            width: width,\n            height: height,\n            fitView: fitView,\n            fitViewOptions: fitViewOptions,\n            minZoom: minZoom,\n            maxZoom: maxZoom,\n            nodeOrigin: nodeOrigin,\n            nodeExtent: nodeExtent,\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(GraphView, {\n                    onInit: onInit,\n                    onNodeClick: onNodeClick,\n                    onEdgeClick: onEdgeClick,\n                    onNodeMouseEnter: onNodeMouseEnter,\n                    onNodeMouseMove: onNodeMouseMove,\n                    onNodeMouseLeave: onNodeMouseLeave,\n                    onNodeContextMenu: onNodeContextMenu,\n                    onNodeDoubleClick: onNodeDoubleClick,\n                    nodeTypes: nodeTypes,\n                    edgeTypes: edgeTypes,\n                    connectionLineType: connectionLineType,\n                    connectionLineStyle: connectionLineStyle,\n                    connectionLineComponent: connectionLineComponent,\n                    connectionLineContainerStyle: connectionLineContainerStyle,\n                    selectionKeyCode: selectionKeyCode,\n                    selectionOnDrag: selectionOnDrag,\n                    selectionMode: selectionMode,\n                    deleteKeyCode: deleteKeyCode,\n                    multiSelectionKeyCode: multiSelectionKeyCode,\n                    panActivationKeyCode: panActivationKeyCode,\n                    zoomActivationKeyCode: zoomActivationKeyCode,\n                    onlyRenderVisibleElements: onlyRenderVisibleElements,\n                    defaultViewport: defaultViewport$1,\n                    translateExtent: translateExtent,\n                    minZoom: minZoom,\n                    maxZoom: maxZoom,\n                    preventScrolling: preventScrolling,\n                    zoomOnScroll: zoomOnScroll,\n                    zoomOnPinch: zoomOnPinch,\n                    zoomOnDoubleClick: zoomOnDoubleClick,\n                    panOnScroll: panOnScroll,\n                    panOnScrollSpeed: panOnScrollSpeed,\n                    panOnScrollMode: panOnScrollMode,\n                    panOnDrag: panOnDrag,\n                    onPaneClick: onPaneClick,\n                    onPaneMouseEnter: onPaneMouseEnter,\n                    onPaneMouseMove: onPaneMouseMove,\n                    onPaneMouseLeave: onPaneMouseLeave,\n                    onPaneScroll: onPaneScroll,\n                    onPaneContextMenu: onPaneContextMenu,\n                    paneClickDistance: paneClickDistance,\n                    nodeClickDistance: nodeClickDistance,\n                    onSelectionContextMenu: onSelectionContextMenu,\n                    onSelectionStart: onSelectionStart,\n                    onSelectionEnd: onSelectionEnd,\n                    onReconnect: onReconnect,\n                    onReconnectStart: onReconnectStart,\n                    onReconnectEnd: onReconnectEnd,\n                    onEdgeContextMenu: onEdgeContextMenu,\n                    onEdgeDoubleClick: onEdgeDoubleClick,\n                    onEdgeMouseEnter: onEdgeMouseEnter,\n                    onEdgeMouseMove: onEdgeMouseMove,\n                    onEdgeMouseLeave: onEdgeMouseLeave,\n                    reconnectRadius: reconnectRadius,\n                    defaultMarkerColor: defaultMarkerColor,\n                    noDragClassName: noDragClassName,\n                    noWheelClassName: noWheelClassName,\n                    noPanClassName: noPanClassName,\n                    rfId: rfId,\n                    disableKeyboardA11y: disableKeyboardA11y,\n                    nodeExtent: nodeExtent,\n                    viewport: viewport,\n                    onViewportChange: onViewportChange\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(StoreUpdater, {\n                    nodes: nodes,\n                    edges: edges,\n                    defaultNodes: defaultNodes,\n                    defaultEdges: defaultEdges,\n                    onConnect: onConnect,\n                    onConnectStart: onConnectStart,\n                    onConnectEnd: onConnectEnd,\n                    onClickConnectStart: onClickConnectStart,\n                    onClickConnectEnd: onClickConnectEnd,\n                    nodesDraggable: nodesDraggable,\n                    autoPanOnNodeFocus: autoPanOnNodeFocus,\n                    nodesConnectable: nodesConnectable,\n                    nodesFocusable: nodesFocusable,\n                    edgesFocusable: edgesFocusable,\n                    edgesReconnectable: edgesReconnectable,\n                    elementsSelectable: elementsSelectable,\n                    elevateNodesOnSelect: elevateNodesOnSelect,\n                    elevateEdgesOnSelect: elevateEdgesOnSelect,\n                    minZoom: minZoom,\n                    maxZoom: maxZoom,\n                    nodeExtent: nodeExtent,\n                    onNodesChange: onNodesChange,\n                    onEdgesChange: onEdgesChange,\n                    snapToGrid: snapToGrid,\n                    snapGrid: snapGrid,\n                    connectionMode: connectionMode,\n                    translateExtent: translateExtent,\n                    connectOnClick: connectOnClick,\n                    defaultEdgeOptions: defaultEdgeOptions,\n                    fitView: fitView,\n                    fitViewOptions: fitViewOptions,\n                    onNodesDelete: onNodesDelete,\n                    onEdgesDelete: onEdgesDelete,\n                    onDelete: onDelete,\n                    onNodeDragStart: onNodeDragStart,\n                    onNodeDrag: onNodeDrag,\n                    onNodeDragStop: onNodeDragStop,\n                    onSelectionDrag: onSelectionDrag,\n                    onSelectionDragStart: onSelectionDragStart,\n                    onSelectionDragStop: onSelectionDragStop,\n                    onMove: onMove,\n                    onMoveStart: onMoveStart,\n                    onMoveEnd: onMoveEnd,\n                    noPanClassName: noPanClassName,\n                    nodeOrigin: nodeOrigin,\n                    rfId: rfId,\n                    autoPanOnConnect: autoPanOnConnect,\n                    autoPanOnNodeDrag: autoPanOnNodeDrag,\n                    autoPanSpeed: autoPanSpeed,\n                    onError: onError,\n                    connectionRadius: connectionRadius,\n                    isValidConnection: isValidConnection,\n                    selectNodesOnDrag: selectNodesOnDrag,\n                    nodeDragThreshold: nodeDragThreshold,\n                    onBeforeDelete: onBeforeDelete,\n                    paneClickDistance: paneClickDistance,\n                    debug: debug,\n                    ariaLabelConfig: ariaLabelConfig\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SelectionListener, {\n                    onSelectionChange: onSelectionChange\n                }),\n                children,\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Attribution, {\n                    proOptions: proOptions,\n                    position: attributionPosition\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(A11yDescriptions, {\n                    rfId: rfId,\n                    disableKeyboardA11y: disableKeyboardA11y\n                })\n            ]\n        })\n    });\n}\n/**\n * The `<ReactFlow />` component is the heart of your React Flow application.\n * It renders your nodes and edges and handles user interaction\n *\n * @public\n *\n * @example\n * ```tsx\n *import { ReactFlow } from '@xyflow/react'\n *\n *export default function Flow() {\n *  return (<ReactFlow\n *    nodes={...}\n *    edges={...}\n *    onNodesChange={...}\n *    ...\n *  />);\n *}\n *```\n */ var index = fixedForwardRef(ReactFlow);\nconst selector$6 = (s)=>s.domNode?.querySelector('.react-flow__edgelabel-renderer');\n/**\n * Edges are SVG-based. If you want to render more complex labels you can use the\n * `<EdgeLabelRenderer />` component to access a div based renderer. This component\n * is a portal that renders the label in a `<div />` that is positioned on top of\n * the edges. You can see an example usage of the component in the\n * [edge label renderer example](/examples/edges/edge-label-renderer).\n * @public\n *\n * @example\n * ```jsx\n * import React from 'react';\n * import { getBezierPath, EdgeLabelRenderer, BaseEdge } from '@xyflow/react';\n *\n * export function CustomEdge({ id, data, ...props }) {\n *   const [edgePath, labelX, labelY] = getBezierPath(props);\n *\n *   return (\n *     <>\n *       <BaseEdge id={id} path={edgePath} />\n *       <EdgeLabelRenderer>\n *         <div\n *           style={{\n *             position: 'absolute',\n *             transform: `translate(-50%, -50%) translate(${labelX}px,${labelY}px)`,\n *             background: '#ffcc00',\n *             padding: 10,\n *         }}\n *           className=\"nodrag nopan\"\n *         >\n *          {data.label}\n *         </div>\n *       </EdgeLabelRenderer>\n *     </>\n *   );\n * };\n * ```\n *\n * @remarks The `<EdgeLabelRenderer />` has no pointer events by default. If you want to\n * add mouse interactions you need to set the style `pointerEvents: all` and add\n * the `nopan` class on the label or the element you want to interact with.\n */ function EdgeLabelRenderer({ children }) {\n    const edgeLabelRenderer = useStore(selector$6);\n    if (!edgeLabelRenderer) {\n        return null;\n    }\n    return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_4__.createPortal)(children, edgeLabelRenderer);\n}\nconst selector$5 = (s)=>s.domNode?.querySelector('.react-flow__viewport-portal');\n/**\n * The `<ViewportPortal />` component can be used to add components to the same viewport\n * of the flow where nodes and edges are rendered. This is useful when you want to render\n * your own components that are adhere to the same coordinate system as the nodes & edges\n * and are also affected by zooming and panning\n * @public\n * @example\n *\n * ```jsx\n *import React from 'react';\n *import { ViewportPortal } from '@xyflow/react';\n *\n *export default function () {\n *  return (\n *    <ViewportPortal>\n *      <div\n *        style={{ transform: 'translate(100px, 100px)', position: 'absolute' }}\n *      >\n *        This div is positioned at [100, 100] on the flow.\n *      </div>\n *    </ViewportPortal>\n *  );\n *}\n *```\n */ function ViewportPortal({ children }) {\n    const viewPortalDiv = useStore(selector$5);\n    if (!viewPortalDiv) {\n        return null;\n    }\n    return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_4__.createPortal)(children, viewPortalDiv);\n}\n/**\n * When you programmatically add or remove handles to a node or update a node's\n * handle position, you need to let React Flow know about it using this hook. This\n * will update the internal dimensions of the node and properly reposition handles\n * on the canvas if necessary.\n *\n * @public\n * @returns Use this function to tell React Flow to update the internal state of one or more nodes\n * that you have changed programmatically.\n *\n * @example\n * ```jsx\n *import { useCallback, useState } from 'react';\n *import { Handle, useUpdateNodeInternals } from '@xyflow/react';\n *\n *export default function RandomHandleNode({ id }) {\n *  const updateNodeInternals = useUpdateNodeInternals();\n *  const [handleCount, setHandleCount] = useState(0);\n *  const randomizeHandleCount = useCallback(() => {\n *   setHandleCount(Math.floor(Math.random() * 10));\n *    updateNodeInternals(id);\n *  }, [id, updateNodeInternals]);\n *\n *  return (\n *    <>\n *      {Array.from({ length: handleCount }).map((_, index) => (\n *        <Handle\n *          key={index}\n *          type=\"target\"\n *          position=\"left\"\n *          id={`handle-${index}`}\n *        />\n *      ))}\n *\n *      <div>\n *        <button onClick={randomizeHandleCount}>Randomize handle count</button>\n *        <p>There are {handleCount} handles on this node.</p>\n *      </div>\n *    </>\n *  );\n *}\n *```\n * @remarks This hook can only be used in a component that is a child of a\n *{@link ReactFlowProvider} or a {@link ReactFlow} component.\n */ function useUpdateNodeInternals() {\n    const store = useStoreApi();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"useUpdateNodeInternals.useCallback\": (id)=>{\n            const { domNode, updateNodeInternals } = store.getState();\n            const updateIds = Array.isArray(id) ? id : [\n                id\n            ];\n            const updates = new Map();\n            updateIds.forEach({\n                \"useUpdateNodeInternals.useCallback\": (updateId)=>{\n                    const nodeElement = domNode?.querySelector(`.react-flow__node[data-id=\"${updateId}\"]`);\n                    if (nodeElement) {\n                        updates.set(updateId, {\n                            id: updateId,\n                            nodeElement,\n                            force: true\n                        });\n                    }\n                }\n            }[\"useUpdateNodeInternals.useCallback\"]);\n            requestAnimationFrame({\n                \"useUpdateNodeInternals.useCallback\": ()=>updateNodeInternals(updates, {\n                        triggerFitView: false\n                    })\n            }[\"useUpdateNodeInternals.useCallback\"]);\n        }\n    }[\"useUpdateNodeInternals.useCallback\"], []);\n}\nconst nodesSelector = (state)=>state.nodes;\n/**\n * This hook returns an array of the current nodes. Components that use this hook\n * will re-render **whenever any node changes**, including when a node is selected\n * or moved.\n *\n * @public\n * @returns An array of all nodes currently in the flow.\n *\n * @example\n * ```jsx\n *import { useNodes } from '@xyflow/react';\n *\n *export default function() {\n *  const nodes = useNodes();\n *\n *  return <div>There are currently {nodes.length} nodes!</div>;\n *}\n *```\n */ function useNodes() {\n    const nodes = useStore(nodesSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return nodes;\n}\nconst edgesSelector = (state)=>state.edges;\n/**\n * This hook returns an array of the current edges. Components that use this hook\n * will re-render **whenever any edge changes**.\n *\n * @public\n * @returns An array of all edges currently in the flow.\n *\n * @example\n * ```tsx\n *import { useEdges } from '@xyflow/react';\n *\n *export default function () {\n *  const edges = useEdges();\n *\n *  return <div>There are currently {edges.length} edges!</div>;\n *}\n *```\n */ function useEdges() {\n    const edges = useStore(edgesSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return edges;\n}\nconst viewportSelector = (state)=>({\n        x: state.transform[0],\n        y: state.transform[1],\n        zoom: state.transform[2]\n    });\n/**\n * The `useViewport` hook is a convenient way to read the current state of the\n * {@link Viewport} in a component. Components that use this hook\n * will re-render **whenever the viewport changes**.\n *\n * @public\n * @returns The current viewport.\n *\n * @example\n *\n *```jsx\n *import { useViewport } from '@xyflow/react';\n *\n *export default function ViewportDisplay() {\n *  const { x, y, zoom } = useViewport();\n *\n *  return (\n *    <div>\n *      <p>\n *        The viewport is currently at ({x}, {y}) and zoomed to {zoom}.\n *      </p>\n *    </div>\n *  );\n *}\n *```\n *\n * @remarks This hook can only be used in a component that is a child of a\n *{@link ReactFlowProvider} or a {@link ReactFlow} component.\n */ function useViewport() {\n    const viewport = useStore(viewportSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return viewport;\n}\n/**\n * This hook makes it easy to prototype a controlled flow where you manage the\n * state of nodes and edges outside the `ReactFlowInstance`. You can think of it\n * like React's `useState` hook with an additional helper callback.\n *\n * @public\n * @returns\n * - `nodes`: The current array of nodes. You might pass this directly to the `nodes` prop of your\n * `<ReactFlow />` component, or you may want to manipulate it first to perform some layouting,\n * for example.\n * - `setNodes`: A function that you can use to update the nodes. You can pass it a new array of\n * nodes or a callback that receives the current array of nodes and returns a new array of nodes.\n * This is the same as the second element of the tuple returned by React's `useState` hook.\n * - `onNodesChange`: A handy callback that can take an array of `NodeChanges` and update the nodes\n * state accordingly. You'll typically pass this directly to the `onNodesChange` prop of your\n * `<ReactFlow />` component.\n * @example\n *\n *```tsx\n *import { ReactFlow, useNodesState, useEdgesState } from '@xyflow/react';\n *\n *const initialNodes = [];\n *const initialEdges = [];\n *\n *export default function () {\n *  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);\n *  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);\n *\n *  return (\n *    <ReactFlow\n *      nodes={nodes}\n *      edges={edges}\n *      onNodesChange={onNodesChange}\n *      onEdgesChange={onEdgesChange}\n *    />\n *  );\n *}\n *```\n *\n * @remarks This hook was created to make prototyping easier and our documentation\n * examples clearer. Although it is OK to use this hook in production, in\n * practice you may want to use a more sophisticated state management solution\n * like Zustand {@link https://reactflow.dev/docs/guides/state-management/} instead.\n *\n */ function useNodesState(initialNodes) {\n    const [nodes, setNodes] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(initialNodes);\n    const onNodesChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"useNodesState.useCallback[onNodesChange]\": (changes)=>setNodes({\n                \"useNodesState.useCallback[onNodesChange]\": (nds)=>applyNodeChanges(changes, nds)\n            }[\"useNodesState.useCallback[onNodesChange]\"])\n    }[\"useNodesState.useCallback[onNodesChange]\"], []);\n    return [\n        nodes,\n        setNodes,\n        onNodesChange\n    ];\n}\n/**\n * This hook makes it easy to prototype a controlled flow where you manage the\n * state of nodes and edges outside the `ReactFlowInstance`. You can think of it\n * like React's `useState` hook with an additional helper callback.\n *\n * @public\n * @returns\n * - `edges`: The current array of edges. You might pass this directly to the `edges` prop of your\n * `<ReactFlow />` component, or you may want to manipulate it first to perform some layouting,\n * for example.\n *\n * - `setEdges`: A function that you can use to update the edges. You can pass it a new array of\n * edges or a callback that receives the current array of edges and returns a new array of edges.\n * This is the same as the second element of the tuple returned by React's `useState` hook.\n *\n * - `onEdgesChange`: A handy callback that can take an array of `EdgeChanges` and update the edges\n * state accordingly. You'll typically pass this directly to the `onEdgesChange` prop of your\n * `<ReactFlow />` component.\n * @example\n *\n *```tsx\n *import { ReactFlow, useNodesState, useEdgesState } from '@xyflow/react';\n *\n *const initialNodes = [];\n *const initialEdges = [];\n *\n *export default function () {\n *  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);\n *  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);\n *\n *  return (\n *    <ReactFlow\n *      nodes={nodes}\n *      edges={edges}\n *      onNodesChange={onNodesChange}\n *      onEdgesChange={onEdgesChange}\n *    />\n *  );\n *}\n *```\n *\n * @remarks This hook was created to make prototyping easier and our documentation\n * examples clearer. Although it is OK to use this hook in production, in\n * practice you may want to use a more sophisticated state management solution\n * like Zustand {@link https://reactflow.dev/docs/guides/state-management/} instead.\n *\n */ function useEdgesState(initialEdges) {\n    const [edges, setEdges] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(initialEdges);\n    const onEdgesChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"useEdgesState.useCallback[onEdgesChange]\": (changes)=>setEdges({\n                \"useEdgesState.useCallback[onEdgesChange]\": (eds)=>applyEdgeChanges(changes, eds)\n            }[\"useEdgesState.useCallback[onEdgesChange]\"])\n    }[\"useEdgesState.useCallback[onEdgesChange]\"], []);\n    return [\n        edges,\n        setEdges,\n        onEdgesChange\n    ];\n}\n/**\n * The `useOnViewportChange` hook lets you listen for changes to the viewport such\n * as panning and zooming. You can provide a callback for each phase of a viewport\n * change: `onStart`, `onChange`, and `onEnd`.\n *\n * @public\n * @example\n * ```jsx\n *import { useCallback } from 'react';\n *import { useOnViewportChange } from '@xyflow/react';\n *\n *function ViewportChangeLogger() {\n *  useOnViewportChange({\n *    onStart: (viewport: Viewport) => console.log('start', viewport),\n *    onChange: (viewport: Viewport) => console.log('change', viewport),\n *    onEnd: (viewport: Viewport) => console.log('end', viewport),\n *  });\n *\n *  return null;\n *}\n *```\n */ function useOnViewportChange({ onStart, onChange, onEnd }) {\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useOnViewportChange.useEffect\": ()=>{\n            store.setState({\n                onViewportChangeStart: onStart\n            });\n        }\n    }[\"useOnViewportChange.useEffect\"], [\n        onStart\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useOnViewportChange.useEffect\": ()=>{\n            store.setState({\n                onViewportChange: onChange\n            });\n        }\n    }[\"useOnViewportChange.useEffect\"], [\n        onChange\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useOnViewportChange.useEffect\": ()=>{\n            store.setState({\n                onViewportChangeEnd: onEnd\n            });\n        }\n    }[\"useOnViewportChange.useEffect\"], [\n        onEnd\n    ]);\n}\n/**\n * This hook lets you listen for changes to both node and edge selection. As the\n *name implies, the callback you provide will be called whenever the selection of\n *_either_ nodes or edges changes.\n *\n * @public\n * @example\n * ```jsx\n *import { useState } from 'react';\n *import { ReactFlow, useOnSelectionChange } from '@xyflow/react';\n *\n *function SelectionDisplay() {\n *  const [selectedNodes, setSelectedNodes] = useState([]);\n *  const [selectedEdges, setSelectedEdges] = useState([]);\n *\n *  // the passed handler has to be memoized, otherwise the hook will not work correctly\n *  const onChange = useCallback(({ nodes, edges }) => {\n *    setSelectedNodes(nodes.map((node) => node.id));\n *    setSelectedEdges(edges.map((edge) => edge.id));\n *  }, []);\n *\n *  useOnSelectionChange({\n *    onChange,\n *  });\n *\n *  return (\n *    <div>\n *      <p>Selected nodes: {selectedNodes.join(', ')}</p>\n *      <p>Selected edges: {selectedEdges.join(', ')}</p>\n *    </div>\n *  );\n *}\n *```\n *\n * @remarks You need to memoize the passed `onChange` handler, otherwise the hook will not work correctly.\n */ function useOnSelectionChange({ onChange }) {\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useOnSelectionChange.useEffect\": ()=>{\n            const nextOnSelectionChangeHandlers = [\n                ...store.getState().onSelectionChangeHandlers,\n                onChange\n            ];\n            store.setState({\n                onSelectionChangeHandlers: nextOnSelectionChangeHandlers\n            });\n            return ({\n                \"useOnSelectionChange.useEffect\": ()=>{\n                    const nextHandlers = store.getState().onSelectionChangeHandlers.filter({\n                        \"useOnSelectionChange.useEffect.nextHandlers\": (fn)=>fn !== onChange\n                    }[\"useOnSelectionChange.useEffect.nextHandlers\"]);\n                    store.setState({\n                        onSelectionChangeHandlers: nextHandlers\n                    });\n                }\n            })[\"useOnSelectionChange.useEffect\"];\n        }\n    }[\"useOnSelectionChange.useEffect\"], [\n        onChange\n    ]);\n}\nconst selector$4 = (options)=>(s)=>{\n        if (!options.includeHiddenNodes) {\n            return s.nodesInitialized;\n        }\n        if (s.nodeLookup.size === 0) {\n            return false;\n        }\n        for (const [, { internals }] of s.nodeLookup){\n            if (internals.handleBounds === undefined || !(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.nodeHasDimensions)(internals.userNode)) {\n                return false;\n            }\n        }\n        return true;\n    };\n/**\n * This hook tells you whether all the nodes in a flow have been measured and given\n *a width and height. When you add a node to the flow, this hook will return\n *`false` and then `true` again once the node has been measured.\n *\n * @public\n * @returns Whether or not the nodes have been initialized by the `<ReactFlow />` component and\n * given a width and height.\n *\n * @example\n * ```jsx\n *import { useReactFlow, useNodesInitialized } from '@xyflow/react';\n *import { useEffect, useState } from 'react';\n *\n *const options = {\n *  includeHiddenNodes: false,\n *};\n *\n *export default function useLayout() {\n *  const { getNodes } = useReactFlow();\n *  const nodesInitialized = useNodesInitialized(options);\n *  const [layoutedNodes, setLayoutedNodes] = useState(getNodes());\n *\n *  useEffect(() => {\n *    if (nodesInitialized) {\n *      setLayoutedNodes(yourLayoutingFunction(getNodes()));\n *    }\n *  }, [nodesInitialized]);\n *\n *  return layoutedNodes;\n *}\n *```\n */ function useNodesInitialized(options = {\n    includeHiddenNodes: false\n}) {\n    const initialized = useStore(selector$4(options));\n    return initialized;\n}\n/**\n * Hook to check if a <Handle /> is connected to another <Handle /> and get the connections.\n *\n * @public\n * @deprecated Use `useNodeConnections` instead.\n * @returns An array with handle connections.\n */ function useHandleConnections({ type, id, nodeId, onConnect, onDisconnect }) {\n    console.warn('[DEPRECATED] `useHandleConnections` is deprecated. Instead use `useNodeConnections` https://reactflow.dev/api-reference/hooks/useNodeConnections');\n    const _nodeId = useNodeId();\n    const currentNodeId = nodeId ?? _nodeId;\n    const prevConnections = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const connections = useStore({\n        \"useHandleConnections.useStore[connections]\": (state)=>state.connectionLookup.get(`${currentNodeId}-${type}${id ? `-${id}` : ''}`)\n    }[\"useHandleConnections.useStore[connections]\"], _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.areConnectionMapsEqual);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useHandleConnections.useEffect\": ()=>{\n            // @todo dicuss if onConnect/onDisconnect should be called when the component mounts/unmounts\n            if (prevConnections.current && prevConnections.current !== connections) {\n                const _connections = connections ?? new Map();\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleConnectionChange)(prevConnections.current, _connections, onDisconnect);\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleConnectionChange)(_connections, prevConnections.current, onConnect);\n            }\n            prevConnections.current = connections ?? new Map();\n        }\n    }[\"useHandleConnections.useEffect\"], [\n        connections,\n        onConnect,\n        onDisconnect\n    ]);\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"useHandleConnections.useMemo\": ()=>Array.from(connections?.values() ?? [])\n    }[\"useHandleConnections.useMemo\"], [\n        connections\n    ]);\n}\nconst error014 = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error014']();\n/**\n * This hook returns an array of connections on a specific node, handle type ('source', 'target') or handle ID.\n *\n * @public\n * @returns An array with connections.\n *\n * @example\n * ```jsx\n *import { useNodeConnections } from '@xyflow/react';\n *\n *export default function () {\n *  const connections = useNodeConnections({\n *    handleType: 'target',\n *    handleId: 'my-handle',\n *  });\n *\n *  return (\n *    <div>There are currently {connections.length} incoming connections!</div>\n *  );\n *}\n *```\n */ function useNodeConnections({ id, handleType, handleId, onConnect, onDisconnect } = {}) {\n    const nodeId = useNodeId();\n    const currentNodeId = id ?? nodeId;\n    if (!currentNodeId) {\n        throw new Error(error014);\n    }\n    const prevConnections = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const connections = useStore({\n        \"useNodeConnections.useStore[connections]\": (state)=>state.connectionLookup.get(`${currentNodeId}${handleType ? handleId ? `-${handleType}-${handleId}` : `-${handleType}` : ''}`)\n    }[\"useNodeConnections.useStore[connections]\"], _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.areConnectionMapsEqual);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useNodeConnections.useEffect\": ()=>{\n            // @todo discuss if onConnect/onDisconnect should be called when the component mounts/unmounts\n            if (prevConnections.current && prevConnections.current !== connections) {\n                const _connections = connections ?? new Map();\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleConnectionChange)(prevConnections.current, _connections, onDisconnect);\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleConnectionChange)(_connections, prevConnections.current, onConnect);\n            }\n            prevConnections.current = connections ?? new Map();\n        }\n    }[\"useNodeConnections.useEffect\"], [\n        connections,\n        onConnect,\n        onDisconnect\n    ]);\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"useNodeConnections.useMemo\": ()=>Array.from(connections?.values() ?? [])\n    }[\"useNodeConnections.useMemo\"], [\n        connections\n    ]);\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction useNodesData(nodeIds) {\n    const nodesData = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"useNodesData.useStore[nodesData]\": (s)=>{\n            const data = [];\n            const isArrayOfIds = Array.isArray(nodeIds);\n            const _nodeIds = isArrayOfIds ? nodeIds : [\n                nodeIds\n            ];\n            for (const nodeId of _nodeIds){\n                const node = s.nodeLookup.get(nodeId);\n                if (node) {\n                    data.push({\n                        id: node.id,\n                        type: node.type,\n                        data: node.data\n                    });\n                }\n            }\n            return isArrayOfIds ? data : data[0] ?? null;\n        }\n    }[\"useNodesData.useStore[nodesData]\"], [\n        nodeIds\n    ]), _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.shallowNodeData);\n    return nodesData;\n}\n/**\n * This hook returns the internal representation of a specific node.\n * Components that use this hook will re-render **whenever the node changes**,\n * including when a node is selected or moved.\n *\n * @public\n * @param id - The ID of a node you want to observe.\n * @returns The `InternalNode` object for the node with the given ID.\n *\n * @example\n * ```tsx\n *import { useInternalNode } from '@xyflow/react';\n *\n *export default function () {\n *  const internalNode = useInternalNode('node-1');\n *  const absolutePosition = internalNode.internals.positionAbsolute;\n *\n *  return (\n *    <div>\n *      The absolute position of the node is at:\n *      <p>x: {absolutePosition.x}</p>\n *      <p>y: {absolutePosition.y}</p>\n *    </div>\n *  );\n *}\n *```\n */ function useInternalNode(id) {\n    const node = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"useInternalNode.useStore[node]\": (s)=>s.nodeLookup.get(id)\n    }[\"useInternalNode.useStore[node]\"], [\n        id\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return node;\n}\nfunction LinePattern({ dimensions, lineWidth, variant, className }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n        strokeWidth: lineWidth,\n        d: `M${dimensions[0] / 2} 0 V${dimensions[1]} M0 ${dimensions[1] / 2} H${dimensions[0]}`,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__background-pattern',\n            variant,\n            className\n        ])\n    });\n}\nfunction DotPattern({ radius, className }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n        cx: radius,\n        cy: radius,\n        r: radius,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__background-pattern',\n            'dots',\n            className\n        ])\n    });\n}\n/**\n * The three variants are exported as an enum for convenience. You can either import\n * the enum and use it like `BackgroundVariant.Lines` or you can use the raw string\n * value directly.\n * @public\n */ var BackgroundVariant;\n(function(BackgroundVariant) {\n    BackgroundVariant[\"Lines\"] = \"lines\";\n    BackgroundVariant[\"Dots\"] = \"dots\";\n    BackgroundVariant[\"Cross\"] = \"cross\";\n})(BackgroundVariant || (BackgroundVariant = {}));\nconst defaultSize = {\n    [BackgroundVariant.Dots]: 1,\n    [BackgroundVariant.Lines]: 1,\n    [BackgroundVariant.Cross]: 6\n};\nconst selector$3 = (s)=>({\n        transform: s.transform,\n        patternId: `pattern-${s.rfId}`\n    });\nfunction BackgroundComponent({ id, variant = BackgroundVariant.Dots, // only used for dots and cross\ngap = 20, // only used for lines and cross\nsize, lineWidth = 1, offset = 0, color, bgColor, style, className, patternClassName }) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const { transform, patternId } = useStore(selector$3, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const patternSize = size || defaultSize[variant];\n    const isDots = variant === BackgroundVariant.Dots;\n    const isCross = variant === BackgroundVariant.Cross;\n    const gapXY = Array.isArray(gap) ? gap : [\n        gap,\n        gap\n    ];\n    const scaledGap = [\n        gapXY[0] * transform[2] || 1,\n        gapXY[1] * transform[2] || 1\n    ];\n    const scaledSize = patternSize * transform[2];\n    const offsetXY = Array.isArray(offset) ? offset : [\n        offset,\n        offset\n    ];\n    const patternDimensions = isCross ? [\n        scaledSize,\n        scaledSize\n    ] : scaledGap;\n    const scaledOffset = [\n        offsetXY[0] * transform[2] || 1 + patternDimensions[0] / 2,\n        offsetXY[1] * transform[2] || 1 + patternDimensions[1] / 2\n    ];\n    const _patternId = `${patternId}${id ? id : ''}`;\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__background',\n            className\n        ]),\n        style: {\n            ...style,\n            ...containerStyle,\n            '--xy-background-color-props': bgColor,\n            '--xy-background-pattern-color-props': color\n        },\n        ref: ref,\n        \"data-testid\": \"rf__background\",\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"pattern\", {\n                id: _patternId,\n                x: transform[0] % scaledGap[0],\n                y: transform[1] % scaledGap[1],\n                width: scaledGap[0],\n                height: scaledGap[1],\n                patternUnits: \"userSpaceOnUse\",\n                patternTransform: `translate(-${scaledOffset[0]},-${scaledOffset[1]})`,\n                children: isDots ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DotPattern, {\n                    radius: scaledSize / 2,\n                    className: patternClassName\n                }) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(LinePattern, {\n                    dimensions: patternDimensions,\n                    lineWidth: lineWidth,\n                    variant: variant,\n                    className: patternClassName\n                })\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"rect\", {\n                x: \"0\",\n                y: \"0\",\n                width: \"100%\",\n                height: \"100%\",\n                fill: `url(#${_patternId})`\n            })\n        ]\n    });\n}\nBackgroundComponent.displayName = 'Background';\n/**\n * The `<Background />` component makes it convenient to render different types of backgrounds common in node-based UIs. It comes with three variants: lines, dots and cross.\n *\n * @example\n *\n * A simple example of how to use the Background component.\n *\n * ```tsx\n * import { useState } from 'react';\n * import { ReactFlow, Background, BackgroundVariant } from '@xyflow/react';\n *\n * export default function Flow() {\n *   return (\n *     <ReactFlow defaultNodes={[...]} defaultEdges={[...]}>\n *       <Background color=\"#ccc\" variant={BackgroundVariant.Dots} />\n *     </ReactFlow>\n *   );\n * }\n * ```\n *\n * @example\n *\n * In this example you can see how to combine multiple backgrounds\n *\n * ```tsx\n * import { ReactFlow, Background, BackgroundVariant } from '@xyflow/react';\n * import '@xyflow/react/dist/style.css';\n *\n * export default function Flow() {\n *   return (\n *     <ReactFlow defaultNodes={[...]} defaultEdges={[...]}>\n *       <Background\n *         id=\"1\"\n *         gap={10}\n *         color=\"#f1f1f1\"\n *         variant={BackgroundVariant.Lines}\n *       />\n *       <Background\n *         id=\"2\"\n *         gap={100}\n *         color=\"#ccc\"\n *         variant={BackgroundVariant.Lines}\n *       />\n *     </ReactFlow>\n *   );\n * }\n * ```\n *\n * @remarks\n *\n * When combining multiple <Background /> components its important to give each of them a unique id prop!\n *\n */ const Background = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(BackgroundComponent);\nfunction PlusIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 32 32\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z\"\n        })\n    });\n}\nfunction MinusIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 32 5\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M0 0h32v4.2H0z\"\n        })\n    });\n}\nfunction FitViewIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 32 30\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z\"\n        })\n    });\n}\nfunction LockIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 25 32\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z\"\n        })\n    });\n}\nfunction UnlockIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 25 32\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z\"\n        })\n    });\n}\n/**\n * You can add buttons to the control panel by using the `<ControlButton />` component\n * and pass it as a child to the [`<Controls />`](/api-reference/components/controls) component.\n *\n * @public\n * @example\n *```jsx\n *import { MagicWand } from '@radix-ui/react-icons'\n *import { ReactFlow, Controls, ControlButton } from '@xyflow/react'\n *\n *export default function Flow() {\n *  return (\n *    <ReactFlow nodes={[...]} edges={[...]}>\n *      <Controls>\n *        <ControlButton onClick={() => alert('Something magical just happened. ')}>\n *          <MagicWand />\n *        </ControlButton>\n *      </Controls>\n *    </ReactFlow>\n *  )\n *}\n *```\n */ function ControlButton({ children, className, ...rest }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", {\n        type: \"button\",\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__controls-button',\n            className\n        ]),\n        ...rest,\n        children: children\n    });\n}\nconst selector$2 = (s)=>({\n        isInteractive: s.nodesDraggable || s.nodesConnectable || s.elementsSelectable,\n        minZoomReached: s.transform[2] <= s.minZoom,\n        maxZoomReached: s.transform[2] >= s.maxZoom,\n        ariaLabelConfig: s.ariaLabelConfig\n    });\nfunction ControlsComponent({ style, showZoom = true, showFitView = true, showInteractive = true, fitViewOptions, onZoomIn, onZoomOut, onFitView, onInteractiveChange, className, children, position = 'bottom-left', orientation = 'vertical', 'aria-label': ariaLabel }) {\n    const store = useStoreApi();\n    const { isInteractive, minZoomReached, maxZoomReached, ariaLabelConfig } = useStore(selector$2, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const { zoomIn, zoomOut, fitView } = useReactFlow();\n    const onZoomInHandler = ()=>{\n        zoomIn();\n        onZoomIn?.();\n    };\n    const onZoomOutHandler = ()=>{\n        zoomOut();\n        onZoomOut?.();\n    };\n    const onFitViewHandler = ()=>{\n        fitView(fitViewOptions);\n        onFitView?.();\n    };\n    const onToggleInteractivity = ()=>{\n        store.setState({\n            nodesDraggable: !isInteractive,\n            nodesConnectable: !isInteractive,\n            elementsSelectable: !isInteractive\n        });\n        onInteractiveChange?.(!isInteractive);\n    };\n    const orientationClass = orientation === 'horizontal' ? 'horizontal' : 'vertical';\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Panel, {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__controls',\n            orientationClass,\n            className\n        ]),\n        position: position,\n        style: style,\n        \"data-testid\": \"rf__controls\",\n        \"aria-label\": ariaLabel ?? ariaLabelConfig['controls.ariaLabel'],\n        children: [\n            showZoom && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                children: [\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {\n                        onClick: onZoomInHandler,\n                        className: \"react-flow__controls-zoomin\",\n                        title: ariaLabelConfig['controls.zoomIn.ariaLabel'],\n                        \"aria-label\": ariaLabelConfig['controls.zoomIn.ariaLabel'],\n                        disabled: maxZoomReached,\n                        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PlusIcon, {})\n                    }),\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {\n                        onClick: onZoomOutHandler,\n                        className: \"react-flow__controls-zoomout\",\n                        title: ariaLabelConfig['controls.zoomOut.ariaLabel'],\n                        \"aria-label\": ariaLabelConfig['controls.zoomOut.ariaLabel'],\n                        disabled: minZoomReached,\n                        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(MinusIcon, {})\n                    })\n                ]\n            }),\n            showFitView && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {\n                className: \"react-flow__controls-fitview\",\n                onClick: onFitViewHandler,\n                title: ariaLabelConfig['controls.fitView.ariaLabel'],\n                \"aria-label\": ariaLabelConfig['controls.fitView.ariaLabel'],\n                children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(FitViewIcon, {})\n            }),\n            showInteractive && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {\n                className: \"react-flow__controls-interactive\",\n                onClick: onToggleInteractivity,\n                title: ariaLabelConfig['controls.interactive.ariaLabel'],\n                \"aria-label\": ariaLabelConfig['controls.interactive.ariaLabel'],\n                children: isInteractive ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(UnlockIcon, {}) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(LockIcon, {})\n            }),\n            children\n        ]\n    });\n}\nControlsComponent.displayName = 'Controls';\n/**\n * The `<Controls />` component renders a small panel that contains convenient\n * buttons to zoom in, zoom out, fit the view, and lock the viewport.\n *\n * @public\n * @example\n *```tsx\n *import { ReactFlow, Controls } from '@xyflow/react'\n *\n *export default function Flow() {\n *  return (\n *    <ReactFlow nodes={[...]} edges={[...]}>\n *      <Controls />\n *    </ReactFlow>\n *  )\n *}\n *```\n *\n * @remarks To extend or customise the controls, you can use the [`<ControlButton />`](/api-reference/components/control-button) component\n *\n */ const Controls = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(ControlsComponent);\nfunction MiniMapNodeComponent({ id, x, y, width, height, style, color, strokeColor, strokeWidth, className, borderRadius, shapeRendering, selected, onClick }) {\n    const { background, backgroundColor } = style || {};\n    const fill = color || background || backgroundColor;\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"rect\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__minimap-node',\n            {\n                selected\n            },\n            className\n        ]),\n        x: x,\n        y: y,\n        rx: borderRadius,\n        ry: borderRadius,\n        width: width,\n        height: height,\n        style: {\n            fill,\n            stroke: strokeColor,\n            strokeWidth\n        },\n        shapeRendering: shapeRendering,\n        onClick: onClick ? (event)=>onClick(event, id) : undefined\n    });\n}\nconst MiniMapNode = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(MiniMapNodeComponent);\nconst selectorNodeIds = (s)=>s.nodes.map((node)=>node.id);\nconst getAttrFunction = (func)=>func instanceof Function ? func : ()=>func;\nfunction MiniMapNodes({ nodeStrokeColor, nodeColor, nodeClassName = '', nodeBorderRadius = 5, nodeStrokeWidth, /*\n * We need to rename the prop to be `CapitalCase` so that JSX will render it as\n * a component properly.\n */ nodeComponent: NodeComponent = MiniMapNode, onClick }) {\n    const nodeIds = useStore(selectorNodeIds, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const nodeColorFunc = getAttrFunction(nodeColor);\n    const nodeStrokeColorFunc = getAttrFunction(nodeStrokeColor);\n    const nodeClassNameFunc = getAttrFunction(nodeClassName);\n    const shapeRendering =  true ? 'crispEdges' : 0;\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: nodeIds.map((nodeId)=>/*\n         * The split of responsibilities between MiniMapNodes and\n         * NodeComponentWrapper may appear weird. However, its designed to\n         * minimize the cost of updates when individual nodes change.\n         *\n         * For more details, see a similar commit in `NodeRenderer/index.tsx`.\n         */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeComponentWrapper, {\n                id: nodeId,\n                nodeColorFunc: nodeColorFunc,\n                nodeStrokeColorFunc: nodeStrokeColorFunc,\n                nodeClassNameFunc: nodeClassNameFunc,\n                nodeBorderRadius: nodeBorderRadius,\n                nodeStrokeWidth: nodeStrokeWidth,\n                NodeComponent: NodeComponent,\n                onClick: onClick,\n                shapeRendering: shapeRendering\n            }, nodeId))\n    });\n}\nfunction NodeComponentWrapperInner({ id, nodeColorFunc, nodeStrokeColorFunc, nodeClassNameFunc, nodeBorderRadius, nodeStrokeWidth, shapeRendering, NodeComponent, onClick }) {\n    const { node, x, y, width, height } = useStore({\n        \"NodeComponentWrapperInner.useStore\": (s)=>{\n            const { internals } = s.nodeLookup.get(id);\n            const node = internals.userNode;\n            const { x, y } = internals.positionAbsolute;\n            const { width, height } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodeDimensions)(node);\n            return {\n                node,\n                x,\n                y,\n                width,\n                height\n            };\n        }\n    }[\"NodeComponentWrapperInner.useStore\"], zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    if (!node || node.hidden || !(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.nodeHasDimensions)(node)) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeComponent, {\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        style: node.style,\n        selected: !!node.selected,\n        className: nodeClassNameFunc(node),\n        color: nodeColorFunc(node),\n        borderRadius: nodeBorderRadius,\n        strokeColor: nodeStrokeColorFunc(node),\n        strokeWidth: nodeStrokeWidth,\n        shapeRendering: shapeRendering,\n        onClick: onClick,\n        id: node.id\n    });\n}\nconst NodeComponentWrapper = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(NodeComponentWrapperInner);\nvar MiniMapNodes$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(MiniMapNodes);\nconst defaultWidth = 200;\nconst defaultHeight = 150;\nconst filterHidden = (node)=>!node.hidden;\nconst selector$1 = (s)=>{\n    const viewBB = {\n        x: -s.transform[0] / s.transform[2],\n        y: -s.transform[1] / s.transform[2],\n        width: s.width / s.transform[2],\n        height: s.height / s.transform[2]\n    };\n    return {\n        viewBB,\n        boundingRect: s.nodeLookup.size > 0 ? (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBoundsOfRects)((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getInternalNodesBounds)(s.nodeLookup, {\n            filter: filterHidden\n        }), viewBB) : viewBB,\n        rfId: s.rfId,\n        panZoom: s.panZoom,\n        translateExtent: s.translateExtent,\n        flowWidth: s.width,\n        flowHeight: s.height,\n        ariaLabelConfig: s.ariaLabelConfig\n    };\n};\nconst ARIA_LABEL_KEY = 'react-flow__minimap-desc';\nfunction MiniMapComponent({ style, className, nodeStrokeColor, nodeColor, nodeClassName = '', nodeBorderRadius = 5, nodeStrokeWidth, /*\n * We need to rename the prop to be `CapitalCase` so that JSX will render it as\n * a component properly.\n */ nodeComponent, bgColor, maskColor, maskStrokeColor, maskStrokeWidth, position = 'bottom-right', onClick, onNodeClick, pannable = false, zoomable = false, ariaLabel, inversePan, zoomStep = 10, offsetScale = 5 }) {\n    const store = useStoreApi();\n    const svg = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const { boundingRect, viewBB, rfId, panZoom, translateExtent, flowWidth, flowHeight, ariaLabelConfig } = useStore(selector$1, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const elementWidth = style?.width ?? defaultWidth;\n    const elementHeight = style?.height ?? defaultHeight;\n    const scaledWidth = boundingRect.width / elementWidth;\n    const scaledHeight = boundingRect.height / elementHeight;\n    const viewScale = Math.max(scaledWidth, scaledHeight);\n    const viewWidth = viewScale * elementWidth;\n    const viewHeight = viewScale * elementHeight;\n    const offset = offsetScale * viewScale;\n    const x = boundingRect.x - (viewWidth - boundingRect.width) / 2 - offset;\n    const y = boundingRect.y - (viewHeight - boundingRect.height) / 2 - offset;\n    const width = viewWidth + offset * 2;\n    const height = viewHeight + offset * 2;\n    const labelledBy = `${ARIA_LABEL_KEY}-${rfId}`;\n    const viewScaleRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    const minimapInstance = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    viewScaleRef.current = viewScale;\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"MiniMapComponent.useEffect\": ()=>{\n            if (svg.current && panZoom) {\n                minimapInstance.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYMinimap)({\n                    domNode: svg.current,\n                    panZoom,\n                    getTransform: {\n                        \"MiniMapComponent.useEffect\": ()=>store.getState().transform\n                    }[\"MiniMapComponent.useEffect\"],\n                    getViewScale: {\n                        \"MiniMapComponent.useEffect\": ()=>viewScaleRef.current\n                    }[\"MiniMapComponent.useEffect\"]\n                });\n                return ({\n                    \"MiniMapComponent.useEffect\": ()=>{\n                        minimapInstance.current?.destroy();\n                    }\n                })[\"MiniMapComponent.useEffect\"];\n            }\n        }\n    }[\"MiniMapComponent.useEffect\"], [\n        panZoom\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"MiniMapComponent.useEffect\": ()=>{\n            minimapInstance.current?.update({\n                translateExtent,\n                width: flowWidth,\n                height: flowHeight,\n                inversePan,\n                pannable,\n                zoomStep,\n                zoomable\n            });\n        }\n    }[\"MiniMapComponent.useEffect\"], [\n        pannable,\n        zoomable,\n        inversePan,\n        zoomStep,\n        translateExtent,\n        flowWidth,\n        flowHeight\n    ]);\n    const onSvgClick = onClick ? (event)=>{\n        const [x, y] = minimapInstance.current?.pointer(event) || [\n            0,\n            0\n        ];\n        onClick(event, {\n            x,\n            y\n        });\n    } : undefined;\n    const onSvgNodeClick = onNodeClick ? (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"MiniMapComponent.useCallback\": (event, nodeId)=>{\n            const node = store.getState().nodeLookup.get(nodeId).internals.userNode;\n            onNodeClick(event, node);\n        }\n    }[\"MiniMapComponent.useCallback\"], []) : undefined;\n    const _ariaLabel = ariaLabel ?? ariaLabelConfig['minimap.ariaLabel'];\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Panel, {\n        position: position,\n        style: {\n            ...style,\n            '--xy-minimap-background-color-props': typeof bgColor === 'string' ? bgColor : undefined,\n            '--xy-minimap-mask-background-color-props': typeof maskColor === 'string' ? maskColor : undefined,\n            '--xy-minimap-mask-stroke-color-props': typeof maskStrokeColor === 'string' ? maskStrokeColor : undefined,\n            '--xy-minimap-mask-stroke-width-props': typeof maskStrokeWidth === 'number' ? maskStrokeWidth * viewScale : undefined,\n            '--xy-minimap-node-background-color-props': typeof nodeColor === 'string' ? nodeColor : undefined,\n            '--xy-minimap-node-stroke-color-props': typeof nodeStrokeColor === 'string' ? nodeStrokeColor : undefined,\n            '--xy-minimap-node-stroke-width-props': typeof nodeStrokeWidth === 'number' ? nodeStrokeWidth : undefined\n        },\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__minimap',\n            className\n        ]),\n        \"data-testid\": \"rf__minimap\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", {\n            width: elementWidth,\n            height: elementHeight,\n            viewBox: `${x} ${y} ${width} ${height}`,\n            className: \"react-flow__minimap-svg\",\n            role: \"img\",\n            \"aria-labelledby\": labelledBy,\n            ref: svg,\n            onClick: onSvgClick,\n            children: [\n                _ariaLabel && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"title\", {\n                    id: labelledBy,\n                    children: _ariaLabel\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(MiniMapNodes$1, {\n                    onClick: onSvgNodeClick,\n                    nodeColor: nodeColor,\n                    nodeStrokeColor: nodeStrokeColor,\n                    nodeBorderRadius: nodeBorderRadius,\n                    nodeClassName: nodeClassName,\n                    nodeStrokeWidth: nodeStrokeWidth,\n                    nodeComponent: nodeComponent\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    className: \"react-flow__minimap-mask\",\n                    d: `M${x - offset},${y - offset}h${width + offset * 2}v${height + offset * 2}h${-width - offset * 2}z\n        M${viewBB.x},${viewBB.y}h${viewBB.width}v${viewBB.height}h${-viewBB.width}z`,\n                    fillRule: \"evenodd\",\n                    pointerEvents: \"none\"\n                })\n            ]\n        })\n    });\n}\nMiniMapComponent.displayName = 'MiniMap';\n/**\n * The `<MiniMap />` component can be used to render an overview of your flow. It\n * renders each node as an SVG element and visualizes where the current viewport is\n * in relation to the rest of the flow.\n *\n * @public\n * @example\n *\n * ```jsx\n *import { ReactFlow, MiniMap } from '@xyflow/react';\n *\n *export default function Flow() {\n *  return (\n *    <ReactFlow nodes={[...]]} edges={[...]]}>\n *      <MiniMap nodeStrokeWidth={3} />\n *    </ReactFlow>\n *  );\n *}\n *```\n */ const MiniMap = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(MiniMapComponent);\nconst scaleSelector = (calculateScale)=>(store)=>calculateScale ? `${Math.max(1 / store.transform[2], 1)}` : undefined;\nconst defaultPositions = {\n    [_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant.Line]: 'right',\n    [_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant.Handle]: 'bottom-right'\n};\nfunction ResizeControl({ nodeId, position, variant = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant.Handle, className, style = undefined, children, color, minWidth = 10, minHeight = 10, maxWidth = Number.MAX_VALUE, maxHeight = Number.MAX_VALUE, keepAspectRatio = false, resizeDirection, autoScale = true, shouldResize, onResizeStart, onResize, onResizeEnd }) {\n    const contextNodeId = useNodeId();\n    const id = typeof nodeId === 'string' ? nodeId : contextNodeId;\n    const store = useStoreApi();\n    const resizeControlRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const isHandleControl = variant === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant.Handle;\n    const scale = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(scaleSelector(isHandleControl && autoScale), [\n        isHandleControl,\n        autoScale\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const resizer = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const controlPosition = position ?? defaultPositions[variant];\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ResizeControl.useEffect\": ()=>{\n            if (!resizeControlRef.current || !id) {\n                return;\n            }\n            if (!resizer.current) {\n                resizer.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYResizer)({\n                    domNode: resizeControlRef.current,\n                    nodeId: id,\n                    getStoreItems: {\n                        \"ResizeControl.useEffect\": ()=>{\n                            const { nodeLookup, transform, snapGrid, snapToGrid, nodeOrigin, domNode } = store.getState();\n                            return {\n                                nodeLookup,\n                                transform,\n                                snapGrid,\n                                snapToGrid,\n                                nodeOrigin,\n                                paneDomNode: domNode\n                            };\n                        }\n                    }[\"ResizeControl.useEffect\"],\n                    onChange: {\n                        \"ResizeControl.useEffect\": (change, childChanges)=>{\n                            const { triggerNodeChanges, nodeLookup, parentLookup, nodeOrigin } = store.getState();\n                            const changes = [];\n                            const nextPosition = {\n                                x: change.x,\n                                y: change.y\n                            };\n                            const node = nodeLookup.get(id);\n                            if (node && node.expandParent && node.parentId) {\n                                const origin = node.origin ?? nodeOrigin;\n                                const width = change.width ?? node.measured.width ?? 0;\n                                const height = change.height ?? node.measured.height ?? 0;\n                                const child = {\n                                    id: node.id,\n                                    parentId: node.parentId,\n                                    rect: {\n                                        width,\n                                        height,\n                                        ...(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.evaluateAbsolutePosition)({\n                                            x: change.x ?? node.position.x,\n                                            y: change.y ?? node.position.y\n                                        }, {\n                                            width,\n                                            height\n                                        }, node.parentId, nodeLookup, origin)\n                                    }\n                                };\n                                const parentExpandChanges = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleExpandParent)([\n                                    child\n                                ], nodeLookup, parentLookup, nodeOrigin);\n                                changes.push(...parentExpandChanges);\n                                /*\n                         * when the parent was expanded by the child node, its position will be clamped at\n                         * 0,0 when node origin is 0,0 and to width, height if it's 1,1\n                         */ nextPosition.x = change.x ? Math.max(origin[0] * width, change.x) : undefined;\n                                nextPosition.y = change.y ? Math.max(origin[1] * height, change.y) : undefined;\n                            }\n                            if (nextPosition.x !== undefined && nextPosition.y !== undefined) {\n                                const positionChange = {\n                                    id,\n                                    type: 'position',\n                                    position: {\n                                        ...nextPosition\n                                    }\n                                };\n                                changes.push(positionChange);\n                            }\n                            if (change.width !== undefined && change.height !== undefined) {\n                                const setAttributes = !resizeDirection ? true : resizeDirection === 'horizontal' ? 'width' : 'height';\n                                const dimensionChange = {\n                                    id,\n                                    type: 'dimensions',\n                                    resizing: true,\n                                    setAttributes,\n                                    dimensions: {\n                                        width: change.width,\n                                        height: change.height\n                                    }\n                                };\n                                changes.push(dimensionChange);\n                            }\n                            for (const childChange of childChanges){\n                                const positionChange = {\n                                    ...childChange,\n                                    type: 'position'\n                                };\n                                changes.push(positionChange);\n                            }\n                            triggerNodeChanges(changes);\n                        }\n                    }[\"ResizeControl.useEffect\"],\n                    onEnd: {\n                        \"ResizeControl.useEffect\": ({ width, height })=>{\n                            const dimensionChange = {\n                                id: id,\n                                type: 'dimensions',\n                                resizing: false,\n                                dimensions: {\n                                    width,\n                                    height\n                                }\n                            };\n                            store.getState().triggerNodeChanges([\n                                dimensionChange\n                            ]);\n                        }\n                    }[\"ResizeControl.useEffect\"]\n                });\n            }\n            resizer.current.update({\n                controlPosition,\n                boundaries: {\n                    minWidth,\n                    minHeight,\n                    maxWidth,\n                    maxHeight\n                },\n                keepAspectRatio,\n                resizeDirection,\n                onResizeStart,\n                onResize,\n                onResizeEnd,\n                shouldResize\n            });\n            return ({\n                \"ResizeControl.useEffect\": ()=>{\n                    resizer.current?.destroy();\n                }\n            })[\"ResizeControl.useEffect\"];\n        }\n    }[\"ResizeControl.useEffect\"], [\n        controlPosition,\n        minWidth,\n        minHeight,\n        maxWidth,\n        maxHeight,\n        keepAspectRatio,\n        onResizeStart,\n        onResize,\n        onResizeEnd,\n        shouldResize\n    ]);\n    const positionClassNames = controlPosition.split('-');\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__resize-control',\n            'nodrag',\n            ...positionClassNames,\n            variant,\n            className\n        ]),\n        ref: resizeControlRef,\n        style: {\n            ...style,\n            scale,\n            ...color && {\n                [isHandleControl ? 'backgroundColor' : 'borderColor']: color\n            }\n        },\n        children: children\n    });\n}\n/**\n * To create your own resizing UI, you can use the `NodeResizeControl` component where you can pass children (such as icons).\n * @public\n *\n */ const NodeResizeControl = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(ResizeControl);\n/**\n * The `<NodeResizer />` component can be used to add a resize functionality to your\n * nodes. It renders draggable controls around the node to resize in all directions.\n * @public\n *\n * @example\n *```jsx\n *import { memo } from 'react';\n *import { Handle, Position, NodeResizer } from '@xyflow/react';\n *\n *function ResizableNode({ data }) {\n *  return (\n *    <>\n *      <NodeResizer minWidth={100} minHeight={30} />\n *      <Handle type=\"target\" position={Position.Left} />\n *      <div style={{ padding: 10 }}>{data.label}</div>\n *      <Handle type=\"source\" position={Position.Right} />\n *    </>\n *  );\n *};\n *\n *export default memo(ResizableNode);\n *```\n */ function NodeResizer({ nodeId, isVisible = true, handleClassName, handleStyle, lineClassName, lineStyle, color, minWidth = 10, minHeight = 10, maxWidth = Number.MAX_VALUE, maxHeight = Number.MAX_VALUE, keepAspectRatio = false, autoScale = true, shouldResize, onResizeStart, onResize, onResizeEnd }) {\n    if (!isVisible) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XY_RESIZER_LINE_POSITIONS.map((position)=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeResizeControl, {\n                    className: lineClassName,\n                    style: lineStyle,\n                    nodeId: nodeId,\n                    position: position,\n                    variant: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant.Line,\n                    color: color,\n                    minWidth: minWidth,\n                    minHeight: minHeight,\n                    maxWidth: maxWidth,\n                    maxHeight: maxHeight,\n                    onResizeStart: onResizeStart,\n                    keepAspectRatio: keepAspectRatio,\n                    autoScale: autoScale,\n                    shouldResize: shouldResize,\n                    onResize: onResize,\n                    onResizeEnd: onResizeEnd\n                }, position)),\n            _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XY_RESIZER_HANDLE_POSITIONS.map((position)=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeResizeControl, {\n                    className: handleClassName,\n                    style: handleStyle,\n                    nodeId: nodeId,\n                    position: position,\n                    color: color,\n                    minWidth: minWidth,\n                    minHeight: minHeight,\n                    maxWidth: maxWidth,\n                    maxHeight: maxHeight,\n                    onResizeStart: onResizeStart,\n                    keepAspectRatio: keepAspectRatio,\n                    autoScale: autoScale,\n                    shouldResize: shouldResize,\n                    onResize: onResize,\n                    onResizeEnd: onResizeEnd\n                }, position))\n        ]\n    });\n}\nconst selector = (state)=>state.domNode?.querySelector('.react-flow__renderer');\nfunction NodeToolbarPortal({ children }) {\n    const wrapperRef = useStore(selector);\n    if (!wrapperRef) {\n        return null;\n    }\n    return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_4__.createPortal)(children, wrapperRef);\n}\nconst nodeEqualityFn = (a, b)=>a?.internals.positionAbsolute.x !== b?.internals.positionAbsolute.x || a?.internals.positionAbsolute.y !== b?.internals.positionAbsolute.y || a?.measured.width !== b?.measured.width || a?.measured.height !== b?.measured.height || a?.selected !== b?.selected || a?.internals.z !== b?.internals.z;\nconst nodesEqualityFn = (a, b)=>{\n    if (a.size !== b.size) {\n        return false;\n    }\n    for (const [key, node] of a){\n        if (nodeEqualityFn(node, b.get(key))) {\n            return false;\n        }\n    }\n    return true;\n};\nconst storeSelector = (state)=>({\n        x: state.transform[0],\n        y: state.transform[1],\n        zoom: state.transform[2],\n        selectedNodesCount: state.nodes.filter((node)=>node.selected).length\n    });\n/**\n * This component can render a toolbar or tooltip to one side of a custom node. This\n * toolbar doesn't scale with the viewport so that the content is always visible.\n *\n * @public\n * @example\n * ```jsx\n *import { memo } from 'react';\n *import { Handle, Position, NodeToolbar } from '@xyflow/react';\n *\n *function CustomNode({ data }) {\n *  return (\n *    <>\n *      <NodeToolbar isVisible={data.toolbarVisible} position={data.toolbarPosition}>\n *        <button>delete</button>\n *        <button>copy</button>\n *        <button>expand</button>\n *      </NodeToolbar>\n *\n *      <div style={{ padding: '10px 20px' }}>\n *        {data.label}\n *      </div>\n *\n *      <Handle type=\"target\" position={Position.Left} />\n *      <Handle type=\"source\" position={Position.Right} />\n *    </>\n *  );\n *};\n *\n *export default memo(CustomNode);\n *```\n * @remarks By default, the toolbar is only visible when a node is selected. If multiple\n * nodes are selected it will not be visible to prevent overlapping toolbars or\n * clutter. You can override this behavior by setting the `isVisible` prop to `true`.\n */ function NodeToolbar({ nodeId, children, className, style, isVisible, position = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top, offset = 10, align = 'center', ...rest }) {\n    const contextNodeId = useNodeId();\n    const nodesSelector = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"NodeToolbar.useCallback[nodesSelector]\": (state)=>{\n            const nodeIds = Array.isArray(nodeId) ? nodeId : [\n                nodeId || contextNodeId || ''\n            ];\n            const internalNodes = nodeIds.reduce({\n                \"NodeToolbar.useCallback[nodesSelector].internalNodes\": (res, id)=>{\n                    const node = state.nodeLookup.get(id);\n                    if (node) {\n                        res.set(node.id, node);\n                    }\n                    return res;\n                }\n            }[\"NodeToolbar.useCallback[nodesSelector].internalNodes\"], new Map());\n            return internalNodes;\n        }\n    }[\"NodeToolbar.useCallback[nodesSelector]\"], [\n        nodeId,\n        contextNodeId\n    ]);\n    const nodes = useStore(nodesSelector, nodesEqualityFn);\n    const { x, y, zoom, selectedNodesCount } = useStore(storeSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    // if isVisible is not set, we show the toolbar only if its node is selected and no other node is selected\n    const isActive = typeof isVisible === 'boolean' ? isVisible : nodes.size === 1 && nodes.values().next().value?.selected && selectedNodesCount === 1;\n    if (!isActive || !nodes.size) {\n        return null;\n    }\n    const nodeRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getInternalNodesBounds)(nodes);\n    const nodesArray = Array.from(nodes.values());\n    const zIndex = Math.max(...nodesArray.map((node)=>node.internals.z + 1));\n    const wrapperStyle = {\n        position: 'absolute',\n        transform: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodeToolbarTransform)(nodeRect, {\n            x,\n            y,\n            zoom\n        }, position, offset, align),\n        zIndex,\n        ...style\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeToolbarPortal, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n            style: wrapperStyle,\n            className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n                'react-flow__node-toolbar',\n                className\n            ]),\n            ...rest,\n            \"data-id\": nodesArray.reduce((acc, node)=>`${acc}${node.id} `, '').trim(),\n            children: children\n        })\n    });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHh5ZmxvdytyZWFjdEAxMi43LjFfQHR5cGVzK3JlYWN0QDE4LjMuMjNfcmVhY3QtZG9tQDE5LjEuMF9yZWFjdEAxOS4xLjBfX3JlYWN0QDE5LjEuMC9ub2RlX21vZHVsZXMvQHh5Zmxvdy9yZWFjdC9kaXN0L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvN0JBQ3dEO0FBQ2dGO0FBQzlHO0FBQ2tzQztBQUMxNEI7QUFDL1A7QUFDekM7QUFDRDtBQUV6QyxNQUFNNkYsNkJBQWUxRixvREFBYUEsQ0FBQztBQUNuQyxNQUFNMkYsYUFBYUQsYUFBYUUsUUFBUTtBQUV4QyxNQUFNQyxzQkFBc0JsRix5REFBYSxDQUFDLFdBQVc7QUFDckQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FzQkMsR0FDRCxTQUFTbUYsU0FBU0MsUUFBUSxFQUFFQyxVQUFVO0lBQ2xDLE1BQU1DLFFBQVFoRyxpREFBVUEsQ0FBQ3lGO0lBQ3pCLElBQUlPLFVBQVUsTUFBTTtRQUNoQixNQUFNLElBQUlDLE1BQU1MO0lBQ3BCO0lBQ0EsT0FBT1AsMkVBQXNCQSxDQUFDVyxPQUFPRixVQUFVQztBQUNuRDtBQUNBOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNELFNBQVNHO0lBQ0wsTUFBTUYsUUFBUWhHLGlEQUFVQSxDQUFDeUY7SUFDekIsSUFBSU8sVUFBVSxNQUFNO1FBQ2hCLE1BQU0sSUFBSUMsTUFBTUw7SUFDcEI7SUFDQSxPQUFPM0YsOENBQU9BOytCQUFDLElBQU87Z0JBQ2xCa0csVUFBVUgsTUFBTUcsUUFBUTtnQkFDeEJDLFVBQVVKLE1BQU1JLFFBQVE7Z0JBQ3hCQyxXQUFXTCxNQUFNSyxTQUFTO1lBQzlCOzhCQUFJO1FBQUNMO0tBQU07QUFDZjtBQUVBLE1BQU1NLFFBQVE7SUFBRUMsU0FBUztBQUFPO0FBQ2hD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QUksQ0FBQzNSLE1BQU02UixNQUFNO0lBQzFDLE1BQU1pVSxTQUFTeE4sS0FBSzRkLEdBQUcsSUFBSXdQLFdBQVc5bEMsR0FBRyxDQUFDLENBQUNiLE9BQVNBLEtBQUtJLFNBQVMsQ0FBQzRtQixDQUFDLEdBQUc7SUFDdkUsTUFBTTBSLGVBQWU7UUFDakJwN0IsVUFBVTtRQUNWc0wsV0FBV2hOLHVFQUF1QkEsQ0FBQ2dXLFVBQVU7WUFBRWpRO1lBQUdDO1lBQUdDO1FBQUssR0FBR3ZFLFVBQVVxd0IsUUFBUThZO1FBQy9FMWY7UUFDQSxHQUFHNXBCLEtBQUs7SUFDWjtJQUNBLE9BQVF4RyxzREFBR0EsQ0FBQ3V2QyxtQkFBbUI7UUFBRXhuQyxVQUFVL0gsc0RBQUdBLENBQUMsT0FBTztZQUFFd0csT0FBT3U3QjtZQUFjMTVCLFdBQVcxSCxvREFBRUEsQ0FBQztnQkFBQztnQkFBNEIwSDthQUFVO1lBQUcsR0FBR0MsSUFBSTtZQUFFLFdBQVcwbkMsV0FBVzdnQyxNQUFNLENBQUMsQ0FBQzhnQyxLQUFLNW1DLE9BQVMsR0FBRzRtQyxNQUFNNW1DLEtBQUt2QixFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSW9vQyxJQUFJO1lBQUlub0MsVUFBVUE7UUFBUztJQUFHO0FBQ3JQO0FBRWdxQiIsInNvdXJjZXMiOlsiL1VzZXJzL293ZW4vcmVwb3MvZ3VtbnV0L2Jlc3Bva2UtbWluZC1nYXJkZW4vbm9kZV9tb2R1bGVzLy5wbnBtL0B4eWZsb3crcmVhY3RAMTIuNy4xX0B0eXBlcytyZWFjdEAxOC4zLjIzX3JlYWN0LWRvbUAxOS4xLjBfcmVhY3RAMTkuMS4wX19yZWFjdEAxOS4xLjAvbm9kZV9tb2R1bGVzL0B4eWZsb3cvcmVhY3QvZGlzdC9lc20vaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCJcbmltcG9ydCB7IGpzeHMsIEZyYWdtZW50LCBqc3ggfSBmcm9tICdyZWFjdC9qc3gtcnVudGltZSc7XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VNZW1vLCBmb3J3YXJkUmVmLCB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUsIHVzZUxheW91dEVmZmVjdCwgdXNlQ2FsbGJhY2ssIG1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY2MgZnJvbSAnY2xhc3NjYXQnO1xuaW1wb3J0IHsgZXJyb3JNZXNzYWdlcywgbWVyZ2VBcmlhTGFiZWxDb25maWcsIGluZmluaXRlRXh0ZW50LCBpc0lucHV0RE9NTm9kZSwgZ2V0Vmlld3BvcnRGb3JCb3VuZHMsIHBvaW50VG9SZW5kZXJlclBvaW50LCByZW5kZXJlclBvaW50VG9Qb2ludCwgaXNOb2RlQmFzZSwgaXNFZGdlQmFzZSwgZ2V0RWxlbWVudHNUb1JlbW92ZSwgaXNSZWN0T2JqZWN0LCBub2RlVG9SZWN0LCBnZXRPdmVybGFwcGluZ0FyZWEsIGdldE5vZGVzQm91bmRzLCB3aXRoUmVzb2x2ZXJzLCBldmFsdWF0ZUFic29sdXRlUG9zaXRpb24sIGdldERpbWVuc2lvbnMsIFhZUGFuWm9vbSwgUGFuT25TY3JvbGxNb2RlLCBTZWxlY3Rpb25Nb2RlLCBnZXRFdmVudFBvc2l0aW9uLCBnZXROb2Rlc0luc2lkZSwgYXJlU2V0c0VxdWFsLCBYWURyYWcsIHNuYXBQb3NpdGlvbiwgY2FsY3VsYXRlTm9kZVBvc2l0aW9uLCBQb3NpdGlvbiwgQ29ubmVjdGlvbk1vZGUsIGlzTW91c2VFdmVudCwgWFlIYW5kbGUsIGdldEhvc3RGb3JFbGVtZW50LCBhZGRFZGdlLCBnZXRJbnRlcm5hbE5vZGVzQm91bmRzLCBpc051bWVyaWMsIG5vZGVIYXNEaW1lbnNpb25zLCBnZXROb2RlRGltZW5zaW9ucywgZWxlbWVudFNlbGVjdGlvbktleXMsIGlzRWRnZVZpc2libGUsIE1hcmtlclR5cGUsIGNyZWF0ZU1hcmtlcklkcywgZ2V0QmV6aWVyRWRnZUNlbnRlciwgZ2V0U21vb3RoU3RlcFBhdGgsIGdldFN0cmFpZ2h0UGF0aCwgZ2V0QmV6aWVyUGF0aCwgZ2V0RWRnZVBvc2l0aW9uLCBnZXRFbGV2YXRlZEVkZ2VaSW5kZXgsIGdldE1hcmtlcklkLCBnZXRDb25uZWN0aW9uU3RhdHVzLCBDb25uZWN0aW9uTGluZVR5cGUsIHVwZGF0ZUNvbm5lY3Rpb25Mb29rdXAsIGFkb3B0VXNlck5vZGVzLCBpbml0aWFsQ29ubmVjdGlvbiwgZGV2V2FybiwgZGVmYXVsdEFyaWFMYWJlbENvbmZpZywgdXBkYXRlTm9kZUludGVybmFscywgdXBkYXRlQWJzb2x1dGVQb3NpdGlvbnMsIGhhbmRsZUV4cGFuZFBhcmVudCwgcGFuQnksIGZpdFZpZXdwb3J0LCBpc01hY09zLCBhcmVDb25uZWN0aW9uTWFwc0VxdWFsLCBoYW5kbGVDb25uZWN0aW9uQ2hhbmdlLCBzaGFsbG93Tm9kZURhdGEsIFhZTWluaW1hcCwgZ2V0Qm91bmRzT2ZSZWN0cywgUmVzaXplQ29udHJvbFZhcmlhbnQsIFhZUmVzaXplciwgWFlfUkVTSVpFUl9MSU5FX1BPU0lUSU9OUywgWFlfUkVTSVpFUl9IQU5ETEVfUE9TSVRJT05TLCBnZXROb2RlVG9vbGJhclRyYW5zZm9ybSB9IGZyb20gJ0B4eWZsb3cvc3lzdGVtJztcbmV4cG9ydCB7IENvbm5lY3Rpb25MaW5lVHlwZSwgQ29ubmVjdGlvbk1vZGUsIE1hcmtlclR5cGUsIFBhbk9uU2Nyb2xsTW9kZSwgUG9zaXRpb24sIFJlc2l6ZUNvbnRyb2xWYXJpYW50LCBTZWxlY3Rpb25Nb2RlLCBhZGRFZGdlLCBnZXRCZXppZXJFZGdlQ2VudGVyLCBnZXRCZXppZXJQYXRoLCBnZXRDb25uZWN0ZWRFZGdlcywgZ2V0RWRnZUNlbnRlciwgZ2V0SW5jb21lcnMsIGdldE5vZGVzQm91bmRzLCBnZXRPdXRnb2VycywgZ2V0U21vb3RoU3RlcFBhdGgsIGdldFN0cmFpZ2h0UGF0aCwgZ2V0Vmlld3BvcnRGb3JCb3VuZHMsIHJlY29ubmVjdEVkZ2UgfSBmcm9tICdAeHlmbG93L3N5c3RlbSc7XG5pbXBvcnQgeyB1c2VTdG9yZVdpdGhFcXVhbGl0eUZuLCBjcmVhdGVXaXRoRXF1YWxpdHlGbiB9IGZyb20gJ3p1c3RhbmQvdHJhZGl0aW9uYWwnO1xuaW1wb3J0IHsgc2hhbGxvdyB9IGZyb20gJ3p1c3RhbmQvc2hhbGxvdyc7XG5pbXBvcnQgeyBjcmVhdGVQb3J0YWwgfSBmcm9tICdyZWFjdC1kb20nO1xuXG5jb25zdCBTdG9yZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xuY29uc3QgUHJvdmlkZXIkMSA9IFN0b3JlQ29udGV4dC5Qcm92aWRlcjtcblxuY29uc3QgenVzdGFuZEVycm9yTWVzc2FnZSA9IGVycm9yTWVzc2FnZXNbJ2Vycm9yMDAxJ10oKTtcbi8qKlxuICogVGhpcyBob29rIGNhbiBiZSB1c2VkIHRvIHN1YnNjcmliZSB0byBpbnRlcm5hbCBzdGF0ZSBjaGFuZ2VzIG9mIHRoZSBSZWFjdCBGbG93XG4gKiBjb21wb25lbnQuIFRoZSBgdXNlU3RvcmVgIGhvb2sgaXMgcmUtZXhwb3J0ZWQgZnJvbSB0aGUgW1p1c3RhbmRdKGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvenVzdGFuZClcbiAqIHN0YXRlIG1hbmFnZW1lbnQgbGlicmFyeSwgc28geW91IHNob3VsZCBjaGVjayBvdXQgdGhlaXIgZG9jcyBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBzZWxlY3RvciAtIEEgc2VsZWN0b3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgc2xpY2Ugb2YgdGhlIGZsb3cncyBpbnRlcm5hbCBzdGF0ZS5cbiAqIEV4dHJhY3Rpbmcgb3IgdHJhbnNmb3JtaW5nIGp1c3QgdGhlIHN0YXRlIHlvdSBuZWVkIGlzIGEgZ29vZCBwcmFjdGljZSB0byBhdm9pZCB1bm5lY2Vzc2FyeVxuICogcmUtcmVuZGVycy5cbiAqIEBwYXJhbSBlcXVhbGl0eUZuIC0gQSBmdW5jdGlvbiB0byBjb21wYXJlIHRoZSBwcmV2aW91cyBhbmQgbmV4dCB2YWx1ZS4gVGhpcyBpcyBpbmNyZWRpYmx5IHVzZWZ1bFxuICogZm9yIHByZXZlbnRpbmcgdW5uZWNlc3NhcnkgcmUtcmVuZGVycy4gR29vZCBzZW5zaWJsZSBkZWZhdWx0cyBhcmUgdXNpbmcgYE9iamVjdC5pc2Agb3IgaW1wb3J0aW5nXG4gKiBgenVzdGFuZC9zaGFsbG93YCwgYnV0IHlvdSBjYW4gYmUgYXMgZ3JhbnVsYXIgYXMgeW91IGxpa2UuXG4gKiBAcmV0dXJucyBUaGUgc2VsZWN0ZWQgc3RhdGUgc2xpY2UuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zdCBub2RlcyA9IHVzZVN0b3JlKChzdGF0ZSkgPT4gc3RhdGUubm9kZXMpO1xuICogYGBgXG4gKlxuICogQHJlbWFya3MgVGhpcyBob29rIHNob3VsZCBvbmx5IGJlIHVzZWQgaWYgdGhlcmUgaXMgbm8gb3RoZXIgd2F5IHRvIGFjY2VzcyB0aGUgaW50ZXJuYWxcbiAqIHN0YXRlLiBGb3IgbWFueSBvZiB0aGUgY29tbW9uIHVzZSBjYXNlcywgdGhlcmUgYXJlIGRlZGljYXRlZCBob29rcyBhdmFpbGFibGVcbiAqIHN1Y2ggYXMge0BsaW5rIHVzZVJlYWN0Rmxvd30sIHtAbGluayB1c2VWaWV3cG9ydH0sIGV0Yy5cbiAqL1xuZnVuY3Rpb24gdXNlU3RvcmUoc2VsZWN0b3IsIGVxdWFsaXR5Rm4pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZUNvbnRleHQoU3RvcmVDb250ZXh0KTtcbiAgICBpZiAoc3RvcmUgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHp1c3RhbmRFcnJvck1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gdXNlU3RvcmVXaXRoRXF1YWxpdHlGbihzdG9yZSwgc2VsZWN0b3IsIGVxdWFsaXR5Rm4pO1xufVxuLyoqXG4gKiBJbiBzb21lIGNhc2VzLCB5b3UgbWlnaHQgbmVlZCB0byBhY2Nlc3MgdGhlIHN0b3JlIGRpcmVjdGx5LiBUaGlzIGhvb2sgcmV0dXJucyB0aGUgc3RvcmUgb2JqZWN0IHdoaWNoIGNhbiBiZSB1c2VkIG9uIGRlbWFuZCB0byBhY2Nlc3MgdGhlIHN0YXRlIG9yIGRpc3BhdGNoIGFjdGlvbnMuXG4gKlxuICogQHJldHVybnMgVGhlIHN0b3JlIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICogYGBgXG4gKlxuICogQHJlbWFya3MgVGhpcyBob29rIHNob3VsZCBvbmx5IGJlIHVzZWQgaWYgdGhlcmUgaXMgbm8gb3RoZXIgd2F5IHRvIGFjY2VzcyB0aGUgaW50ZXJuYWxcbiAqIHN0YXRlLiBGb3IgbWFueSBvZiB0aGUgY29tbW9uIHVzZSBjYXNlcywgdGhlcmUgYXJlIGRlZGljYXRlZCBob29rcyBhdmFpbGFibGVcbiAqIHN1Y2ggYXMge0BsaW5rIHVzZVJlYWN0Rmxvd30sIHtAbGluayB1c2VWaWV3cG9ydH0sIGV0Yy5cbiAqL1xuZnVuY3Rpb24gdXNlU3RvcmVBcGkoKSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VDb250ZXh0KFN0b3JlQ29udGV4dCk7XG4gICAgaWYgKHN0b3JlID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih6dXN0YW5kRXJyb3JNZXNzYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHVzZU1lbW8oKCkgPT4gKHtcbiAgICAgICAgZ2V0U3RhdGU6IHN0b3JlLmdldFN0YXRlLFxuICAgICAgICBzZXRTdGF0ZTogc3RvcmUuc2V0U3RhdGUsXG4gICAgICAgIHN1YnNjcmliZTogc3RvcmUuc3Vic2NyaWJlLFxuICAgIH0pLCBbc3RvcmVdKTtcbn1cblxuY29uc3Qgc3R5bGUgPSB7IGRpc3BsYXk6ICdub25lJyB9O1xuY29uc3QgYXJpYUxpdmVTdHlsZSA9IHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB3aWR0aDogMSxcbiAgICBoZWlnaHQ6IDEsXG4gICAgbWFyZ2luOiAtMSxcbiAgICBib3JkZXI6IDAsXG4gICAgcGFkZGluZzogMCxcbiAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgY2xpcDogJ3JlY3QoMHB4LCAwcHgsIDBweCwgMHB4KScsXG4gICAgY2xpcFBhdGg6ICdpbnNldCgxMDAlKScsXG59O1xuY29uc3QgQVJJQV9OT0RFX0RFU0NfS0VZID0gJ3JlYWN0LWZsb3dfX25vZGUtZGVzYyc7XG5jb25zdCBBUklBX0VER0VfREVTQ19LRVkgPSAncmVhY3QtZmxvd19fZWRnZS1kZXNjJztcbmNvbnN0IEFSSUFfTElWRV9NRVNTQUdFID0gJ3JlYWN0LWZsb3dfX2FyaWEtbGl2ZSc7XG5jb25zdCBhcmlhTGl2ZVNlbGVjdG9yID0gKHMpID0+IHMuYXJpYUxpdmVNZXNzYWdlO1xuY29uc3QgYXJpYUxhYmVsQ29uZmlnU2VsZWN0b3IgPSAocykgPT4gcy5hcmlhTGFiZWxDb25maWc7XG5mdW5jdGlvbiBBcmlhTGl2ZU1lc3NhZ2UoeyByZklkIH0pIHtcbiAgICBjb25zdCBhcmlhTGl2ZU1lc3NhZ2UgPSB1c2VTdG9yZShhcmlhTGl2ZVNlbGVjdG9yKTtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGlkOiBgJHtBUklBX0xJVkVfTUVTU0FHRX0tJHtyZklkfWAsIFwiYXJpYS1saXZlXCI6IFwiYXNzZXJ0aXZlXCIsIFwiYXJpYS1hdG9taWNcIjogXCJ0cnVlXCIsIHN0eWxlOiBhcmlhTGl2ZVN0eWxlLCBjaGlsZHJlbjogYXJpYUxpdmVNZXNzYWdlIH0pKTtcbn1cbmZ1bmN0aW9uIEExMXlEZXNjcmlwdGlvbnMoeyByZklkLCBkaXNhYmxlS2V5Ym9hcmRBMTF5IH0pIHtcbiAgICBjb25zdCBhcmlhTGFiZWxDb25maWcgPSB1c2VTdG9yZShhcmlhTGFiZWxDb25maWdTZWxlY3Rvcik7XG4gICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbanN4KFwiZGl2XCIsIHsgaWQ6IGAke0FSSUFfTk9ERV9ERVNDX0tFWX0tJHtyZklkfWAsIHN0eWxlOiBzdHlsZSwgY2hpbGRyZW46IGRpc2FibGVLZXlib2FyZEExMXlcbiAgICAgICAgICAgICAgICAgICAgPyBhcmlhTGFiZWxDb25maWdbJ25vZGUuYTExeURlc2NyaXB0aW9uLmRlZmF1bHQnXVxuICAgICAgICAgICAgICAgICAgICA6IGFyaWFMYWJlbENvbmZpZ1snbm9kZS5hMTF5RGVzY3JpcHRpb24ua2V5Ym9hcmREaXNhYmxlZCddIH0pLCBqc3goXCJkaXZcIiwgeyBpZDogYCR7QVJJQV9FREdFX0RFU0NfS0VZfS0ke3JmSWR9YCwgc3R5bGU6IHN0eWxlLCBjaGlsZHJlbjogYXJpYUxhYmVsQ29uZmlnWydlZGdlLmExMXlEZXNjcmlwdGlvbi5kZWZhdWx0J10gfSksICFkaXNhYmxlS2V5Ym9hcmRBMTF5ICYmIGpzeChBcmlhTGl2ZU1lc3NhZ2UsIHsgcmZJZDogcmZJZCB9KV0gfSkpO1xufVxuXG5jb25zdCBzZWxlY3RvciRuID0gKHMpID0+IChzLnVzZXJTZWxlY3Rpb25BY3RpdmUgPyAnbm9uZScgOiAnYWxsJyk7XG4vKipcbiAqIFRoZSBgPFBhbmVsIC8+YCBjb21wb25lbnQgaGVscHMgeW91IHBvc2l0aW9uIGNvbnRlbnQgYWJvdmUgdGhlIHZpZXdwb3J0LlxuICogSXQgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBbYDxNaW5pTWFwIC8+YF0oL2FwaS1yZWZlcmVuY2UvY29tcG9uZW50cy9taW5pbWFwKVxuICogYW5kIFtgPENvbnRyb2xzIC8+YF0oL2FwaS1yZWZlcmVuY2UvY29tcG9uZW50cy9jb250cm9scykgY29tcG9uZW50cy5cbiAqXG4gKiBAcHVibGljXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzeFxuICppbXBvcnQgeyBSZWFjdEZsb3csIEJhY2tncm91bmQsIFBhbmVsIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGbG93KCkge1xuICogIHJldHVybiAoXG4gKiAgICA8UmVhY3RGbG93IG5vZGVzPXtbXX0gZml0Vmlldz5cbiAqICAgICAgPFBhbmVsIHBvc2l0aW9uPVwidG9wLWxlZnRcIj50b3AtbGVmdDwvUGFuZWw+XG4gKiAgICAgIDxQYW5lbCBwb3NpdGlvbj1cInRvcC1jZW50ZXJcIj50b3AtY2VudGVyPC9QYW5lbD5cbiAqICAgICAgPFBhbmVsIHBvc2l0aW9uPVwidG9wLXJpZ2h0XCI+dG9wLXJpZ2h0PC9QYW5lbD5cbiAqICAgICAgPFBhbmVsIHBvc2l0aW9uPVwiYm90dG9tLWxlZnRcIj5ib3R0b20tbGVmdDwvUGFuZWw+XG4gKiAgICAgIDxQYW5lbCBwb3NpdGlvbj1cImJvdHRvbS1jZW50ZXJcIj5ib3R0b20tY2VudGVyPC9QYW5lbD5cbiAqICAgICAgPFBhbmVsIHBvc2l0aW9uPVwiYm90dG9tLXJpZ2h0XCI+Ym90dG9tLXJpZ2h0PC9QYW5lbD5cbiAqICAgIDwvUmVhY3RGbG93PlxuICogICk7XG4gKn1cbiAqYGBgXG4gKi9cbmNvbnN0IFBhbmVsID0gZm9yd2FyZFJlZigoeyBwb3NpdGlvbiA9ICd0b3AtbGVmdCcsIGNoaWxkcmVuLCBjbGFzc05hbWUsIHN0eWxlLCAuLi5yZXN0IH0sIHJlZikgPT4ge1xuICAgIGNvbnN0IHBvaW50ZXJFdmVudHMgPSB1c2VTdG9yZShzZWxlY3RvciRuKTtcbiAgICBjb25zdCBwb3NpdGlvbkNsYXNzZXMgPSBgJHtwb3NpdGlvbn1gLnNwbGl0KCctJyk7XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fcGFuZWwnLCBjbGFzc05hbWUsIC4uLnBvc2l0aW9uQ2xhc3Nlc10pLCBzdHlsZTogeyAuLi5zdHlsZSwgcG9pbnRlckV2ZW50cyB9LCByZWY6IHJlZiwgLi4ucmVzdCwgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbn0pO1xuUGFuZWwuZGlzcGxheU5hbWUgPSAnUGFuZWwnO1xuXG5mdW5jdGlvbiBBdHRyaWJ1dGlvbih7IHByb09wdGlvbnMsIHBvc2l0aW9uID0gJ2JvdHRvbS1yaWdodCcgfSkge1xuICAgIGlmIChwcm9PcHRpb25zPy5oaWRlQXR0cmlidXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoanN4KFBhbmVsLCB7IHBvc2l0aW9uOiBwb3NpdGlvbiwgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2F0dHJpYnV0aW9uXCIsIFwiZGF0YS1tZXNzYWdlXCI6IFwiUGxlYXNlIG9ubHkgaGlkZSB0aGlzIGF0dHJpYnV0aW9uIHdoZW4geW91IGFyZSBzdWJzY3JpYmVkIHRvIFJlYWN0IEZsb3cgUHJvOiBodHRwczovL3Byby5yZWFjdGZsb3cuZGV2XCIsIGNoaWxkcmVuOiBqc3goXCJhXCIsIHsgaHJlZjogXCJodHRwczovL3JlYWN0Zmxvdy5kZXZcIiwgdGFyZ2V0OiBcIl9ibGFua1wiLCByZWw6IFwibm9vcGVuZXIgbm9yZWZlcnJlclwiLCBcImFyaWEtbGFiZWxcIjogXCJSZWFjdCBGbG93IGF0dHJpYnV0aW9uXCIsIGNoaWxkcmVuOiBcIlJlYWN0IEZsb3dcIiB9KSB9KSk7XG59XG5cbmNvbnN0IHNlbGVjdG9yJG0gPSAocykgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGVkTm9kZXMgPSBbXTtcbiAgICBjb25zdCBzZWxlY3RlZEVkZ2VzID0gW107XG4gICAgZm9yIChjb25zdCBbLCBub2RlXSBvZiBzLm5vZGVMb29rdXApIHtcbiAgICAgICAgaWYgKG5vZGUuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkTm9kZXMucHVzaChub2RlLmludGVybmFscy51c2VyTm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBbLCBlZGdlXSBvZiBzLmVkZ2VMb29rdXApIHtcbiAgICAgICAgaWYgKGVkZ2Uuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkRWRnZXMucHVzaChlZGdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBzZWxlY3RlZE5vZGVzLCBzZWxlY3RlZEVkZ2VzIH07XG59O1xuY29uc3Qgc2VsZWN0SWQgPSAob2JqKSA9PiBvYmouaWQ7XG5mdW5jdGlvbiBhcmVFcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIChzaGFsbG93KGEuc2VsZWN0ZWROb2Rlcy5tYXAoc2VsZWN0SWQpLCBiLnNlbGVjdGVkTm9kZXMubWFwKHNlbGVjdElkKSkgJiZcbiAgICAgICAgc2hhbGxvdyhhLnNlbGVjdGVkRWRnZXMubWFwKHNlbGVjdElkKSwgYi5zZWxlY3RlZEVkZ2VzLm1hcChzZWxlY3RJZCkpKTtcbn1cbmZ1bmN0aW9uIFNlbGVjdGlvbkxpc3RlbmVySW5uZXIoeyBvblNlbGVjdGlvbkNoYW5nZSwgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCB7IHNlbGVjdGVkTm9kZXMsIHNlbGVjdGVkRWRnZXMgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJG0sIGFyZUVxdWFsKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSB7IG5vZGVzOiBzZWxlY3RlZE5vZGVzLCBlZGdlczogc2VsZWN0ZWRFZGdlcyB9O1xuICAgICAgICBvblNlbGVjdGlvbkNoYW5nZT8uKHBhcmFtcyk7XG4gICAgICAgIHN0b3JlLmdldFN0YXRlKCkub25TZWxlY3Rpb25DaGFuZ2VIYW5kbGVycy5mb3JFYWNoKChmbikgPT4gZm4ocGFyYW1zKSk7XG4gICAgfSwgW3NlbGVjdGVkTm9kZXMsIHNlbGVjdGVkRWRnZXMsIG9uU2VsZWN0aW9uQ2hhbmdlXSk7XG4gICAgcmV0dXJuIG51bGw7XG59XG5jb25zdCBjaGFuZ2VTZWxlY3RvciA9IChzKSA9PiAhIXMub25TZWxlY3Rpb25DaGFuZ2VIYW5kbGVycztcbmZ1bmN0aW9uIFNlbGVjdGlvbkxpc3RlbmVyKHsgb25TZWxlY3Rpb25DaGFuZ2UsIH0pIHtcbiAgICBjb25zdCBzdG9yZUhhc1NlbGVjdGlvbkNoYW5nZUhhbmRsZXJzID0gdXNlU3RvcmUoY2hhbmdlU2VsZWN0b3IpO1xuICAgIGlmIChvblNlbGVjdGlvbkNoYW5nZSB8fCBzdG9yZUhhc1NlbGVjdGlvbkNoYW5nZUhhbmRsZXJzKSB7XG4gICAgICAgIHJldHVybiBqc3goU2VsZWN0aW9uTGlzdGVuZXJJbm5lciwgeyBvblNlbGVjdGlvbkNoYW5nZTogb25TZWxlY3Rpb25DaGFuZ2UgfSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5jb25zdCBkZWZhdWx0Tm9kZU9yaWdpbiA9IFswLCAwXTtcbmNvbnN0IGRlZmF1bHRWaWV3cG9ydCA9IHsgeDogMCwgeTogMCwgem9vbTogMSB9O1xuXG4vKlxuICogVGhpcyBjb21wb25lbnQgaGVscHMgdXMgdG8gdXBkYXRlIHRoZSBzdG9yZSB3aXRoIHRoZSB2YWx1ZXMgY29taW5nIGZyb20gdGhlIHVzZXIuXG4gKiBXZSBkaXN0aW5ndWlzaCBiZXR3ZWVuIHZhbHVlcyB3ZSBjYW4gdXBkYXRlIGRpcmVjdGx5IHdpdGggYHVzZURpcmVjdFN0b3JlVXBkYXRlcmAgKGxpa2UgYHNuYXBHcmlkYClcbiAqIGFuZCB2YWx1ZXMgdGhhdCBoYXZlIGEgZGVkaWNhdGVkIHNldHRlciBmdW5jdGlvbiBpbiB0aGUgc3RvcmUgKGxpa2UgYHNldE5vZGVzYCkuXG4gKi9cbi8vIFRoZXNlIGZpZWxkcyBleGlzdCBpbiB0aGUgZ2xvYmFsIHN0b3JlLCBhbmQgd2UgbmVlZCB0byBrZWVwIHRoZW0gdXAgdG8gZGF0ZVxuY29uc3QgcmVhY3RGbG93RmllbGRzVG9UcmFjayA9IFtcbiAgICAnbm9kZXMnLFxuICAgICdlZGdlcycsXG4gICAgJ2RlZmF1bHROb2RlcycsXG4gICAgJ2RlZmF1bHRFZGdlcycsXG4gICAgJ29uQ29ubmVjdCcsXG4gICAgJ29uQ29ubmVjdFN0YXJ0JyxcbiAgICAnb25Db25uZWN0RW5kJyxcbiAgICAnb25DbGlja0Nvbm5lY3RTdGFydCcsXG4gICAgJ29uQ2xpY2tDb25uZWN0RW5kJyxcbiAgICAnbm9kZXNEcmFnZ2FibGUnLFxuICAgICdhdXRvUGFuT25Ob2RlRm9jdXMnLFxuICAgICdub2Rlc0Nvbm5lY3RhYmxlJyxcbiAgICAnbm9kZXNGb2N1c2FibGUnLFxuICAgICdlZGdlc0ZvY3VzYWJsZScsXG4gICAgJ2VkZ2VzUmVjb25uZWN0YWJsZScsXG4gICAgJ2VsZXZhdGVOb2Rlc09uU2VsZWN0JyxcbiAgICAnZWxldmF0ZUVkZ2VzT25TZWxlY3QnLFxuICAgICdtaW5ab29tJyxcbiAgICAnbWF4Wm9vbScsXG4gICAgJ25vZGVFeHRlbnQnLFxuICAgICdvbk5vZGVzQ2hhbmdlJyxcbiAgICAnb25FZGdlc0NoYW5nZScsXG4gICAgJ2VsZW1lbnRzU2VsZWN0YWJsZScsXG4gICAgJ2Nvbm5lY3Rpb25Nb2RlJyxcbiAgICAnc25hcEdyaWQnLFxuICAgICdzbmFwVG9HcmlkJyxcbiAgICAndHJhbnNsYXRlRXh0ZW50JyxcbiAgICAnY29ubmVjdE9uQ2xpY2snLFxuICAgICdkZWZhdWx0RWRnZU9wdGlvbnMnLFxuICAgICdmaXRWaWV3JyxcbiAgICAnZml0Vmlld09wdGlvbnMnLFxuICAgICdvbk5vZGVzRGVsZXRlJyxcbiAgICAnb25FZGdlc0RlbGV0ZScsXG4gICAgJ29uRGVsZXRlJyxcbiAgICAnb25Ob2RlRHJhZycsXG4gICAgJ29uTm9kZURyYWdTdGFydCcsXG4gICAgJ29uTm9kZURyYWdTdG9wJyxcbiAgICAnb25TZWxlY3Rpb25EcmFnJyxcbiAgICAnb25TZWxlY3Rpb25EcmFnU3RhcnQnLFxuICAgICdvblNlbGVjdGlvbkRyYWdTdG9wJyxcbiAgICAnb25Nb3ZlU3RhcnQnLFxuICAgICdvbk1vdmUnLFxuICAgICdvbk1vdmVFbmQnLFxuICAgICdub1BhbkNsYXNzTmFtZScsXG4gICAgJ25vZGVPcmlnaW4nLFxuICAgICdhdXRvUGFuT25Db25uZWN0JyxcbiAgICAnYXV0b1Bhbk9uTm9kZURyYWcnLFxuICAgICdvbkVycm9yJyxcbiAgICAnY29ubmVjdGlvblJhZGl1cycsXG4gICAgJ2lzVmFsaWRDb25uZWN0aW9uJyxcbiAgICAnc2VsZWN0Tm9kZXNPbkRyYWcnLFxuICAgICdub2RlRHJhZ1RocmVzaG9sZCcsXG4gICAgJ29uQmVmb3JlRGVsZXRlJyxcbiAgICAnZGVidWcnLFxuICAgICdhdXRvUGFuU3BlZWQnLFxuICAgICdwYW5lQ2xpY2tEaXN0YW5jZScsXG4gICAgJ2FyaWFMYWJlbENvbmZpZycsXG5dO1xuLy8gcmZJZCBkb2Vzbid0IGV4aXN0IGluIFJlYWN0Rmxvd1Byb3BzLCBidXQgaXQncyBvbmUgb2YgdGhlIGZpZWxkcyB3ZSB3YW50IHRvIHVwZGF0ZVxuY29uc3QgZmllbGRzVG9UcmFjayA9IFsuLi5yZWFjdEZsb3dGaWVsZHNUb1RyYWNrLCAncmZJZCddO1xuY29uc3Qgc2VsZWN0b3IkbCA9IChzKSA9PiAoe1xuICAgIHNldE5vZGVzOiBzLnNldE5vZGVzLFxuICAgIHNldEVkZ2VzOiBzLnNldEVkZ2VzLFxuICAgIHNldE1pblpvb206IHMuc2V0TWluWm9vbSxcbiAgICBzZXRNYXhab29tOiBzLnNldE1heFpvb20sXG4gICAgc2V0VHJhbnNsYXRlRXh0ZW50OiBzLnNldFRyYW5zbGF0ZUV4dGVudCxcbiAgICBzZXROb2RlRXh0ZW50OiBzLnNldE5vZGVFeHRlbnQsXG4gICAgcmVzZXQ6IHMucmVzZXQsXG4gICAgc2V0RGVmYXVsdE5vZGVzQW5kRWRnZXM6IHMuc2V0RGVmYXVsdE5vZGVzQW5kRWRnZXMsXG4gICAgc2V0UGFuZUNsaWNrRGlzdGFuY2U6IHMuc2V0UGFuZUNsaWNrRGlzdGFuY2UsXG59KTtcbmNvbnN0IGluaXRQcmV2VmFsdWVzID0ge1xuICAgIC8qXG4gICAgICogdGhlc2UgYXJlIHZhbHVlcyB0aGF0IGFyZSBhbHNvIHBhc3NlZCBkaXJlY3RseSB0byBvdGhlciBjb21wb25lbnRzXG4gICAgICogdGhhbiB0aGUgU3RvcmVVcGRhdGVyLiBXZSBjYW4gcmVkdWNlIHRoZSBudW1iZXIgb2Ygc2V0U3RvcmUgY2FsbHNcbiAgICAgKiBieSBzZXR0aW5nIHRoZSBzYW1lIHZhbHVlcyBoZXJlIGFzIHByZXYgZmllbGRzLlxuICAgICAqL1xuICAgIHRyYW5zbGF0ZUV4dGVudDogaW5maW5pdGVFeHRlbnQsXG4gICAgbm9kZU9yaWdpbjogZGVmYXVsdE5vZGVPcmlnaW4sXG4gICAgbWluWm9vbTogMC41LFxuICAgIG1heFpvb206IDIsXG4gICAgZWxlbWVudHNTZWxlY3RhYmxlOiB0cnVlLFxuICAgIG5vUGFuQ2xhc3NOYW1lOiAnbm9wYW4nLFxuICAgIHJmSWQ6ICcxJyxcbiAgICBwYW5lQ2xpY2tEaXN0YW5jZTogMCxcbn07XG5mdW5jdGlvbiBTdG9yZVVwZGF0ZXIocHJvcHMpIHtcbiAgICBjb25zdCB7IHNldE5vZGVzLCBzZXRFZGdlcywgc2V0TWluWm9vbSwgc2V0TWF4Wm9vbSwgc2V0VHJhbnNsYXRlRXh0ZW50LCBzZXROb2RlRXh0ZW50LCByZXNldCwgc2V0RGVmYXVsdE5vZGVzQW5kRWRnZXMsIHNldFBhbmVDbGlja0Rpc3RhbmNlLCB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkbCwgc2hhbGxvdyk7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHNldERlZmF1bHROb2Rlc0FuZEVkZ2VzKHByb3BzLmRlZmF1bHROb2RlcywgcHJvcHMuZGVmYXVsdEVkZ2VzKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIC8vIHdoZW4gd2UgcmVzZXQgdGhlIHN0b3JlIHdlIGFsc28gbmVlZCB0byByZXNldCB0aGUgcHJldmlvdXMgZmllbGRzXG4gICAgICAgICAgICBwcmV2aW91c0ZpZWxkcy5jdXJyZW50ID0gaW5pdFByZXZWYWx1ZXM7XG4gICAgICAgICAgICByZXNldCgpO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBwcmV2aW91c0ZpZWxkcyA9IHVzZVJlZihpbml0UHJldlZhbHVlcyk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZE5hbWUgb2YgZmllbGRzVG9UcmFjaykge1xuICAgICAgICAgICAgY29uc3QgZmllbGRWYWx1ZSA9IHByb3BzW2ZpZWxkTmFtZV07XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c0ZpZWxkVmFsdWUgPSBwcmV2aW91c0ZpZWxkcy5jdXJyZW50W2ZpZWxkTmFtZV07XG4gICAgICAgICAgICBpZiAoZmllbGRWYWx1ZSA9PT0gcHJldmlvdXNGaWVsZFZhbHVlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wc1tmaWVsZE5hbWVdID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIC8vIEN1c3RvbSBoYW5kbGluZyB3aXRoIGRlZGljYXRlZCBzZXR0ZXJzIGZvciBzb21lIGZpZWxkc1xuICAgICAgICAgICAgaWYgKGZpZWxkTmFtZSA9PT0gJ25vZGVzJylcbiAgICAgICAgICAgICAgICBzZXROb2RlcyhmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkTmFtZSA9PT0gJ2VkZ2VzJylcbiAgICAgICAgICAgICAgICBzZXRFZGdlcyhmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkTmFtZSA9PT0gJ21pblpvb20nKVxuICAgICAgICAgICAgICAgIHNldE1pblpvb20oZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZE5hbWUgPT09ICdtYXhab29tJylcbiAgICAgICAgICAgICAgICBzZXRNYXhab29tKGZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGROYW1lID09PSAndHJhbnNsYXRlRXh0ZW50JylcbiAgICAgICAgICAgICAgICBzZXRUcmFuc2xhdGVFeHRlbnQoZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZE5hbWUgPT09ICdub2RlRXh0ZW50JylcbiAgICAgICAgICAgICAgICBzZXROb2RlRXh0ZW50KGZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGROYW1lID09PSAncGFuZUNsaWNrRGlzdGFuY2UnKVxuICAgICAgICAgICAgICAgIHNldFBhbmVDbGlja0Rpc3RhbmNlKGZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgLy8gUmVuYW1lZCBmaWVsZHNcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkTmFtZSA9PT0gJ2ZpdFZpZXcnKVxuICAgICAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgZml0Vmlld1F1ZXVlZDogZmllbGRWYWx1ZSB9KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkTmFtZSA9PT0gJ2ZpdFZpZXdPcHRpb25zJylcbiAgICAgICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IGZpdFZpZXdPcHRpb25zOiBmaWVsZFZhbHVlIH0pO1xuICAgICAgICAgICAgaWYgKGZpZWxkTmFtZSA9PT0gJ2FyaWFMYWJlbENvbmZpZycpIHtcbiAgICAgICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IGFyaWFMYWJlbENvbmZpZzogbWVyZ2VBcmlhTGFiZWxDb25maWcoZmllbGRWYWx1ZSkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZW5lcmFsIGNhc2VcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IFtmaWVsZE5hbWVdOiBmaWVsZFZhbHVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzRmllbGRzLmN1cnJlbnQgPSBwcm9wcztcbiAgICB9LCBcbiAgICAvLyBPbmx5IHJlLXJ1biB0aGUgZWZmZWN0IGlmIG9uZSBvZiB0aGUgZmllbGRzIHdlIHRyYWNrIGNoYW5nZXNcbiAgICBmaWVsZHNUb1RyYWNrLm1hcCgoZmllbGROYW1lKSA9PiBwcm9wc1tmaWVsZE5hbWVdKSk7XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldE1lZGlhUXVlcnkoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICF3aW5kb3cubWF0Y2hNZWRpYSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHdpbmRvdy5tYXRjaE1lZGlhKCcocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspJyk7XG59XG4vKipcbiAqIEhvb2sgZm9yIHJlY2VpdmluZyB0aGUgY3VycmVudCBjb2xvciBtb2RlIGNsYXNzICdkYXJrJyBvciAnbGlnaHQnLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIGNvbG9yTW9kZSAtIFRoZSBjb2xvciBtb2RlIHRvIHVzZSAoJ2RhcmsnLCAnbGlnaHQnIG9yICdzeXN0ZW0nKVxuICovXG5mdW5jdGlvbiB1c2VDb2xvck1vZGVDbGFzcyhjb2xvck1vZGUpIHtcbiAgICBjb25zdCBbY29sb3JNb2RlQ2xhc3MsIHNldENvbG9yTW9kZUNsYXNzXSA9IHVzZVN0YXRlKGNvbG9yTW9kZSA9PT0gJ3N5c3RlbScgPyBudWxsIDogY29sb3JNb2RlKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoY29sb3JNb2RlICE9PSAnc3lzdGVtJykge1xuICAgICAgICAgICAgc2V0Q29sb3JNb2RlQ2xhc3MoY29sb3JNb2RlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZWRpYVF1ZXJ5ID0gZ2V0TWVkaWFRdWVyeSgpO1xuICAgICAgICBjb25zdCB1cGRhdGVDb2xvck1vZGVDbGFzcyA9ICgpID0+IHNldENvbG9yTW9kZUNsYXNzKG1lZGlhUXVlcnk/Lm1hdGNoZXMgPyAnZGFyaycgOiAnbGlnaHQnKTtcbiAgICAgICAgdXBkYXRlQ29sb3JNb2RlQ2xhc3MoKTtcbiAgICAgICAgbWVkaWFRdWVyeT8uYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdXBkYXRlQ29sb3JNb2RlQ2xhc3MpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgbWVkaWFRdWVyeT8ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdXBkYXRlQ29sb3JNb2RlQ2xhc3MpO1xuICAgICAgICB9O1xuICAgIH0sIFtjb2xvck1vZGVdKTtcbiAgICByZXR1cm4gY29sb3JNb2RlQ2xhc3MgIT09IG51bGwgPyBjb2xvck1vZGVDbGFzcyA6IGdldE1lZGlhUXVlcnkoKT8ubWF0Y2hlcyA/ICdkYXJrJyA6ICdsaWdodCc7XG59XG5cbmNvbnN0IGRlZmF1bHREb2MgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiBudWxsO1xuLyoqXG4gKiBUaGlzIGhvb2sgbGV0cyB5b3UgbGlzdGVuIGZvciBzcGVjaWZpYyBrZXkgY29kZXMgYW5kIHRlbGxzIHlvdSB3aGV0aGVyIHRoZXkgYXJlXG4gKiBjdXJyZW50bHkgcHJlc3NlZCBvciBub3QuXG4gKlxuICogQHB1YmxpY1xuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICppbXBvcnQgeyB1c2VLZXlQcmVzcyB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCkge1xuICogIGNvbnN0IHNwYWNlUHJlc3NlZCA9IHVzZUtleVByZXNzKCdTcGFjZScpO1xuICogIGNvbnN0IGNtZEFuZFNQcmVzc2VkID0gdXNlS2V5UHJlc3MoWydNZXRhK3MnLCAnU3RyZytzJ10pO1xuICpcbiAqICByZXR1cm4gKFxuICogICAgPGRpdj5cbiAqICAgICB7c3BhY2VQcmVzc2VkICYmIDxwPlNwYWNlIHByZXNzZWQhPC9wPn1cbiAqICAgICB7Y21kQW5kU1ByZXNzZWQgJiYgPHA+Q21kICsgUyBwcmVzc2VkITwvcD59XG4gKiAgICA8L2Rpdj5cbiAqICApO1xuICp9XG4gKmBgYFxuICovXG5mdW5jdGlvbiB1c2VLZXlQcmVzcyhcbi8qKlxuICogVGhlIGtleSBjb2RlIChzdHJpbmcgb3IgYXJyYXkgb2Ygc3RyaW5ncykgc3BlY2lmaWVzIHdoaWNoIGtleShzKSBzaG91bGQgdHJpZ2dlclxuICogYW4gYWN0aW9uLlxuICpcbiAqIEEgKipzdHJpbmcqKiBjYW4gcmVwcmVzZW50OlxuICogLSBBICoqc2luZ2xlIGtleSoqLCBlLmcuIGAnYSdgXG4gKiAtIEEgKiprZXkgY29tYmluYXRpb24qKiwgdXNpbmcgYCcrJ2AgdG8gc2VwYXJhdGUga2V5cywgZS5nLiBgJ2ErZCdgXG4gKlxuICogQW4gICoqYXJyYXkgb2Ygc3RyaW5ncyoqIHJlcHJlc2VudHMgKiptdWx0aXBsZSBwb3NzaWJsZSBrZXkgaW5wdXRzKiouIEZvciBleGFtcGxlLCBgWydhJywgJ2QrcyddYFxuICogbWVhbnMgdGhlIHVzZXIgY2FuIHByZXNzIGVpdGhlciB0aGUgc2luZ2xlIGtleSBgJ2EnYCBvciB0aGUgY29tYmluYXRpb24gb2YgYCdkJ2AgYW5kIGAncydgLlxuICogQGRlZmF1bHQgbnVsbFxuICovXG5rZXlDb2RlID0gbnVsbCwgb3B0aW9ucyA9IHsgdGFyZ2V0OiBkZWZhdWx0RG9jLCBhY3RJbnNpZGVJbnB1dFdpdGhNb2RpZmllcjogdHJ1ZSB9KSB7XG4gICAgY29uc3QgW2tleVByZXNzZWQsIHNldEtleVByZXNzZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIC8vIHdlIG5lZWQgdG8gcmVtZW1iZXIgaWYgYSBtb2RpZmllciBrZXkgaXMgcHJlc3NlZCBpbiBvcmRlciB0byB0cmFjayBpdFxuICAgIGNvbnN0IG1vZGlmaWVyUHJlc3NlZCA9IHVzZVJlZihmYWxzZSk7XG4gICAgLy8gd2UgbmVlZCB0byByZW1lbWJlciB0aGUgcHJlc3NlZCBrZXlzIGluIG9yZGVyIHRvIHN1cHBvcnQgY29tYmluYXRpb25zXG4gICAgY29uc3QgcHJlc3NlZEtleXMgPSB1c2VSZWYobmV3IFNldChbXSkpO1xuICAgIC8qXG4gICAgICoga2V5Q29kZXMgPSBhcnJheSB3aXRoIHNpbmdsZSBrZXlzIFtbJ2EnXV0gb3Iga2V5IGNvbWJpbmF0aW9ucyBbWydhJywgJ3MnXV1cbiAgICAgKiBrZXlzVG9XYXRjaCA9IGFycmF5IHdpdGggYWxsIGtleXMgZmxhdHRlbmVkIFsnYScsICdkJywgJ1NoaWZ0TGVmdCddXG4gICAgICogdXNlZCB0byBjaGVjayBpZiB3ZSBzdG9yZSBldmVudC5jb2RlIG9yIGV2ZW50LmtleS4gV2hlbiB0aGUgY29kZSBpcyBpbiB0aGUgbGlzdCBvZiBrZXlzVG9XYXRjaFxuICAgICAqIHdlIHVzZSB0aGUgY29kZSBvdGhlcndpc2UgdGhlIGtleS4gRXhwbGFpbmVyOiBXaGVuIHlvdSBwcmVzcyB0aGUgbGVmdCBcImNvbW1hbmRcIiBrZXksIHRoZSBjb2RlIGlzIFwiTWV0YUxlZnRcIlxuICAgICAqIGFuZCB0aGUga2V5IGlzIFwiTWV0YVwiLiBXZSB3YW50IHVzZXJzIHRvIGJlIGFibGUgdG8gcGFzcyBrZXlzIGFuZCBjb2RlcyBzbyB3ZSBhc3N1bWUgdGhhdCB0aGUga2V5IGlzIG1lYW50IHdoZW5cbiAgICAgKiB3ZSBjYW4ndCBmaW5kIGl0IGluIHRoZSBsaXN0IG9mIGtleXNUb1dhdGNoLlxuICAgICAqL1xuICAgIGNvbnN0IFtrZXlDb2Rlcywga2V5c1RvV2F0Y2hdID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmIChrZXlDb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlDb2RlQXJyID0gQXJyYXkuaXNBcnJheShrZXlDb2RlKSA/IGtleUNvZGUgOiBba2V5Q29kZV07XG4gICAgICAgICAgICBjb25zdCBrZXlzID0ga2V5Q29kZUFyclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKGtjKSA9PiB0eXBlb2Yga2MgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogd2UgZmlyc3QgcmVwbGFjZSBhbGwgJysnIHdpdGggJ1xcbicgIHdoaWNoIHdlIHdpbGwgdXNlIHRvIHNwbGl0IHRoZSBrZXlzIG9uXG4gICAgICAgICAgICAgICAgICogdGhlbiB3ZSByZXBsYWNlICdcXG5cXG4nIHdpdGggJ1xcbisnLCB0aGlzIHdheSB3ZSBjYW4gYWxzbyBzdXBwb3J0IHRoZSBjb21iaW5hdGlvbiAna2V5KysnXG4gICAgICAgICAgICAgICAgICogaW4gdGhlIGVuZCB3ZSBzaW1wbHkgc3BsaXQgb24gJ1xcbicgdG8gZ2V0IHRoZSBrZXkgYXJyYXlcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAubWFwKChrYykgPT4ga2MucmVwbGFjZSgnKycsICdcXG4nKS5yZXBsYWNlKCdcXG5cXG4nLCAnXFxuKycpLnNwbGl0KCdcXG4nKSk7XG4gICAgICAgICAgICBjb25zdCBrZXlzRmxhdCA9IGtleXMucmVkdWNlKChyZXMsIGl0ZW0pID0+IHJlcy5jb25jYXQoLi4uaXRlbSksIFtdKTtcbiAgICAgICAgICAgIHJldHVybiBba2V5cywga2V5c0ZsYXRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbW10sIFtdXTtcbiAgICB9LCBba2V5Q29kZV0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IG9wdGlvbnM/LnRhcmdldCA/PyBkZWZhdWx0RG9jO1xuICAgICAgICBjb25zdCBhY3RJbnNpZGVJbnB1dFdpdGhNb2RpZmllciA9IG9wdGlvbnM/LmFjdEluc2lkZUlucHV0V2l0aE1vZGlmaWVyID8/IHRydWU7XG4gICAgICAgIGlmIChrZXlDb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBkb3duSGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIG1vZGlmaWVyUHJlc3NlZC5jdXJyZW50ID0gZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5IHx8IGV2ZW50LnNoaWZ0S2V5IHx8IGV2ZW50LmFsdEtleTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2ZW50QWN0aW9uID0gKCFtb2RpZmllclByZXNzZWQuY3VycmVudCB8fCAobW9kaWZpZXJQcmVzc2VkLmN1cnJlbnQgJiYgIWFjdEluc2lkZUlucHV0V2l0aE1vZGlmaWVyKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNJbnB1dERPTU5vZGUoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2ZW50QWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5T3JDb2RlID0gdXNlS2V5T3JDb2RlKGV2ZW50LmNvZGUsIGtleXNUb1dhdGNoKTtcbiAgICAgICAgICAgICAgICBwcmVzc2VkS2V5cy5jdXJyZW50LmFkZChldmVudFtrZXlPckNvZGVdKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNNYXRjaGluZ0tleShrZXlDb2RlcywgcHJlc3NlZEtleXMuY3VycmVudCwgZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IChldmVudC5jb21wb3NlZFBhdGg/LigpPy5bMF0gfHwgZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNJbnRlcmFjdGl2ZUVsZW1lbnQgPSB0YXJnZXQ/Lm5vZGVOYW1lID09PSAnQlVUVE9OJyB8fCB0YXJnZXQ/Lm5vZGVOYW1lID09PSAnQSc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnByZXZlbnREZWZhdWx0ICE9PSBmYWxzZSAmJiAobW9kaWZpZXJQcmVzc2VkLmN1cnJlbnQgfHwgIWlzSW50ZXJhY3RpdmVFbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXRLZXlQcmVzc2VkKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCB1cEhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlPckNvZGUgPSB1c2VLZXlPckNvZGUoZXZlbnQuY29kZSwga2V5c1RvV2F0Y2gpO1xuICAgICAgICAgICAgICAgIGlmIChpc01hdGNoaW5nS2V5KGtleUNvZGVzLCBwcmVzc2VkS2V5cy5jdXJyZW50LCB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRLZXlQcmVzc2VkKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgcHJlc3NlZEtleXMuY3VycmVudC5jbGVhcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlc3NlZEtleXMuY3VycmVudC5kZWxldGUoZXZlbnRba2V5T3JDb2RlXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGZpeCBmb3IgTWFjOiB3aGVuIGNtZCBrZXkgaXMgcHJlc3NlZCwga2V5dXAgaXMgbm90IHRyaWdnZXJlZCBmb3IgYW55IG90aGVyIGtleSwgc2VlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNzM4MDAxOC93aGVuLWNtZC1rZXktaXMta2VwdC1wcmVzc2VkLWtleXVwLWlzLW5vdC10cmlnZ2VyZWQtZm9yLWFueS1vdGhlci1rZXlcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnTWV0YScpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlc3NlZEtleXMuY3VycmVudC5jbGVhcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtb2RpZmllclByZXNzZWQuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHJlc2V0SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBwcmVzc2VkS2V5cy5jdXJyZW50LmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgc2V0S2V5UHJlc3NlZChmYWxzZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGFyZ2V0Py5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZG93bkhhbmRsZXIpO1xuICAgICAgICAgICAgdGFyZ2V0Py5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHVwSGFuZGxlcik7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIHJlc2V0SGFuZGxlcik7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCByZXNldEhhbmRsZXIpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ/LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBkb3duSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Py5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIHVwSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCByZXNldEhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHJlc2V0SGFuZGxlcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSwgW2tleUNvZGUsIHNldEtleVByZXNzZWRdKTtcbiAgICByZXR1cm4ga2V5UHJlc3NlZDtcbn1cbi8vIHV0aWxzXG5mdW5jdGlvbiBpc01hdGNoaW5nS2V5KGtleUNvZGVzLCBwcmVzc2VkS2V5cywgaXNVcCkge1xuICAgIHJldHVybiAoa2V5Q29kZXNcbiAgICAgICAgLypcbiAgICAgICAgICogd2Ugb25seSB3YW50IHRvIGNvbXBhcmUgc2FtZSBzaXplcyBvZiBrZXlDb2RlIGRlZmluaXRpb25zXG4gICAgICAgICAqIGFuZCBwcmVzc2VkIGtleXMuIFdoZW4gdGhlIHVzZXIgc3BlY2lmaWVkICdNZXRhJyBhcyBhIGtleSBzb21ld2hlcmVcbiAgICAgICAgICogdGhpcyB3b3VsZCBhbHNvIGJlIHRydXRoeSB3aXRob3V0IHRoaXMgZmlsdGVyIHdoZW4gdXNlciBwcmVzc2VzICdNZXRhJyArICdyJ1xuICAgICAgICAgKi9cbiAgICAgICAgLmZpbHRlcigoa2V5cykgPT4gaXNVcCB8fCBrZXlzLmxlbmd0aCA9PT0gcHJlc3NlZEtleXMuc2l6ZSlcbiAgICAgICAgLypcbiAgICAgICAgICogc2luY2Ugd2Ugd2FudCB0byBzdXBwb3J0IG11bHRpcGxlIHBvc3NpYmlsaXRpZXMgb25seSBvbmUgb2YgdGhlXG4gICAgICAgICAqIGNvbWJpbmF0aW9ucyBuZWVkIHRvIGJlIHBhcnQgb2YgdGhlIHByZXNzZWQga2V5c1xuICAgICAgICAgKi9cbiAgICAgICAgLnNvbWUoKGtleXMpID0+IGtleXMuZXZlcnkoKGspID0+IHByZXNzZWRLZXlzLmhhcyhrKSkpKTtcbn1cbmZ1bmN0aW9uIHVzZUtleU9yQ29kZShldmVudENvZGUsIGtleXNUb1dhdGNoKSB7XG4gICAgcmV0dXJuIGtleXNUb1dhdGNoLmluY2x1ZGVzKGV2ZW50Q29kZSkgPyAnY29kZScgOiAna2V5Jztcbn1cblxuLyoqXG4gKiBIb29rIGZvciBnZXR0aW5nIHZpZXdwb3J0IGhlbHBlciBmdW5jdGlvbnMuXG4gKlxuICogQGludGVybmFsXG4gKiBAcmV0dXJucyB2aWV3cG9ydCBoZWxwZXIgZnVuY3Rpb25zXG4gKi9cbmNvbnN0IHVzZVZpZXdwb3J0SGVscGVyID0gKCkgPT4ge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICByZXR1cm4gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB6b29tSW46IChvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYW5ab29tIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYW5ab29tID8gcGFuWm9vbS5zY2FsZUJ5KDEuMiwgeyBkdXJhdGlvbjogb3B0aW9ucz8uZHVyYXRpb24gfSkgOiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHpvb21PdXQ6IChvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYW5ab29tIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYW5ab29tID8gcGFuWm9vbS5zY2FsZUJ5KDEgLyAxLjIsIHsgZHVyYXRpb246IG9wdGlvbnM/LmR1cmF0aW9uIH0pIDogUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB6b29tVG86ICh6b29tTGV2ZWwsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHBhblpvb20gfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhblpvb20gPyBwYW5ab29tLnNjYWxlVG8oem9vbUxldmVsLCB7IGR1cmF0aW9uOiBvcHRpb25zPy5kdXJhdGlvbiB9KSA6IFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0Wm9vbTogKCkgPT4gc3RvcmUuZ2V0U3RhdGUoKS50cmFuc2Zvcm1bMl0sXG4gICAgICAgICAgICBzZXRWaWV3cG9ydDogYXN5bmMgKHZpZXdwb3J0LCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB0cmFuc2Zvcm06IFt0WCwgdFksIHRab29tXSwgcGFuWm9vbSwgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYW5ab29tKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhd2FpdCBwYW5ab29tLnNldFZpZXdwb3J0KHtcbiAgICAgICAgICAgICAgICAgICAgeDogdmlld3BvcnQueCA/PyB0WCxcbiAgICAgICAgICAgICAgICAgICAgeTogdmlld3BvcnQueSA/PyB0WSxcbiAgICAgICAgICAgICAgICAgICAgem9vbTogdmlld3BvcnQuem9vbSA/PyB0Wm9vbSxcbiAgICAgICAgICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFZpZXdwb3J0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3gsIHksIHpvb21dID0gc3RvcmUuZ2V0U3RhdGUoKS50cmFuc2Zvcm07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSwgem9vbSB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldENlbnRlcjogYXN5bmMgKHgsIHksIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RvcmUuZ2V0U3RhdGUoKS5zZXRDZW50ZXIoeCwgeSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZml0Qm91bmRzOiBhc3luYyAoYm91bmRzLCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCBtaW5ab29tLCBtYXhab29tLCBwYW5ab29tIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXdwb3J0ID0gZ2V0Vmlld3BvcnRGb3JCb3VuZHMoYm91bmRzLCB3aWR0aCwgaGVpZ2h0LCBtaW5ab29tLCBtYXhab29tLCBvcHRpb25zPy5wYWRkaW5nID8/IDAuMSk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYW5ab29tKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhd2FpdCBwYW5ab29tLnNldFZpZXdwb3J0KHZpZXdwb3J0LCB7XG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBvcHRpb25zPy5kdXJhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgZWFzZTogb3B0aW9ucz8uZWFzZSxcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJwb2xhdGU6IG9wdGlvbnM/LmludGVycG9sYXRlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2NyZWVuVG9GbG93UG9zaXRpb246IChjbGllbnRQb3NpdGlvbiwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB0cmFuc2Zvcm0sIHNuYXBHcmlkLCBzbmFwVG9HcmlkLCBkb21Ob2RlIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGlmICghZG9tTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xpZW50UG9zaXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgeDogZG9tWCwgeTogZG9tWSB9ID0gZG9tTm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb3JyZWN0ZWRQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogY2xpZW50UG9zaXRpb24ueCAtIGRvbVgsXG4gICAgICAgICAgICAgICAgICAgIHk6IGNsaWVudFBvc2l0aW9uLnkgLSBkb21ZLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgX3NuYXBHcmlkID0gb3B0aW9ucy5zbmFwR3JpZCA/PyBzbmFwR3JpZDtcbiAgICAgICAgICAgICAgICBjb25zdCBfc25hcFRvR3JpZCA9IG9wdGlvbnMuc25hcFRvR3JpZCA/PyBzbmFwVG9HcmlkO1xuICAgICAgICAgICAgICAgIHJldHVybiBwb2ludFRvUmVuZGVyZXJQb2ludChjb3JyZWN0ZWRQb3NpdGlvbiwgdHJhbnNmb3JtLCBfc25hcFRvR3JpZCwgX3NuYXBHcmlkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmbG93VG9TY3JlZW5Qb3NpdGlvbjogKGZsb3dQb3NpdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdHJhbnNmb3JtLCBkb21Ob2RlIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGlmICghZG9tTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmxvd1Bvc2l0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IHg6IGRvbVgsIHk6IGRvbVkgfSA9IGRvbU5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVuZGVyZXJQb3NpdGlvbiA9IHJlbmRlcmVyUG9pbnRUb1BvaW50KGZsb3dQb3NpdGlvbiwgdHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB4OiByZW5kZXJlclBvc2l0aW9uLnggKyBkb21YLFxuICAgICAgICAgICAgICAgICAgICB5OiByZW5kZXJlclBvc2l0aW9uLnkgKyBkb21ZLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbn07XG5cbi8qXG4gKiBUaGlzIGZ1bmN0aW9uIGFwcGxpZXMgY2hhbmdlcyB0byBub2RlcyBvciBlZGdlcyB0aGF0IGFyZSB0cmlnZ2VyZWQgYnkgUmVhY3QgRmxvdyBpbnRlcm5hbGx5LlxuICogV2hlbiB5b3UgZHJhZyBhIG5vZGUgZm9yIGV4YW1wbGUsIFJlYWN0IEZsb3cgd2lsbCBzZW5kIGEgcG9zaXRpb24gY2hhbmdlIHVwZGF0ZS5cbiAqIFRoaXMgZnVuY3Rpb24gdGhlbiBhcHBsaWVzIHRoZSBjaGFuZ2VzIGFuZCByZXR1cm5zIHRoZSB1cGRhdGVkIGVsZW1lbnRzLlxuICovXG5mdW5jdGlvbiBhcHBseUNoYW5nZXMoY2hhbmdlcywgZWxlbWVudHMpIHtcbiAgICBjb25zdCB1cGRhdGVkRWxlbWVudHMgPSBbXTtcbiAgICAvKlxuICAgICAqIEJ5IHN0b3JpbmcgYSBtYXAgb2YgY2hhbmdlcyBmb3IgZWFjaCBlbGVtZW50LCB3ZSBjYW4gYSBxdWljayBsb29rdXAgYXMgd2VcbiAgICAgKiBpdGVyYXRlIG92ZXIgdGhlIGVsZW1lbnRzIGFycmF5IVxuICAgICAqL1xuICAgIGNvbnN0IGNoYW5nZXNNYXAgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgYWRkSXRlbUNoYW5nZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGNoYW5nZSBvZiBjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2UudHlwZSA9PT0gJ2FkZCcpIHtcbiAgICAgICAgICAgIGFkZEl0ZW1DaGFuZ2VzLnB1c2goY2hhbmdlKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYW5nZS50eXBlID09PSAncmVtb3ZlJyB8fCBjaGFuZ2UudHlwZSA9PT0gJ3JlcGxhY2UnKSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogRm9yIGEgJ3JlbW92ZScgY2hhbmdlIHdlIGNhbiBzYWZlbHkgaWdub3JlIGFueSBvdGhlciBjaGFuZ2VzIHF1ZXVlZCBmb3JcbiAgICAgICAgICAgICAqIHRoZSBzYW1lIGVsZW1lbnQsIGl0J3MgZ29pbmcgdG8gYmUgcmVtb3ZlZCBhbnl3YXkhXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNoYW5nZXNNYXAuc2V0KGNoYW5nZS5pZCwgW2NoYW5nZV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudENoYW5nZXMgPSBjaGFuZ2VzTWFwLmdldChjaGFuZ2UuaWQpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnRDaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBJZiB3ZSBoYXZlIHNvbWUgY2hhbmdlcyBxdWV1ZWQgYWxyZWFkeSwgd2UgY2FuIGRvIGEgbXV0YWJsZSB1cGRhdGUgb2ZcbiAgICAgICAgICAgICAgICAgKiB0aGF0IGFycmF5IGFuZCBzYXZlIG91cnNlbHZlcyBzb21lIGNvcHlpbmcuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZWxlbWVudENoYW5nZXMucHVzaChjaGFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlc01hcC5zZXQoY2hhbmdlLmlkLCBbY2hhbmdlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgIGNvbnN0IGNoYW5nZXMgPSBjaGFuZ2VzTWFwLmdldChlbGVtZW50LmlkKTtcbiAgICAgICAgLypcbiAgICAgICAgICogV2hlbiB0aGVyZSBhcmUgbm8gY2hhbmdlcyBmb3IgYW4gZWxlbWVudCB3ZSBjYW4ganVzdCBwdXNoIGl0IHVubW9kaWZpZWQsXG4gICAgICAgICAqIG5vIG5lZWQgdG8gY29weSBpdC5cbiAgICAgICAgICovXG4gICAgICAgIGlmICghY2hhbmdlcykge1xuICAgICAgICAgICAgdXBkYXRlZEVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgJ3JlbW92ZScgY2hhbmdlIHF1ZXVlZCwgaXQnbGwgYmUgdGhlIG9ubHkgY2hhbmdlIGluIHRoZSBhcnJheVxuICAgICAgICBpZiAoY2hhbmdlc1swXS50eXBlID09PSAncmVtb3ZlJykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXNbMF0udHlwZSA9PT0gJ3JlcGxhY2UnKSB7XG4gICAgICAgICAgICB1cGRhdGVkRWxlbWVudHMucHVzaCh7IC4uLmNoYW5nZXNbMF0uaXRlbSB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3Igb3RoZXIgdHlwZXMgb2YgY2hhbmdlcywgd2Ugd2FudCB0byBzdGFydCB3aXRoIGEgc2hhbGxvdyBjb3B5IG9mIHRoZVxuICAgICAgICAgKiBvYmplY3Qgc28gUmVhY3Qga25vd3MgdGhpcyBlbGVtZW50IGhhcyBjaGFuZ2VkLiBTZXF1ZW50aWFsIGNoYW5nZXMgd2lsbFxuICAgICAgICAgKiBlYWNoIF9tdXRhdGVfIHRoaXMgb2JqZWN0LCBzbyB0aGVyZSdzIG9ubHkgZXZlciBvbmUgY29weS5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHVwZGF0ZWRFbGVtZW50ID0geyAuLi5lbGVtZW50IH07XG4gICAgICAgIGZvciAoY29uc3QgY2hhbmdlIG9mIGNoYW5nZXMpIHtcbiAgICAgICAgICAgIGFwcGx5Q2hhbmdlKGNoYW5nZSwgdXBkYXRlZEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZWRFbGVtZW50cy5wdXNoKHVwZGF0ZWRFbGVtZW50KTtcbiAgICB9XG4gICAgLypcbiAgICAgKiB3ZSBuZWVkIHRvIHdhaXQgZm9yIGFsbCBjaGFuZ2VzIHRvIGJlIGFwcGxpZWQgYmVmb3JlIGFkZGluZyBuZXcgaXRlbXNcbiAgICAgKiB0byBiZSBhYmxlIHRvIGFkZCB0aGVtIGF0IHRoZSBjb3JyZWN0IGluZGV4XG4gICAgICovXG4gICAgaWYgKGFkZEl0ZW1DaGFuZ2VzLmxlbmd0aCkge1xuICAgICAgICBhZGRJdGVtQ2hhbmdlcy5mb3JFYWNoKChjaGFuZ2UpID0+IHtcbiAgICAgICAgICAgIGlmIChjaGFuZ2UuaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZWRFbGVtZW50cy5zcGxpY2UoY2hhbmdlLmluZGV4LCAwLCB7IC4uLmNoYW5nZS5pdGVtIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlZEVsZW1lbnRzLnB1c2goeyAuLi5jaGFuZ2UuaXRlbSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB1cGRhdGVkRWxlbWVudHM7XG59XG4vLyBBcHBsaWVzIGEgc2luZ2xlIGNoYW5nZSB0byBhbiBlbGVtZW50LiBUaGlzIGlzIGEgKm11dGFibGUqIHVwZGF0ZS5cbmZ1bmN0aW9uIGFwcGx5Q2hhbmdlKGNoYW5nZSwgZWxlbWVudCkge1xuICAgIHN3aXRjaCAoY2hhbmdlLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnc2VsZWN0Jzoge1xuICAgICAgICAgICAgZWxlbWVudC5zZWxlY3RlZCA9IGNoYW5nZS5zZWxlY3RlZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3Bvc2l0aW9uJzoge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGFuZ2UucG9zaXRpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5wb3NpdGlvbiA9IGNoYW5nZS5wb3NpdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hhbmdlLmRyYWdnaW5nICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuZHJhZ2dpbmcgPSBjaGFuZ2UuZHJhZ2dpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdkaW1lbnNpb25zJzoge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGFuZ2UuZGltZW5zaW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50Lm1lYXN1cmVkID8/PSB7fTtcbiAgICAgICAgICAgICAgICBlbGVtZW50Lm1lYXN1cmVkLndpZHRoID0gY2hhbmdlLmRpbWVuc2lvbnMud2lkdGg7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5tZWFzdXJlZC5oZWlnaHQgPSBjaGFuZ2UuZGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZS5zZXRBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2Uuc2V0QXR0cmlidXRlcyA9PT0gdHJ1ZSB8fCBjaGFuZ2Uuc2V0QXR0cmlidXRlcyA9PT0gJ3dpZHRoJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC53aWR0aCA9IGNoYW5nZS5kaW1lbnNpb25zLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2Uuc2V0QXR0cmlidXRlcyA9PT0gdHJ1ZSB8fCBjaGFuZ2Uuc2V0QXR0cmlidXRlcyA9PT0gJ2hlaWdodCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuaGVpZ2h0ID0gY2hhbmdlLmRpbWVuc2lvbnMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGFuZ2UucmVzaXppbmcgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQucmVzaXppbmcgPSBjaGFuZ2UucmVzaXppbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogRHJvcCBpbiBmdW5jdGlvbiB0aGF0IGFwcGxpZXMgbm9kZSBjaGFuZ2VzIHRvIGFuIGFycmF5IG9mIG5vZGVzLlxuICogQHB1YmxpY1xuICogQHBhcmFtIGNoYW5nZXMgLSBBcnJheSBvZiBjaGFuZ2VzIHRvIGFwcGx5LlxuICogQHBhcmFtIG5vZGVzIC0gQXJyYXkgb2Ygbm9kZXMgdG8gYXBwbHkgdGhlIGNoYW5nZXMgdG8uXG4gKiBAcmV0dXJucyBBcnJheSBvZiB1cGRhdGVkIG5vZGVzLlxuICogQGV4YW1wbGVcbiAqYGBgdHN4XG4gKmltcG9ydCB7IHVzZVN0YXRlLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbiAqaW1wb3J0IHsgUmVhY3RGbG93LCBhcHBseU5vZGVDaGFuZ2VzLCB0eXBlIE5vZGUsIHR5cGUgRWRnZSwgdHlwZSBPbk5vZGVzQ2hhbmdlIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGbG93KCkge1xuICogIGNvbnN0IFtub2Rlcywgc2V0Tm9kZXNdID0gdXNlU3RhdGU8Tm9kZVtdPihbXSk7XG4gKiAgY29uc3QgW2VkZ2VzLCBzZXRFZGdlc10gPSB1c2VTdGF0ZTxFZGdlW10+KFtdKTtcbiAqICBjb25zdCBvbk5vZGVzQ2hhbmdlOiBPbk5vZGVzQ2hhbmdlID0gdXNlQ2FsbGJhY2soXG4gKiAgICAoY2hhbmdlcykgPT4ge1xuICogICAgICBzZXROb2Rlcygob2xkTm9kZXMpID0+IGFwcGx5Tm9kZUNoYW5nZXMoY2hhbmdlcywgb2xkTm9kZXMpKTtcbiAqICAgIH0sXG4gKiAgICBbc2V0Tm9kZXNdLFxuICogICk7XG4gKlxuICogIHJldHVybiAoXG4gKiAgICA8UmVhY3RGbG93IG5vZGVzPXtub2Rlc30gZWRnZXM9e2VkZ2VzfSBvbk5vZGVzQ2hhbmdlPXtvbk5vZGVzQ2hhbmdlfSAvPlxuICogICk7XG4gKn1cbiAqYGBgXG4gKiBAcmVtYXJrcyBWYXJpb3VzIGV2ZW50cyBvbiB0aGUgPFJlYWN0RmxvdyAvPiBjb21wb25lbnQgY2FuIHByb2R1Y2UgYW4ge0BsaW5rIE5vZGVDaGFuZ2V9XG4gKiB0aGF0IGRlc2NyaWJlcyBob3cgdG8gdXBkYXRlIHRoZSBlZGdlcyBvZiB5b3VyIGZsb3cgaW4gc29tZSB3YXkuXG4gKiBJZiB5b3UgZG9uJ3QgbmVlZCBhbnkgY3VzdG9tIGJlaGF2aW91ciwgdGhpcyB1dGlsIGNhbiBiZSB1c2VkIHRvIHRha2UgYW4gYXJyYXlcbiAqIG9mIHRoZXNlIGNoYW5nZXMgYW5kIGFwcGx5IHRoZW0gdG8geW91ciBlZGdlcy5cbiAqL1xuZnVuY3Rpb24gYXBwbHlOb2RlQ2hhbmdlcyhjaGFuZ2VzLCBub2Rlcykge1xuICAgIHJldHVybiBhcHBseUNoYW5nZXMoY2hhbmdlcywgbm9kZXMpO1xufVxuLyoqXG4gKiBEcm9wIGluIGZ1bmN0aW9uIHRoYXQgYXBwbGllcyBlZGdlIGNoYW5nZXMgdG8gYW4gYXJyYXkgb2YgZWRnZXMuXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gY2hhbmdlcyAtIEFycmF5IG9mIGNoYW5nZXMgdG8gYXBwbHkuXG4gKiBAcGFyYW0gZWRnZXMgLSBBcnJheSBvZiBlZGdlIHRvIGFwcGx5IHRoZSBjaGFuZ2VzIHRvLlxuICogQHJldHVybnMgQXJyYXkgb2YgdXBkYXRlZCBlZGdlcy5cbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuICppbXBvcnQgeyBSZWFjdEZsb3csIGFwcGx5RWRnZUNoYW5nZXMgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEZsb3coKSB7XG4gKiAgY29uc3QgW25vZGVzLCBzZXROb2Rlc10gPSB1c2VTdGF0ZShbXSk7XG4gKiAgY29uc3QgW2VkZ2VzLCBzZXRFZGdlc10gPSB1c2VTdGF0ZShbXSk7XG4gKiAgY29uc3Qgb25FZGdlc0NoYW5nZSA9IHVzZUNhbGxiYWNrKFxuICogICAgKGNoYW5nZXMpID0+IHtcbiAqICAgICAgc2V0RWRnZXMoKG9sZEVkZ2VzKSA9PiBhcHBseUVkZ2VDaGFuZ2VzKGNoYW5nZXMsIG9sZEVkZ2VzKSk7XG4gKiAgICB9LFxuICogICAgW3NldEVkZ2VzXSxcbiAqICApO1xuICpcbiAqICByZXR1cm4gKFxuICogICAgPFJlYWN0RmxvdyBub2Rlcz17bm9kZXN9IGVkZ2VzPXtlZGdlc30gb25FZGdlc0NoYW5nZT17b25FZGdlc0NoYW5nZX0gLz5cbiAqICApO1xuICp9XG4gKmBgYFxuICogQHJlbWFya3MgVmFyaW91cyBldmVudHMgb24gdGhlIDxSZWFjdEZsb3cgLz4gY29tcG9uZW50IGNhbiBwcm9kdWNlIGFuIHtAbGluayBFZGdlQ2hhbmdlfVxuICogdGhhdCBkZXNjcmliZXMgaG93IHRvIHVwZGF0ZSB0aGUgZWRnZXMgb2YgeW91ciBmbG93IGluIHNvbWUgd2F5LlxuICogSWYgeW91IGRvbid0IG5lZWQgYW55IGN1c3RvbSBiZWhhdmlvdXIsIHRoaXMgdXRpbCBjYW4gYmUgdXNlZCB0byB0YWtlIGFuIGFycmF5XG4gKiBvZiB0aGVzZSBjaGFuZ2VzIGFuZCBhcHBseSB0aGVtIHRvIHlvdXIgZWRnZXMuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5RWRnZUNoYW5nZXMoY2hhbmdlcywgZWRnZXMpIHtcbiAgICByZXR1cm4gYXBwbHlDaGFuZ2VzKGNoYW5nZXMsIGVkZ2VzKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNlbGVjdGlvbkNoYW5nZShpZCwgc2VsZWN0ZWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpZCxcbiAgICAgICAgdHlwZTogJ3NlbGVjdCcsXG4gICAgICAgIHNlbGVjdGVkLFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRTZWxlY3Rpb25DaGFuZ2VzKGl0ZW1zLCBzZWxlY3RlZElkcyA9IG5ldyBTZXQoKSwgbXV0YXRlSXRlbSA9IGZhbHNlKSB7XG4gICAgY29uc3QgY2hhbmdlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgW2lkLCBpdGVtXSBvZiBpdGVtcykge1xuICAgICAgICBjb25zdCB3aWxsQmVTZWxlY3RlZCA9IHNlbGVjdGVkSWRzLmhhcyhpZCk7XG4gICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdG8gc2V0IGFsbCBpdGVtcyB0byBzZWxlY3RlZD1mYWxzZSBvbiB0aGUgZmlyc3Qgc2VsZWN0aW9uXG4gICAgICAgIGlmICghKGl0ZW0uc2VsZWN0ZWQgPT09IHVuZGVmaW5lZCAmJiAhd2lsbEJlU2VsZWN0ZWQpICYmIGl0ZW0uc2VsZWN0ZWQgIT09IHdpbGxCZVNlbGVjdGVkKSB7XG4gICAgICAgICAgICBpZiAobXV0YXRlSXRlbSkge1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogdGhpcyBoYWNrIGlzIG5lZWRlZCBmb3Igbm9kZXMuIFdoZW4gdGhlIHVzZXIgZHJhZ2dlZCBhIG5vZGUsIGl0J3Mgc2VsZWN0ZWQuXG4gICAgICAgICAgICAgICAgICogV2hlbiBhbm90aGVyIG5vZGUgZ2V0cyBkcmFnZ2VkLCB3ZSBuZWVkIHRvIGRlc2VsZWN0IHRoZSBwcmV2aW91cyBvbmUsXG4gICAgICAgICAgICAgICAgICogaW4gb3JkZXIgdG8gaGF2ZSBvbmx5IG9uZSBzZWxlY3RlZCBub2RlIGF0IGEgdGltZSAtIHRoZSBvbk5vZGVzQ2hhbmdlIGNhbGxiYWNrIGNvbWVzIHRvbyBsYXRlIGhlcmUgOi9cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpdGVtLnNlbGVjdGVkID0gd2lsbEJlU2VsZWN0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goY3JlYXRlU2VsZWN0aW9uQ2hhbmdlKGl0ZW0uaWQsIHdpbGxCZVNlbGVjdGVkKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZXM7XG59XG5mdW5jdGlvbiBnZXRFbGVtZW50c0RpZmZDaGFuZ2VzKHsgaXRlbXMgPSBbXSwgbG9va3VwLCB9KSB7XG4gICAgY29uc3QgY2hhbmdlcyA9IFtdO1xuICAgIGNvbnN0IGl0ZW1zTG9va3VwID0gbmV3IE1hcChpdGVtcy5tYXAoKGl0ZW0pID0+IFtpdGVtLmlkLCBpdGVtXSkpO1xuICAgIGZvciAoY29uc3QgW2luZGV4LCBpdGVtXSBvZiBpdGVtcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgY29uc3QgbG9va3VwSXRlbSA9IGxvb2t1cC5nZXQoaXRlbS5pZCk7XG4gICAgICAgIGNvbnN0IHN0b3JlSXRlbSA9IGxvb2t1cEl0ZW0/LmludGVybmFscz8udXNlck5vZGUgPz8gbG9va3VwSXRlbTtcbiAgICAgICAgaWYgKHN0b3JlSXRlbSAhPT0gdW5kZWZpbmVkICYmIHN0b3JlSXRlbSAhPT0gaXRlbSkge1xuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgaWQ6IGl0ZW0uaWQsIGl0ZW06IGl0ZW0sIHR5cGU6ICdyZXBsYWNlJyB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RvcmVJdGVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGl0ZW06IGl0ZW0sIHR5cGU6ICdhZGQnLCBpbmRleCB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtpZF0gb2YgbG9va3VwKSB7XG4gICAgICAgIGNvbnN0IG5leHROb2RlID0gaXRlbXNMb29rdXAuZ2V0KGlkKTtcbiAgICAgICAgaWYgKG5leHROb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGlkLCB0eXBlOiAncmVtb3ZlJyB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlcztcbn1cbmZ1bmN0aW9uIGVsZW1lbnRUb1JlbW92ZUNoYW5nZShpdGVtKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IGl0ZW0uaWQsXG4gICAgICAgIHR5cGU6ICdyZW1vdmUnLFxuICAgIH07XG59XG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIGFuIG9iamVjdCBpcyB1c2FibGUgYXMgYW4gW2BOb2RlYF0oL2FwaS1yZWZlcmVuY2UvdHlwZXMvbm9kZSkuXG4gKiBJbiBUeXBlU2NyaXB0IHRoaXMgaXMgYSB0eXBlIGd1YXJkIHRoYXQgd2lsbCBuYXJyb3cgdGhlIHR5cGUgb2Ygd2hhdGV2ZXIgeW91IHBhc3MgaW4gdG9cbiAqIFtgTm9kZWBdKC9hcGktcmVmZXJlbmNlL3R5cGVzL25vZGUpIGlmIGl0IHJldHVybnMgYHRydWVgLlxuICpcbiAqIEBwdWJsaWNcbiAqIEByZW1hcmtzIEluIFR5cGVTY3JpcHQgdGhpcyBpcyBhIHR5cGUgZ3VhcmQgdGhhdCB3aWxsIG5hcnJvdyB0aGUgdHlwZSBvZiB3aGF0ZXZlciB5b3UgcGFzcyBpbiB0byBOb2RlIGlmIGl0IHJldHVybnMgdHJ1ZVxuICogQHBhcmFtIGVsZW1lbnQgLSBUaGUgZWxlbWVudCB0byB0ZXN0LlxuICogQHJldHVybnMgVGVzdHMgd2hldGhlciB0aGUgcHJvdmlkZWQgdmFsdWUgY2FuIGJlIHVzZWQgYXMgYSBgTm9kZWAuIElmIHlvdSdyZSB1c2luZyBUeXBlU2NyaXB0LFxuICogdGhpcyBmdW5jdGlvbiBhY3RzIGFzIGEgdHlwZSBndWFyZCBhbmQgd2lsbCBuYXJyb3cgdGhlIHR5cGUgb2YgdGhlIHZhbHVlIHRvIGBOb2RlYCBpZiBpdCByZXR1cm5zXG4gKiBgdHJ1ZWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKmltcG9ydCB7IGlzTm9kZSB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqaWYgKGlzTm9kZShub2RlKSkge1xuICogLy8gLi4uXG4gKn1cbiAqYGBgXG4gKi9cbmNvbnN0IGlzTm9kZSA9IChlbGVtZW50KSA9PiBpc05vZGVCYXNlKGVsZW1lbnQpO1xuLyoqXG4gKiBUZXN0IHdoZXRoZXIgYW4gb2JqZWN0IGlzIHVzYWJsZSBhcyBhbiBbYEVkZ2VgXSgvYXBpLXJlZmVyZW5jZS90eXBlcy9lZGdlKS5cbiAqIEluIFR5cGVTY3JpcHQgdGhpcyBpcyBhIHR5cGUgZ3VhcmQgdGhhdCB3aWxsIG5hcnJvdyB0aGUgdHlwZSBvZiB3aGF0ZXZlciB5b3UgcGFzcyBpbiB0b1xuICogW2BFZGdlYF0oL2FwaS1yZWZlcmVuY2UvdHlwZXMvZWRnZSkgaWYgaXQgcmV0dXJucyBgdHJ1ZWAuXG4gKlxuICogQHB1YmxpY1xuICogQHJlbWFya3MgSW4gVHlwZVNjcmlwdCB0aGlzIGlzIGEgdHlwZSBndWFyZCB0aGF0IHdpbGwgbmFycm93IHRoZSB0eXBlIG9mIHdoYXRldmVyIHlvdSBwYXNzIGluIHRvIEVkZ2UgaWYgaXQgcmV0dXJucyB0cnVlXG4gKiBAcGFyYW0gZWxlbWVudCAtIFRoZSBlbGVtZW50IHRvIHRlc3RcbiAqIEByZXR1cm5zIFRlc3RzIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHZhbHVlIGNhbiBiZSB1c2VkIGFzIGFuIGBFZGdlYC4gSWYgeW91J3JlIHVzaW5nIFR5cGVTY3JpcHQsXG4gKiB0aGlzIGZ1bmN0aW9uIGFjdHMgYXMgYSB0eXBlIGd1YXJkIGFuZCB3aWxsIG5hcnJvdyB0aGUgdHlwZSBvZiB0aGUgdmFsdWUgdG8gYEVkZ2VgIGlmIGl0IHJldHVybnNcbiAqIGB0cnVlYC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqaW1wb3J0IHsgaXNFZGdlIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICppZiAoaXNFZGdlKGVkZ2UpKSB7XG4gKiAvLyAuLi5cbiAqfVxuICpgYGBcbiAqL1xuY29uc3QgaXNFZGdlID0gKGVsZW1lbnQpID0+IGlzRWRnZUJhc2UoZWxlbWVudCk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LW9iamVjdC10eXBlXG5mdW5jdGlvbiBmaXhlZEZvcndhcmRSZWYocmVuZGVyKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICByZXR1cm4gZm9yd2FyZFJlZihyZW5kZXIpO1xufVxuXG4vLyB3ZSBuZWVkIHRoaXMgaG9vayB0byBwcmV2ZW50IGEgd2FybmluZyB3aGVuIHVzaW5nIHJlYWN0LWZsb3cgaW4gU1NSXG5jb25zdCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XG5cbi8qKlxuICogVGhpcyBob29rIHJldHVybnMgYSBxdWV1ZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGJhdGNoIHVwZGF0ZXMuXG4gKlxuICogQHBhcmFtIHJ1blF1ZXVlIC0gYSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIHdoZW4gdGhlIHF1ZXVlIGlzIGZsdXNoZWRcbiAqIEBpbnRlcm5hbFxuICpcbiAqIEByZXR1cm5zIGEgUXVldWUgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIHVzZVF1ZXVlKHJ1blF1ZXVlKSB7XG4gICAgLypcbiAgICAgKiBCZWNhdXNlIHdlJ3JlIHVzaW5nIGEgcmVmIGFib3ZlLCB3ZSBuZWVkIHNvbWUgd2F5IHRvIGxldCBSZWFjdCBrbm93IHdoZW4gdG9cbiAgICAgKiBhY3R1YWxseSBwcm9jZXNzIHRoZSBxdWV1ZS4gV2UgaW5jcmVtZW50IHRoaXMgbnVtYmVyIGFueSB0aW1lIHdlIG11dGF0ZSB0aGVcbiAgICAgKiBxdWV1ZSwgY3JlYXRpbmcgYSBuZXcgc3RhdGUgdG8gdHJpZ2dlciB0aGUgbGF5b3V0IGVmZmVjdCBiZWxvdy5cbiAgICAgKiBVc2luZyBhIGJvb2xlYW4gZGlydHkgZmxhZyBoZXJlIGluc3RlYWQgd291bGQgbGVhZCB0byBpc3N1ZXMgcmVsYXRlZCB0b1xuICAgICAqIGF1dG9tYXRpYyBiYXRjaGluZy4gKGh0dHBzOi8vZ2l0aHViLmNvbS94eWZsb3cveHlmbG93L2lzc3Vlcy80Nzc5KVxuICAgICAqL1xuICAgIGNvbnN0IFtzZXJpYWwsIHNldFNlcmlhbF0gPSB1c2VTdGF0ZShCaWdJbnQoMCkpO1xuICAgIC8qXG4gICAgICogQSByZWZlcmVuY2Ugb2YgYWxsIHRoZSBiYXRjaGVkIHVwZGF0ZXMgdG8gcHJvY2VzcyBiZWZvcmUgdGhlIG5leHQgcmVuZGVyLiBXZVxuICAgICAqIHdhbnQgYSByZWZlcmVuY2UgaGVyZSBzbyBtdWx0aXBsZSBzeW5jaHJvbm91cyBjYWxscyB0byBgc2V0Tm9kZXNgIGV0YyBjYW4gYmVcbiAgICAgKiBiYXRjaGVkIHRvZ2V0aGVyLlxuICAgICAqL1xuICAgIGNvbnN0IFtxdWV1ZV0gPSB1c2VTdGF0ZSgoKSA9PiBjcmVhdGVRdWV1ZSgoKSA9PiBzZXRTZXJpYWwobiA9PiBuICsgQmlnSW50KDEpKSkpO1xuICAgIC8qXG4gICAgICogTGF5b3V0IGVmZmVjdHMgYXJlIGd1YXJhbnRlZWQgdG8gcnVuIGJlZm9yZSB0aGUgbmV4dCByZW5kZXIgd2hpY2ggbWVhbnMgd2VcbiAgICAgKiBzaG91bGRuJ3QgcnVuIGludG8gYW55IGlzc3VlcyB3aXRoIHN0YWxlIHN0YXRlIG9yIHdlaXJkIGlzc3VlcyB0aGF0IGNvbWUgZnJvbVxuICAgICAqIHJlbmRlcmluZyB0aGluZ3Mgb25lIGZyYW1lIGxhdGVyIHRoYW4gZXhwZWN0ZWQgKHdlIHVzZWQgdG8gdXNlIGBzZXRUaW1lb3V0YCkuXG4gICAgICovXG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHF1ZXVlSXRlbXMgPSBxdWV1ZS5nZXQoKTtcbiAgICAgICAgaWYgKHF1ZXVlSXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBydW5RdWV1ZShxdWV1ZUl0ZW1zKTtcbiAgICAgICAgICAgIHF1ZXVlLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICB9LCBbc2VyaWFsXSk7XG4gICAgcmV0dXJuIHF1ZXVlO1xufVxuZnVuY3Rpb24gY3JlYXRlUXVldWUoY2IpIHtcbiAgICBsZXQgcXVldWUgPSBbXTtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXQ6ICgpID0+IHF1ZXVlLFxuICAgICAgICByZXNldDogKCkgPT4ge1xuICAgICAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgfSxcbiAgICAgICAgcHVzaDogKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goaXRlbSk7XG4gICAgICAgICAgICBjYigpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5cbmNvbnN0IEJhdGNoQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XG4vKipcbiAqIFRoaXMgaXMgYSBjb250ZXh0IHByb3ZpZGVyIHRoYXQgaG9sZHMgYW5kIHByb2Nlc3NlcyB0aGUgbm9kZSBhbmQgZWRnZSB1cGRhdGUgcXVldWVzXG4gKiB0aGF0IGFyZSBuZWVkZWQgdG8gaGFuZGxlIHNldE5vZGVzLCBhZGROb2Rlcywgc2V0RWRnZXMgYW5kIGFkZEVkZ2VzLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBCYXRjaFByb3ZpZGVyKHsgY2hpbGRyZW4sIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3Qgbm9kZVF1ZXVlSGFuZGxlciA9IHVzZUNhbGxiYWNrKChxdWV1ZUl0ZW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbm9kZXMgPSBbXSwgc2V0Tm9kZXMsIGhhc0RlZmF1bHROb2Rlcywgb25Ob2Rlc0NoYW5nZSwgbm9kZUxvb2t1cCwgZml0Vmlld1F1ZXVlZCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgLypcbiAgICAgICAgICogVGhpcyBpcyBlc3NlbnRpYWxseSBhbiBgQXJyYXkucmVkdWNlYCBpbiBpbXBlcmF0aXZlIGNsb3RoaW5nLiBQcm9jZXNzaW5nXG4gICAgICAgICAqIHRoaXMgcXVldWUgaXMgYSByZWxhdGl2ZWx5IGhvdCBwYXRoIHNvIHdlJ2QgbGlrZSB0byBhdm9pZCB0aGUgb3ZlcmhlYWQgb2ZcbiAgICAgICAgICogYXJyYXkgbWV0aG9kcyB3aGVyZSB3ZSBjYW4uXG4gICAgICAgICAqL1xuICAgICAgICBsZXQgbmV4dCA9IG5vZGVzO1xuICAgICAgICBmb3IgKGNvbnN0IHBheWxvYWQgb2YgcXVldWVJdGVtcykge1xuICAgICAgICAgICAgbmV4dCA9IHR5cGVvZiBwYXlsb2FkID09PSAnZnVuY3Rpb24nID8gcGF5bG9hZChuZXh0KSA6IHBheWxvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IGdldEVsZW1lbnRzRGlmZkNoYW5nZXMoe1xuICAgICAgICAgICAgaXRlbXM6IG5leHQsXG4gICAgICAgICAgICBsb29rdXA6IG5vZGVMb29rdXAsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaGFzRGVmYXVsdE5vZGVzKSB7XG4gICAgICAgICAgICBzZXROb2RlcyhuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBvbmx5IHdhbnQgdG8gZmlyZSBvbk5vZGVzQ2hhbmdlIGlmIHRoZXJlIGFyZSBjaGFuZ2VzIHRvIHRoZSBub2Rlc1xuICAgICAgICBpZiAoY2hhbmdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBvbk5vZGVzQ2hhbmdlPy4oY2hhbmdlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZml0Vmlld1F1ZXVlZCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGNoYW5nZXMgdG8gdGhlIG5vZGVzLCB3ZSBzdGlsbCBuZWVkIHRvIGNhbGwgc2V0Tm9kZXNcbiAgICAgICAgICAgIC8vIHRvIHRyaWdnZXIgYSByZS1yZW5kZXIgYW5kIGZpdFZpZXcuXG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGZpdFZpZXdRdWV1ZWQsIG5vZGVzLCBzZXROb2RlcyB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoZml0Vmlld1F1ZXVlZCkge1xuICAgICAgICAgICAgICAgICAgICBzZXROb2Rlcyhub2Rlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG4gICAgY29uc3Qgbm9kZVF1ZXVlID0gdXNlUXVldWUobm9kZVF1ZXVlSGFuZGxlcik7XG4gICAgY29uc3QgZWRnZVF1ZXVlSGFuZGxlciA9IHVzZUNhbGxiYWNrKChxdWV1ZUl0ZW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZWRnZXMgPSBbXSwgc2V0RWRnZXMsIGhhc0RlZmF1bHRFZGdlcywgb25FZGdlc0NoYW5nZSwgZWRnZUxvb2t1cCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgbGV0IG5leHQgPSBlZGdlcztcbiAgICAgICAgZm9yIChjb25zdCBwYXlsb2FkIG9mIHF1ZXVlSXRlbXMpIHtcbiAgICAgICAgICAgIG5leHQgPSB0eXBlb2YgcGF5bG9hZCA9PT0gJ2Z1bmN0aW9uJyA/IHBheWxvYWQobmV4dCkgOiBwYXlsb2FkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNEZWZhdWx0RWRnZXMpIHtcbiAgICAgICAgICAgIHNldEVkZ2VzKG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9uRWRnZXNDaGFuZ2UpIHtcbiAgICAgICAgICAgIG9uRWRnZXNDaGFuZ2UoZ2V0RWxlbWVudHNEaWZmQ2hhbmdlcyh7XG4gICAgICAgICAgICAgICAgaXRlbXM6IG5leHQsXG4gICAgICAgICAgICAgICAgbG9va3VwOiBlZGdlTG9va3VwLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IGVkZ2VRdWV1ZSA9IHVzZVF1ZXVlKGVkZ2VRdWV1ZUhhbmRsZXIpO1xuICAgIGNvbnN0IHZhbHVlID0gdXNlTWVtbygoKSA9PiAoeyBub2RlUXVldWUsIGVkZ2VRdWV1ZSB9KSwgW10pO1xuICAgIHJldHVybiBqc3goQmF0Y2hDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB2YWx1ZSwgY2hpbGRyZW46IGNoaWxkcmVuIH0pO1xufVxuZnVuY3Rpb24gdXNlQmF0Y2hDb250ZXh0KCkge1xuICAgIGNvbnN0IGJhdGNoQ29udGV4dCA9IHVzZUNvbnRleHQoQmF0Y2hDb250ZXh0KTtcbiAgICBpZiAoIWJhdGNoQ29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZUJhdGNoQ29udGV4dCBtdXN0IGJlIHVzZWQgd2l0aGluIGEgQmF0Y2hQcm92aWRlcicpO1xuICAgIH1cbiAgICByZXR1cm4gYmF0Y2hDb250ZXh0O1xufVxuXG5jb25zdCBzZWxlY3RvciRrID0gKHMpID0+ICEhcy5wYW5ab29tO1xuLyoqXG4gKiBUaGlzIGhvb2sgcmV0dXJucyBhIFJlYWN0Rmxvd0luc3RhbmNlIHRoYXQgY2FuIGJlIHVzZWQgdG8gdXBkYXRlIG5vZGVzIGFuZCBlZGdlcywgbWFuaXB1bGF0ZSB0aGUgdmlld3BvcnQsIG9yIHF1ZXJ5IHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBmbG93LlxuICpcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKiBgYGBqc3hcbiAqaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuICppbXBvcnQgeyB1c2VSZWFjdEZsb3cgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmV4cG9ydCBmdW5jdGlvbiBOb2RlQ291bnRlcigpIHtcbiAqICBjb25zdCByZWFjdEZsb3cgPSB1c2VSZWFjdEZsb3coKTtcbiAqICBjb25zdCBbY291bnQsIHNldENvdW50XSA9IHVzZVN0YXRlKDApO1xuICogIGNvbnN0IGNvdW50Tm9kZXMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gKiAgICBzZXRDb3VudChyZWFjdEZsb3cuZ2V0Tm9kZXMoKS5sZW5ndGgpO1xuICogICAgLy8geW91IG5lZWQgdG8gcGFzcyBpdCBhcyBhIGRlcGVuZGVuY3kgaWYgeW91IGFyZSB1c2luZyBpdCB3aXRoIHVzZUVmZmVjdCBvciB1c2VDYWxsYmFja1xuICogICAgLy8gYmVjYXVzZSBhdCB0aGUgZmlyc3QgcmVuZGVyLCBpdCdzIG5vdCBpbml0aWFsaXplZCB5ZXQgYW5kIHNvbWUgZnVuY3Rpb25zIG1pZ2h0IG5vdCB3b3JrLlxuICogIH0sIFtyZWFjdEZsb3ddKTtcbiAqXG4gKiAgcmV0dXJuIChcbiAqICAgIDxkaXY+XG4gKiAgICAgIDxidXR0b24gb25DbGljaz17Y291bnROb2Rlc30+VXBkYXRlIGNvdW50PC9idXR0b24+XG4gKiAgICAgIDxwPlRoZXJlIGFyZSB7Y291bnR9IG5vZGVzIGluIHRoZSBmbG93LjwvcD5cbiAqICAgIDwvZGl2PlxuICogICk7XG4gKn1cbiAqYGBgXG4gKi9cbmZ1bmN0aW9uIHVzZVJlYWN0RmxvdygpIHtcbiAgICBjb25zdCB2aWV3cG9ydEhlbHBlciA9IHVzZVZpZXdwb3J0SGVscGVyKCk7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IGJhdGNoQ29udGV4dCA9IHVzZUJhdGNoQ29udGV4dCgpO1xuICAgIGNvbnN0IHZpZXdwb3J0SW5pdGlhbGl6ZWQgPSB1c2VTdG9yZShzZWxlY3RvciRrKTtcbiAgICBjb25zdCBnZW5lcmFsSGVscGVyID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IGdldEludGVybmFsTm9kZSA9IChpZCkgPT4gc3RvcmUuZ2V0U3RhdGUoKS5ub2RlTG9va3VwLmdldChpZCk7XG4gICAgICAgIGNvbnN0IHNldE5vZGVzID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgIGJhdGNoQ29udGV4dC5ub2RlUXVldWUucHVzaChwYXlsb2FkKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc2V0RWRnZXMgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICAgICAgYmF0Y2hDb250ZXh0LmVkZ2VRdWV1ZS5wdXNoKHBheWxvYWQpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBnZXROb2RlUmVjdCA9IChub2RlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG5vZGVMb29rdXAsIG5vZGVPcmlnaW4gfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICBjb25zdCBub2RlVG9Vc2UgPSBpc05vZGUobm9kZSkgPyBub2RlIDogbm9kZUxvb2t1cC5nZXQobm9kZS5pZCk7XG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IG5vZGVUb1VzZS5wYXJlbnRJZFxuICAgICAgICAgICAgICAgID8gZXZhbHVhdGVBYnNvbHV0ZVBvc2l0aW9uKG5vZGVUb1VzZS5wb3NpdGlvbiwgbm9kZVRvVXNlLm1lYXN1cmVkLCBub2RlVG9Vc2UucGFyZW50SWQsIG5vZGVMb29rdXAsIG5vZGVPcmlnaW4pXG4gICAgICAgICAgICAgICAgOiBub2RlVG9Vc2UucG9zaXRpb247XG4gICAgICAgICAgICBjb25zdCBub2RlV2l0aFBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgIC4uLm5vZGVUb1VzZSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgICAgICB3aWR0aDogbm9kZVRvVXNlLm1lYXN1cmVkPy53aWR0aCA/PyBub2RlVG9Vc2Uud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBub2RlVG9Vc2UubWVhc3VyZWQ/LmhlaWdodCA/PyBub2RlVG9Vc2UuaGVpZ2h0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBub2RlVG9SZWN0KG5vZGVXaXRoUG9zaXRpb24pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB1cGRhdGVOb2RlID0gKGlkLCBub2RlVXBkYXRlLCBvcHRpb25zID0geyByZXBsYWNlOiBmYWxzZSB9KSA9PiB7XG4gICAgICAgICAgICBzZXROb2RlcygocHJldk5vZGVzKSA9PiBwcmV2Tm9kZXMubWFwKChub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHROb2RlID0gdHlwZW9mIG5vZGVVcGRhdGUgPT09ICdmdW5jdGlvbicgPyBub2RlVXBkYXRlKG5vZGUpIDogbm9kZVVwZGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMucmVwbGFjZSAmJiBpc05vZGUobmV4dE5vZGUpID8gbmV4dE5vZGUgOiB7IC4uLm5vZGUsIC4uLm5leHROb2RlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB1cGRhdGVFZGdlID0gKGlkLCBlZGdlVXBkYXRlLCBvcHRpb25zID0geyByZXBsYWNlOiBmYWxzZSB9KSA9PiB7XG4gICAgICAgICAgICBzZXRFZGdlcygocHJldkVkZ2VzKSA9PiBwcmV2RWRnZXMubWFwKChlZGdlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVkZ2UuaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRFZGdlID0gdHlwZW9mIGVkZ2VVcGRhdGUgPT09ICdmdW5jdGlvbicgPyBlZGdlVXBkYXRlKGVkZ2UpIDogZWRnZVVwZGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMucmVwbGFjZSAmJiBpc0VkZ2UobmV4dEVkZ2UpID8gbmV4dEVkZ2UgOiB7IC4uLmVkZ2UsIC4uLm5leHRFZGdlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBlZGdlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ2V0Tm9kZXM6ICgpID0+IHN0b3JlLmdldFN0YXRlKCkubm9kZXMubWFwKChuKSA9PiAoeyAuLi5uIH0pKSxcbiAgICAgICAgICAgIGdldE5vZGU6IChpZCkgPT4gZ2V0SW50ZXJuYWxOb2RlKGlkKT8uaW50ZXJuYWxzLnVzZXJOb2RlLFxuICAgICAgICAgICAgZ2V0SW50ZXJuYWxOb2RlLFxuICAgICAgICAgICAgZ2V0RWRnZXM6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGVkZ2VzID0gW10gfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVkZ2VzLm1hcCgoZSkgPT4gKHsgLi4uZSB9KSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0RWRnZTogKGlkKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLmVkZ2VMb29rdXAuZ2V0KGlkKSxcbiAgICAgICAgICAgIHNldE5vZGVzLFxuICAgICAgICAgICAgc2V0RWRnZXMsXG4gICAgICAgICAgICBhZGROb2RlczogKHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdOb2RlcyA9IEFycmF5LmlzQXJyYXkocGF5bG9hZCkgPyBwYXlsb2FkIDogW3BheWxvYWRdO1xuICAgICAgICAgICAgICAgIGJhdGNoQ29udGV4dC5ub2RlUXVldWUucHVzaCgobm9kZXMpID0+IFsuLi5ub2RlcywgLi4ubmV3Tm9kZXNdKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZGRFZGdlczogKHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdFZGdlcyA9IEFycmF5LmlzQXJyYXkocGF5bG9hZCkgPyBwYXlsb2FkIDogW3BheWxvYWRdO1xuICAgICAgICAgICAgICAgIGJhdGNoQ29udGV4dC5lZGdlUXVldWUucHVzaCgoZWRnZXMpID0+IFsuLi5lZGdlcywgLi4ubmV3RWRnZXNdKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b09iamVjdDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbm9kZXMgPSBbXSwgZWRnZXMgPSBbXSwgdHJhbnNmb3JtIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IFt4LCB5LCB6b29tXSA9IHRyYW5zZm9ybTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBub2Rlczogbm9kZXMubWFwKChuKSA9PiAoeyAuLi5uIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgZWRnZXM6IGVkZ2VzLm1hcCgoZSkgPT4gKHsgLi4uZSB9KSksXG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgICAgICAgICAgeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHpvb20sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWxldGVFbGVtZW50czogYXN5bmMgKHsgbm9kZXM6IG5vZGVzVG9SZW1vdmUgPSBbXSwgZWRnZXM6IGVkZ2VzVG9SZW1vdmUgPSBbXSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBub2RlcywgZWRnZXMsIG9uTm9kZXNEZWxldGUsIG9uRWRnZXNEZWxldGUsIHRyaWdnZXJOb2RlQ2hhbmdlcywgdHJpZ2dlckVkZ2VDaGFuZ2VzLCBvbkRlbGV0ZSwgb25CZWZvcmVEZWxldGUsIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbm9kZXM6IG1hdGNoaW5nTm9kZXMsIGVkZ2VzOiBtYXRjaGluZ0VkZ2VzIH0gPSBhd2FpdCBnZXRFbGVtZW50c1RvUmVtb3ZlKHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNUb1JlbW92ZSxcbiAgICAgICAgICAgICAgICAgICAgZWRnZXNUb1JlbW92ZSxcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMsXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VzLFxuICAgICAgICAgICAgICAgICAgICBvbkJlZm9yZURlbGV0ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNNYXRjaGluZ0VkZ2VzID0gbWF0Y2hpbmdFZGdlcy5sZW5ndGggPiAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc01hdGNoaW5nTm9kZXMgPSBtYXRjaGluZ05vZGVzLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICAgICAgaWYgKGhhc01hdGNoaW5nRWRnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWRnZUNoYW5nZXMgPSBtYXRjaGluZ0VkZ2VzLm1hcChlbGVtZW50VG9SZW1vdmVDaGFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICBvbkVkZ2VzRGVsZXRlPy4obWF0Y2hpbmdFZGdlcyk7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJFZGdlQ2hhbmdlcyhlZGdlQ2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoYXNNYXRjaGluZ05vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVDaGFuZ2VzID0gbWF0Y2hpbmdOb2Rlcy5tYXAoZWxlbWVudFRvUmVtb3ZlQ2hhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgb25Ob2Rlc0RlbGV0ZT8uKG1hdGNoaW5nTm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXMobm9kZUNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGFzTWF0Y2hpbmdOb2RlcyB8fCBoYXNNYXRjaGluZ0VkZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRGVsZXRlPy4oeyBub2RlczogbWF0Y2hpbmdOb2RlcywgZWRnZXM6IG1hdGNoaW5nRWRnZXMgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGRlbGV0ZWROb2RlczogbWF0Y2hpbmdOb2RlcywgZGVsZXRlZEVkZ2VzOiBtYXRjaGluZ0VkZ2VzIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0SW50ZXJzZWN0aW5nTm9kZXM6IChub2RlT3JSZWN0LCBwYXJ0aWFsbHkgPSB0cnVlLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzUmVjdCA9IGlzUmVjdE9iamVjdChub2RlT3JSZWN0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlUmVjdCA9IGlzUmVjdCA/IG5vZGVPclJlY3QgOiBnZXROb2RlUmVjdChub2RlT3JSZWN0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNOb2Rlc09wdGlvbiA9IG5vZGVzICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlUmVjdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAobm9kZXMgfHwgc3RvcmUuZ2V0U3RhdGUoKS5ub2RlcykuZmlsdGVyKChuKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGludGVybmFsTm9kZSA9IHN0b3JlLmdldFN0YXRlKCkubm9kZUxvb2t1cC5nZXQobi5pZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbE5vZGUgJiYgIWlzUmVjdCAmJiAobi5pZCA9PT0gbm9kZU9yUmVjdC5pZCB8fCAhaW50ZXJuYWxOb2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJOb2RlUmVjdCA9IG5vZGVUb1JlY3QoaGFzTm9kZXNPcHRpb24gPyBuIDogaW50ZXJuYWxOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3ZlcmxhcHBpbmdBcmVhID0gZ2V0T3ZlcmxhcHBpbmdBcmVhKGN1cnJOb2RlUmVjdCwgbm9kZVJlY3QpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJ0aWFsbHlWaXNpYmxlID0gcGFydGlhbGx5ICYmIG92ZXJsYXBwaW5nQXJlYSA+IDA7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0aWFsbHlWaXNpYmxlIHx8IG92ZXJsYXBwaW5nQXJlYSA+PSBub2RlUmVjdC53aWR0aCAqIG5vZGVSZWN0LmhlaWdodDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc05vZGVJbnRlcnNlY3Rpbmc6IChub2RlT3JSZWN0LCBhcmVhLCBwYXJ0aWFsbHkgPSB0cnVlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNSZWN0ID0gaXNSZWN0T2JqZWN0KG5vZGVPclJlY3QpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVSZWN0ID0gaXNSZWN0ID8gbm9kZU9yUmVjdCA6IGdldE5vZGVSZWN0KG5vZGVPclJlY3QpO1xuICAgICAgICAgICAgICAgIGlmICghbm9kZVJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBvdmVybGFwcGluZ0FyZWEgPSBnZXRPdmVybGFwcGluZ0FyZWEobm9kZVJlY3QsIGFyZWEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRpYWxseVZpc2libGUgPSBwYXJ0aWFsbHkgJiYgb3ZlcmxhcHBpbmdBcmVhID4gMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydGlhbGx5VmlzaWJsZSB8fCBvdmVybGFwcGluZ0FyZWEgPj0gbm9kZVJlY3Qud2lkdGggKiBub2RlUmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlTm9kZSxcbiAgICAgICAgICAgIHVwZGF0ZU5vZGVEYXRhOiAoaWQsIGRhdGFVcGRhdGUsIG9wdGlvbnMgPSB7IHJlcGxhY2U6IGZhbHNlIH0pID0+IHtcbiAgICAgICAgICAgICAgICB1cGRhdGVOb2RlKGlkLCAobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0RGF0YSA9IHR5cGVvZiBkYXRhVXBkYXRlID09PSAnZnVuY3Rpb24nID8gZGF0YVVwZGF0ZShub2RlKSA6IGRhdGFVcGRhdGU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnJlcGxhY2UgPyB7IC4uLm5vZGUsIGRhdGE6IG5leHREYXRhIH0gOiB7IC4uLm5vZGUsIGRhdGE6IHsgLi4ubm9kZS5kYXRhLCAuLi5uZXh0RGF0YSB9IH07XG4gICAgICAgICAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlRWRnZSxcbiAgICAgICAgICAgIHVwZGF0ZUVkZ2VEYXRhOiAoaWQsIGRhdGFVcGRhdGUsIG9wdGlvbnMgPSB7IHJlcGxhY2U6IGZhbHNlIH0pID0+IHtcbiAgICAgICAgICAgICAgICB1cGRhdGVFZGdlKGlkLCAoZWRnZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0RGF0YSA9IHR5cGVvZiBkYXRhVXBkYXRlID09PSAnZnVuY3Rpb24nID8gZGF0YVVwZGF0ZShlZGdlKSA6IGRhdGFVcGRhdGU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnJlcGxhY2UgPyB7IC4uLmVkZ2UsIGRhdGE6IG5leHREYXRhIH0gOiB7IC4uLmVkZ2UsIGRhdGE6IHsgLi4uZWRnZS5kYXRhLCAuLi5uZXh0RGF0YSB9IH07XG4gICAgICAgICAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0Tm9kZXNCb3VuZHM6IChub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbm9kZUxvb2t1cCwgbm9kZU9yaWdpbiB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Tm9kZXNCb3VuZHMobm9kZXMsIHsgbm9kZUxvb2t1cCwgbm9kZU9yaWdpbiB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRIYW5kbGVDb25uZWN0aW9uczogKHsgdHlwZSwgaWQsIG5vZGVJZCB9KSA9PiBBcnJheS5mcm9tKHN0b3JlXG4gICAgICAgICAgICAgICAgLmdldFN0YXRlKClcbiAgICAgICAgICAgICAgICAuY29ubmVjdGlvbkxvb2t1cC5nZXQoYCR7bm9kZUlkfS0ke3R5cGV9JHtpZCA/IGAtJHtpZH1gIDogJyd9YClcbiAgICAgICAgICAgICAgICA/LnZhbHVlcygpID8/IFtdKSxcbiAgICAgICAgICAgIGdldE5vZGVDb25uZWN0aW9uczogKHsgdHlwZSwgaGFuZGxlSWQsIG5vZGVJZCB9KSA9PiBBcnJheS5mcm9tKHN0b3JlXG4gICAgICAgICAgICAgICAgLmdldFN0YXRlKClcbiAgICAgICAgICAgICAgICAuY29ubmVjdGlvbkxvb2t1cC5nZXQoYCR7bm9kZUlkfSR7dHlwZSA/IChoYW5kbGVJZCA/IGAtJHt0eXBlfS0ke2hhbmRsZUlkfWAgOiBgLSR7dHlwZX1gKSA6ICcnfWApXG4gICAgICAgICAgICAgICAgPy52YWx1ZXMoKSA/PyBbXSksXG4gICAgICAgICAgICBmaXRWaWV3OiBhc3luYyAob3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFdlIGVpdGhlciBjcmVhdGUgYSBuZXcgUHJvbWlzZSBvciByZXVzZSB0aGUgZXhpc3Rpbmcgb25lXG4gICAgICAgICAgICAgICAgLy8gRXZlbiBpZiBmaXRWaWV3IGlzIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBpbiBhIHJvdywgd2Ugb25seSBlbmQgdXAgd2l0aCBhIHNpbmdsZSBQcm9taXNlXG4gICAgICAgICAgICAgICAgY29uc3QgZml0Vmlld1Jlc29sdmVyID0gc3RvcmUuZ2V0U3RhdGUoKS5maXRWaWV3UmVzb2x2ZXIgPz8gd2l0aFJlc29sdmVycygpO1xuICAgICAgICAgICAgICAgIC8vIFdlIHNjaGVkdWxlIGEgZml0VmlldyBieSBzZXR0aW5nIGZpdFZpZXdRdWV1ZWQgYW5kIHRyaWdnZXJpbmcgYSBzZXROb2Rlc1xuICAgICAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgZml0Vmlld1F1ZXVlZDogdHJ1ZSwgZml0Vmlld09wdGlvbnM6IG9wdGlvbnMsIGZpdFZpZXdSZXNvbHZlciB9KTtcbiAgICAgICAgICAgICAgICBiYXRjaENvbnRleHQubm9kZVF1ZXVlLnB1c2goKG5vZGVzKSA9PiBbLi4ubm9kZXNdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZml0Vmlld1Jlc29sdmVyLnByb21pc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5nZW5lcmFsSGVscGVyLFxuICAgICAgICAgICAgLi4udmlld3BvcnRIZWxwZXIsXG4gICAgICAgICAgICB2aWV3cG9ydEluaXRpYWxpemVkLFxuICAgICAgICB9O1xuICAgIH0sIFt2aWV3cG9ydEluaXRpYWxpemVkXSk7XG59XG5cbmNvbnN0IHNlbGVjdGVkID0gKGl0ZW0pID0+IGl0ZW0uc2VsZWN0ZWQ7XG5jb25zdCB3aW4kMSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdW5kZWZpbmVkO1xuLyoqXG4gKiBIb29rIGZvciBoYW5kbGluZyBnbG9iYWwga2V5IGV2ZW50cy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdXNlR2xvYmFsS2V5SGFuZGxlcih7IGRlbGV0ZUtleUNvZGUsIG11bHRpU2VsZWN0aW9uS2V5Q29kZSwgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCB7IGRlbGV0ZUVsZW1lbnRzIH0gPSB1c2VSZWFjdEZsb3coKTtcbiAgICBjb25zdCBkZWxldGVLZXlQcmVzc2VkID0gdXNlS2V5UHJlc3MoZGVsZXRlS2V5Q29kZSwgeyBhY3RJbnNpZGVJbnB1dFdpdGhNb2RpZmllcjogZmFsc2UgfSk7XG4gICAgY29uc3QgbXVsdGlTZWxlY3Rpb25LZXlQcmVzc2VkID0gdXNlS2V5UHJlc3MobXVsdGlTZWxlY3Rpb25LZXlDb2RlLCB7IHRhcmdldDogd2luJDEgfSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGRlbGV0ZUtleVByZXNzZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZWRnZXMsIG5vZGVzIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgZGVsZXRlRWxlbWVudHMoeyBub2Rlczogbm9kZXMuZmlsdGVyKHNlbGVjdGVkKSwgZWRnZXM6IGVkZ2VzLmZpbHRlcihzZWxlY3RlZCkgfSk7XG4gICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IG5vZGVzU2VsZWN0aW9uQWN0aXZlOiBmYWxzZSB9KTtcbiAgICAgICAgfVxuICAgIH0sIFtkZWxldGVLZXlQcmVzc2VkXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBtdWx0aVNlbGVjdGlvbkFjdGl2ZTogbXVsdGlTZWxlY3Rpb25LZXlQcmVzc2VkIH0pO1xuICAgIH0sIFttdWx0aVNlbGVjdGlvbktleVByZXNzZWRdKTtcbn1cblxuLyoqXG4gKiBIb29rIGZvciBoYW5kbGluZyByZXNpemUgZXZlbnRzLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1c2VSZXNpemVIYW5kbGVyKGRvbU5vZGUpIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgdXBkYXRlRGltZW5zaW9ucyA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICghZG9tTm9kZS5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IGdldERpbWVuc2lvbnMoZG9tTm9kZS5jdXJyZW50KTtcbiAgICAgICAgICAgIGlmIChzaXplLmhlaWdodCA9PT0gMCB8fCBzaXplLndpZHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3RvcmUuZ2V0U3RhdGUoKS5vbkVycm9yPy4oJzAwNCcsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDA0J10oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IHdpZHRoOiBzaXplLndpZHRoIHx8IDUwMCwgaGVpZ2h0OiBzaXplLmhlaWdodCB8fCA1MDAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChkb21Ob2RlLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHVwZGF0ZURpbWVuc2lvbnMoKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGVEaW1lbnNpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHVwZGF0ZURpbWVuc2lvbnMoKSk7XG4gICAgICAgICAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKGRvbU5vZGUuY3VycmVudCk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGVEaW1lbnNpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzaXplT2JzZXJ2ZXIgJiYgZG9tTm9kZS5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyLnVub2JzZXJ2ZShkb21Ob2RlLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG59XG5cbmNvbnN0IGNvbnRhaW5lclN0eWxlID0ge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIHdpZHRoOiAnMTAwJScsXG4gICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgdG9wOiAwLFxuICAgIGxlZnQ6IDAsXG59O1xuXG5jb25zdCBzZWxlY3RvciRqID0gKHMpID0+ICh7XG4gICAgdXNlclNlbGVjdGlvbkFjdGl2ZTogcy51c2VyU2VsZWN0aW9uQWN0aXZlLFxuICAgIGxpYjogcy5saWIsXG59KTtcbmZ1bmN0aW9uIFpvb21QYW5lKHsgb25QYW5lQ29udGV4dE1lbnUsIHpvb21PblNjcm9sbCA9IHRydWUsIHpvb21PblBpbmNoID0gdHJ1ZSwgcGFuT25TY3JvbGwgPSBmYWxzZSwgcGFuT25TY3JvbGxTcGVlZCA9IDAuNSwgcGFuT25TY3JvbGxNb2RlID0gUGFuT25TY3JvbGxNb2RlLkZyZWUsIHpvb21PbkRvdWJsZUNsaWNrID0gdHJ1ZSwgcGFuT25EcmFnID0gdHJ1ZSwgZGVmYXVsdFZpZXdwb3J0LCB0cmFuc2xhdGVFeHRlbnQsIG1pblpvb20sIG1heFpvb20sIHpvb21BY3RpdmF0aW9uS2V5Q29kZSwgcHJldmVudFNjcm9sbGluZyA9IHRydWUsIGNoaWxkcmVuLCBub1doZWVsQ2xhc3NOYW1lLCBub1BhbkNsYXNzTmFtZSwgb25WaWV3cG9ydENoYW5nZSwgaXNDb250cm9sbGVkVmlld3BvcnQsIHBhbmVDbGlja0Rpc3RhbmNlLCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IHpvb21QYW5lID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IHsgdXNlclNlbGVjdGlvbkFjdGl2ZSwgbGliIH0gPSB1c2VTdG9yZShzZWxlY3RvciRqLCBzaGFsbG93KTtcbiAgICBjb25zdCB6b29tQWN0aXZhdGlvbktleVByZXNzZWQgPSB1c2VLZXlQcmVzcyh6b29tQWN0aXZhdGlvbktleUNvZGUpO1xuICAgIGNvbnN0IHBhblpvb20gPSB1c2VSZWYoKTtcbiAgICB1c2VSZXNpemVIYW5kbGVyKHpvb21QYW5lKTtcbiAgICBjb25zdCBvblRyYW5zZm9ybUNoYW5nZSA9IHVzZUNhbGxiYWNrKCh0cmFuc2Zvcm0pID0+IHtcbiAgICAgICAgb25WaWV3cG9ydENoYW5nZT8uKHsgeDogdHJhbnNmb3JtWzBdLCB5OiB0cmFuc2Zvcm1bMV0sIHpvb206IHRyYW5zZm9ybVsyXSB9KTtcbiAgICAgICAgaWYgKCFpc0NvbnRyb2xsZWRWaWV3cG9ydCkge1xuICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyB0cmFuc2Zvcm0gfSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25WaWV3cG9ydENoYW5nZSwgaXNDb250cm9sbGVkVmlld3BvcnRdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoem9vbVBhbmUuY3VycmVudCkge1xuICAgICAgICAgICAgcGFuWm9vbS5jdXJyZW50ID0gWFlQYW5ab29tKHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlOiB6b29tUGFuZS5jdXJyZW50LFxuICAgICAgICAgICAgICAgIG1pblpvb20sXG4gICAgICAgICAgICAgICAgbWF4Wm9vbSxcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVFeHRlbnQsXG4gICAgICAgICAgICAgICAgdmlld3BvcnQ6IGRlZmF1bHRWaWV3cG9ydCxcbiAgICAgICAgICAgICAgICBwYW5lQ2xpY2tEaXN0YW5jZSxcbiAgICAgICAgICAgICAgICBvbkRyYWdnaW5nQ2hhbmdlOiAocGFuZURyYWdnaW5nKSA9PiBzdG9yZS5zZXRTdGF0ZSh7IHBhbmVEcmFnZ2luZyB9KSxcbiAgICAgICAgICAgICAgICBvblBhblpvb21TdGFydDogKGV2ZW50LCB2cCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IG9uVmlld3BvcnRDaGFuZ2VTdGFydCwgb25Nb3ZlU3RhcnQgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIG9uTW92ZVN0YXJ0Py4oZXZlbnQsIHZwKTtcbiAgICAgICAgICAgICAgICAgICAgb25WaWV3cG9ydENoYW5nZVN0YXJ0Py4odnApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25QYW5ab29tOiAoZXZlbnQsIHZwKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgb25WaWV3cG9ydENoYW5nZSwgb25Nb3ZlIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBvbk1vdmU/LihldmVudCwgdnApO1xuICAgICAgICAgICAgICAgICAgICBvblZpZXdwb3J0Q2hhbmdlPy4odnApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25QYW5ab29tRW5kOiAoZXZlbnQsIHZwKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgb25WaWV3cG9ydENoYW5nZUVuZCwgb25Nb3ZlRW5kIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBvbk1vdmVFbmQ/LihldmVudCwgdnApO1xuICAgICAgICAgICAgICAgICAgICBvblZpZXdwb3J0Q2hhbmdlRW5kPy4odnApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSwgem9vbSB9ID0gcGFuWm9vbS5jdXJyZW50LmdldFZpZXdwb3J0KCk7XG4gICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgcGFuWm9vbTogcGFuWm9vbS5jdXJyZW50LFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogW3gsIHksIHpvb21dLFxuICAgICAgICAgICAgICAgIGRvbU5vZGU6IHpvb21QYW5lLmN1cnJlbnQuY2xvc2VzdCgnLnJlYWN0LWZsb3cnKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBwYW5ab29tLmN1cnJlbnQ/LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgcGFuWm9vbS5jdXJyZW50Py51cGRhdGUoe1xuICAgICAgICAgICAgb25QYW5lQ29udGV4dE1lbnUsXG4gICAgICAgICAgICB6b29tT25TY3JvbGwsXG4gICAgICAgICAgICB6b29tT25QaW5jaCxcbiAgICAgICAgICAgIHBhbk9uU2Nyb2xsLFxuICAgICAgICAgICAgcGFuT25TY3JvbGxTcGVlZCxcbiAgICAgICAgICAgIHBhbk9uU2Nyb2xsTW9kZSxcbiAgICAgICAgICAgIHpvb21PbkRvdWJsZUNsaWNrLFxuICAgICAgICAgICAgcGFuT25EcmFnLFxuICAgICAgICAgICAgem9vbUFjdGl2YXRpb25LZXlQcmVzc2VkLFxuICAgICAgICAgICAgcHJldmVudFNjcm9sbGluZyxcbiAgICAgICAgICAgIG5vUGFuQ2xhc3NOYW1lLFxuICAgICAgICAgICAgdXNlclNlbGVjdGlvbkFjdGl2ZSxcbiAgICAgICAgICAgIG5vV2hlZWxDbGFzc05hbWUsXG4gICAgICAgICAgICBsaWIsXG4gICAgICAgICAgICBvblRyYW5zZm9ybUNoYW5nZSxcbiAgICAgICAgfSk7XG4gICAgfSwgW1xuICAgICAgICBvblBhbmVDb250ZXh0TWVudSxcbiAgICAgICAgem9vbU9uU2Nyb2xsLFxuICAgICAgICB6b29tT25QaW5jaCxcbiAgICAgICAgcGFuT25TY3JvbGwsXG4gICAgICAgIHBhbk9uU2Nyb2xsU3BlZWQsXG4gICAgICAgIHBhbk9uU2Nyb2xsTW9kZSxcbiAgICAgICAgem9vbU9uRG91YmxlQ2xpY2ssXG4gICAgICAgIHBhbk9uRHJhZyxcbiAgICAgICAgem9vbUFjdGl2YXRpb25LZXlQcmVzc2VkLFxuICAgICAgICBwcmV2ZW50U2Nyb2xsaW5nLFxuICAgICAgICBub1BhbkNsYXNzTmFtZSxcbiAgICAgICAgdXNlclNlbGVjdGlvbkFjdGl2ZSxcbiAgICAgICAgbm9XaGVlbENsYXNzTmFtZSxcbiAgICAgICAgbGliLFxuICAgICAgICBvblRyYW5zZm9ybUNoYW5nZSxcbiAgICBdKTtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19yZW5kZXJlclwiLCByZWY6IHpvb21QYW5lLCBzdHlsZTogY29udGFpbmVyU3R5bGUsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59XG5cbmNvbnN0IHNlbGVjdG9yJGkgPSAocykgPT4gKHtcbiAgICB1c2VyU2VsZWN0aW9uQWN0aXZlOiBzLnVzZXJTZWxlY3Rpb25BY3RpdmUsXG4gICAgdXNlclNlbGVjdGlvblJlY3Q6IHMudXNlclNlbGVjdGlvblJlY3QsXG59KTtcbmZ1bmN0aW9uIFVzZXJTZWxlY3Rpb24oKSB7XG4gICAgY29uc3QgeyB1c2VyU2VsZWN0aW9uQWN0aXZlLCB1c2VyU2VsZWN0aW9uUmVjdCB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkaSwgc2hhbGxvdyk7XG4gICAgY29uc3QgaXNBY3RpdmUgPSB1c2VyU2VsZWN0aW9uQWN0aXZlICYmIHVzZXJTZWxlY3Rpb25SZWN0O1xuICAgIGlmICghaXNBY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX3NlbGVjdGlvbiByZWFjdC1mbG93X19jb250YWluZXJcIiwgc3R5bGU6IHtcbiAgICAgICAgICAgIHdpZHRoOiB1c2VyU2VsZWN0aW9uUmVjdC53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdXNlclNlbGVjdGlvblJlY3QuaGVpZ2h0LFxuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7dXNlclNlbGVjdGlvblJlY3QueH1weCwgJHt1c2VyU2VsZWN0aW9uUmVjdC55fXB4KWAsXG4gICAgICAgIH0gfSkpO1xufVxuXG5jb25zdCB3cmFwSGFuZGxlciA9IChoYW5kbGVyLCBjb250YWluZXJSZWYpID0+IHtcbiAgICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC50YXJnZXQgIT09IGNvbnRhaW5lclJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlcj8uKGV2ZW50KTtcbiAgICB9O1xufTtcbmNvbnN0IHNlbGVjdG9yJGggPSAocykgPT4gKHtcbiAgICB1c2VyU2VsZWN0aW9uQWN0aXZlOiBzLnVzZXJTZWxlY3Rpb25BY3RpdmUsXG4gICAgZWxlbWVudHNTZWxlY3RhYmxlOiBzLmVsZW1lbnRzU2VsZWN0YWJsZSxcbiAgICBjb25uZWN0aW9uSW5Qcm9ncmVzczogcy5jb25uZWN0aW9uLmluUHJvZ3Jlc3MsXG4gICAgZHJhZ2dpbmc6IHMucGFuZURyYWdnaW5nLFxufSk7XG5mdW5jdGlvbiBQYW5lKHsgaXNTZWxlY3RpbmcsIHNlbGVjdGlvbktleVByZXNzZWQsIHNlbGVjdGlvbk1vZGUgPSBTZWxlY3Rpb25Nb2RlLkZ1bGwsIHBhbk9uRHJhZywgc2VsZWN0aW9uT25EcmFnLCBvblNlbGVjdGlvblN0YXJ0LCBvblNlbGVjdGlvbkVuZCwgb25QYW5lQ2xpY2ssIG9uUGFuZUNvbnRleHRNZW51LCBvblBhbmVTY3JvbGwsIG9uUGFuZU1vdXNlRW50ZXIsIG9uUGFuZU1vdXNlTW92ZSwgb25QYW5lTW91c2VMZWF2ZSwgY2hpbGRyZW4sIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgeyB1c2VyU2VsZWN0aW9uQWN0aXZlLCBlbGVtZW50c1NlbGVjdGFibGUsIGRyYWdnaW5nLCBjb25uZWN0aW9uSW5Qcm9ncmVzcyB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkaCwgc2hhbGxvdyk7XG4gICAgY29uc3QgaGFzQWN0aXZlU2VsZWN0aW9uID0gZWxlbWVudHNTZWxlY3RhYmxlICYmIChpc1NlbGVjdGluZyB8fCB1c2VyU2VsZWN0aW9uQWN0aXZlKTtcbiAgICBjb25zdCBjb250YWluZXIgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgY29udGFpbmVyQm91bmRzID0gdXNlUmVmKCk7XG4gICAgY29uc3Qgc2VsZWN0ZWROb2RlSWRzID0gdXNlUmVmKG5ldyBTZXQoKSk7XG4gICAgY29uc3Qgc2VsZWN0ZWRFZGdlSWRzID0gdXNlUmVmKG5ldyBTZXQoKSk7XG4gICAgLy8gVXNlZCB0byBwcmV2ZW50IGNsaWNrIGV2ZW50cyB3aGVuIHRoZSB1c2VyIGxldHMgZ28gb2YgdGhlIHNlbGVjdGlvbktleSBkdXJpbmcgYSBzZWxlY3Rpb25cbiAgICBjb25zdCBzZWxlY3Rpb25JblByb2dyZXNzID0gdXNlUmVmKGZhbHNlKTtcbiAgICBjb25zdCBzZWxlY3Rpb25TdGFydGVkID0gdXNlUmVmKGZhbHNlKTtcbiAgICBjb25zdCBvbkNsaWNrID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIC8vIFdlIHByZXZlbnQgY2xpY2sgZXZlbnRzIHdoZW4gdGhlIHVzZXIgbGV0IGdvIG9mIHRoZSBzZWxlY3Rpb25LZXkgZHVyaW5nIGEgc2VsZWN0aW9uXG4gICAgICAgIC8vIFdlIGFsc28gcHJldmVudCBjbGljayBldmVudHMgd2hlbiBhIGNvbm5lY3Rpb24gaXMgaW4gcHJvZ3Jlc3NcbiAgICAgICAgaWYgKHNlbGVjdGlvbkluUHJvZ3Jlc3MuY3VycmVudCB8fCBjb25uZWN0aW9uSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgc2VsZWN0aW9uSW5Qcm9ncmVzcy5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgb25QYW5lQ2xpY2s/LihldmVudCk7XG4gICAgICAgIHN0b3JlLmdldFN0YXRlKCkucmVzZXRTZWxlY3RlZEVsZW1lbnRzKCk7XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHsgbm9kZXNTZWxlY3Rpb25BY3RpdmU6IGZhbHNlIH0pO1xuICAgIH07XG4gICAgY29uc3Qgb25Db250ZXh0TWVudSA9IChldmVudCkgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYW5PbkRyYWcpICYmIHBhbk9uRHJhZz8uaW5jbHVkZXMoMikpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgb25QYW5lQ29udGV4dE1lbnU/LihldmVudCk7XG4gICAgfTtcbiAgICBjb25zdCBvbldoZWVsID0gb25QYW5lU2Nyb2xsID8gKGV2ZW50KSA9PiBvblBhbmVTY3JvbGwoZXZlbnQpIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9uUG9pbnRlckRvd24gPSAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgeyByZXNldFNlbGVjdGVkRWxlbWVudHMsIGRvbU5vZGUgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGNvbnRhaW5lckJvdW5kcy5jdXJyZW50ID0gZG9tTm9kZT8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmICghZWxlbWVudHNTZWxlY3RhYmxlIHx8XG4gICAgICAgICAgICAhaXNTZWxlY3RpbmcgfHxcbiAgICAgICAgICAgIGV2ZW50LmJ1dHRvbiAhPT0gMCB8fFxuICAgICAgICAgICAgZXZlbnQudGFyZ2V0ICE9PSBjb250YWluZXIuY3VycmVudCB8fFxuICAgICAgICAgICAgIWNvbnRhaW5lckJvdW5kcy5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQudGFyZ2V0Py5zZXRQb2ludGVyQ2FwdHVyZT8uKGV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgIHNlbGVjdGlvblN0YXJ0ZWQuY3VycmVudCA9IHRydWU7XG4gICAgICAgIHNlbGVjdGlvbkluUHJvZ3Jlc3MuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IGdldEV2ZW50UG9zaXRpb24oZXZlbnQubmF0aXZlRXZlbnQsIGNvbnRhaW5lckJvdW5kcy5jdXJyZW50KTtcbiAgICAgICAgcmVzZXRTZWxlY3RlZEVsZW1lbnRzKCk7XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHVzZXJTZWxlY3Rpb25SZWN0OiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgICAgICAgIHN0YXJ0WDogeCxcbiAgICAgICAgICAgICAgICBzdGFydFk6IHksXG4gICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIG9uU2VsZWN0aW9uU3RhcnQ/LihldmVudCk7XG4gICAgfTtcbiAgICBjb25zdCBvblBvaW50ZXJNb3ZlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgdXNlclNlbGVjdGlvblJlY3QsIHRyYW5zZm9ybSwgbm9kZUxvb2t1cCwgZWRnZUxvb2t1cCwgY29ubmVjdGlvbkxvb2t1cCwgdHJpZ2dlck5vZGVDaGFuZ2VzLCB0cmlnZ2VyRWRnZUNoYW5nZXMsIGRlZmF1bHRFZGdlT3B0aW9ucywgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGlmICghY29udGFpbmVyQm91bmRzLmN1cnJlbnQgfHwgIXVzZXJTZWxlY3Rpb25SZWN0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2VsZWN0aW9uSW5Qcm9ncmVzcy5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyB4OiBtb3VzZVgsIHk6IG1vdXNlWSB9ID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudC5uYXRpdmVFdmVudCwgY29udGFpbmVyQm91bmRzLmN1cnJlbnQpO1xuICAgICAgICBjb25zdCB7IHN0YXJ0WCwgc3RhcnRZIH0gPSB1c2VyU2VsZWN0aW9uUmVjdDtcbiAgICAgICAgY29uc3QgbmV4dFVzZXJTZWxlY3RSZWN0ID0ge1xuICAgICAgICAgICAgc3RhcnRYLFxuICAgICAgICAgICAgc3RhcnRZLFxuICAgICAgICAgICAgeDogbW91c2VYIDwgc3RhcnRYID8gbW91c2VYIDogc3RhcnRYLFxuICAgICAgICAgICAgeTogbW91c2VZIDwgc3RhcnRZID8gbW91c2VZIDogc3RhcnRZLFxuICAgICAgICAgICAgd2lkdGg6IE1hdGguYWJzKG1vdXNlWCAtIHN0YXJ0WCksXG4gICAgICAgICAgICBoZWlnaHQ6IE1hdGguYWJzKG1vdXNlWSAtIHN0YXJ0WSksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHByZXZTZWxlY3RlZE5vZGVJZHMgPSBzZWxlY3RlZE5vZGVJZHMuY3VycmVudDtcbiAgICAgICAgY29uc3QgcHJldlNlbGVjdGVkRWRnZUlkcyA9IHNlbGVjdGVkRWRnZUlkcy5jdXJyZW50O1xuICAgICAgICBzZWxlY3RlZE5vZGVJZHMuY3VycmVudCA9IG5ldyBTZXQoZ2V0Tm9kZXNJbnNpZGUobm9kZUxvb2t1cCwgbmV4dFVzZXJTZWxlY3RSZWN0LCB0cmFuc2Zvcm0sIHNlbGVjdGlvbk1vZGUgPT09IFNlbGVjdGlvbk1vZGUuUGFydGlhbCwgdHJ1ZSkubWFwKChub2RlKSA9PiBub2RlLmlkKSk7XG4gICAgICAgIHNlbGVjdGVkRWRnZUlkcy5jdXJyZW50ID0gbmV3IFNldCgpO1xuICAgICAgICBjb25zdCBlZGdlc1NlbGVjdGFibGUgPSBkZWZhdWx0RWRnZU9wdGlvbnM/LnNlbGVjdGFibGUgPz8gdHJ1ZTtcbiAgICAgICAgLy8gV2UgbG9vayBmb3IgYWxsIGVkZ2VzIGNvbm5lY3RlZCB0byB0aGUgc2VsZWN0ZWQgbm9kZXNcbiAgICAgICAgZm9yIChjb25zdCBub2RlSWQgb2Ygc2VsZWN0ZWROb2RlSWRzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb25zID0gY29ubmVjdGlvbkxvb2t1cC5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgIGlmICghY29ubmVjdGlvbnMpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHsgZWRnZUlkIH0gb2YgY29ubmVjdGlvbnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlZGdlID0gZWRnZUxvb2t1cC5nZXQoZWRnZUlkKTtcbiAgICAgICAgICAgICAgICBpZiAoZWRnZSAmJiAoZWRnZS5zZWxlY3RhYmxlID8/IGVkZ2VzU2VsZWN0YWJsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRFZGdlSWRzLmN1cnJlbnQuYWRkKGVkZ2VJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghYXJlU2V0c0VxdWFsKHByZXZTZWxlY3RlZE5vZGVJZHMsIHNlbGVjdGVkTm9kZUlkcy5jdXJyZW50KSkge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IGdldFNlbGVjdGlvbkNoYW5nZXMobm9kZUxvb2t1cCwgc2VsZWN0ZWROb2RlSWRzLmN1cnJlbnQsIHRydWUpO1xuICAgICAgICAgICAgdHJpZ2dlck5vZGVDaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYXJlU2V0c0VxdWFsKHByZXZTZWxlY3RlZEVkZ2VJZHMsIHNlbGVjdGVkRWRnZUlkcy5jdXJyZW50KSkge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IGdldFNlbGVjdGlvbkNoYW5nZXMoZWRnZUxvb2t1cCwgc2VsZWN0ZWRFZGdlSWRzLmN1cnJlbnQpO1xuICAgICAgICAgICAgdHJpZ2dlckVkZ2VDaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICB9XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHVzZXJTZWxlY3Rpb25SZWN0OiBuZXh0VXNlclNlbGVjdFJlY3QsXG4gICAgICAgICAgICB1c2VyU2VsZWN0aW9uQWN0aXZlOiB0cnVlLFxuICAgICAgICAgICAgbm9kZXNTZWxlY3Rpb25BY3RpdmU6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IG9uUG9pbnRlclVwID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC5idXR0b24gIT09IDAgfHwgIXNlbGVjdGlvblN0YXJ0ZWQuY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnRhcmdldD8ucmVsZWFzZVBvaW50ZXJDYXB0dXJlPy4oZXZlbnQucG9pbnRlcklkKTtcbiAgICAgICAgY29uc3QgeyB1c2VyU2VsZWN0aW9uUmVjdCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgLypcbiAgICAgICAgICogV2Ugb25seSB3YW50IHRvIHRyaWdnZXIgY2xpY2sgZnVuY3Rpb25zIHdoZW4gaW4gc2VsZWN0aW9uIG1vZGUgaWZcbiAgICAgICAgICogdGhlIHVzZXIgZGlkIG5vdCBtb3ZlIHRoZSBtb3VzZS5cbiAgICAgICAgICovXG4gICAgICAgIGlmICghdXNlclNlbGVjdGlvbkFjdGl2ZSAmJiB1c2VyU2VsZWN0aW9uUmVjdCAmJiBldmVudC50YXJnZXQgPT09IGNvbnRhaW5lci5jdXJyZW50KSB7XG4gICAgICAgICAgICBvbkNsaWNrPy4oZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHVzZXJTZWxlY3Rpb25BY3RpdmU6IGZhbHNlLFxuICAgICAgICAgICAgdXNlclNlbGVjdGlvblJlY3Q6IG51bGwsXG4gICAgICAgICAgICBub2Rlc1NlbGVjdGlvbkFjdGl2ZTogc2VsZWN0ZWROb2RlSWRzLmN1cnJlbnQuc2l6ZSA+IDAsXG4gICAgICAgIH0pO1xuICAgICAgICBvblNlbGVjdGlvbkVuZD8uKGV2ZW50KTtcbiAgICAgICAgLypcbiAgICAgICAgICogSWYgdGhlIHVzZXIga2VwdCBob2xkaW5nIHRoZSBzZWxlY3Rpb25LZXkgZHVyaW5nIHRoZSBzZWxlY3Rpb24sXG4gICAgICAgICAqIHdlIG5lZWQgdG8gcmVzZXQgdGhlIHNlbGVjdGlvbkluUHJvZ3Jlc3MsIHNvIHRoZSBuZXh0IGNsaWNrIGV2ZW50IGlzIG5vdCBwcmV2ZW50ZWRcbiAgICAgICAgICovXG4gICAgICAgIGlmIChzZWxlY3Rpb25LZXlQcmVzc2VkIHx8IHNlbGVjdGlvbk9uRHJhZykge1xuICAgICAgICAgICAgc2VsZWN0aW9uSW5Qcm9ncmVzcy5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZWN0aW9uU3RhcnRlZC5jdXJyZW50ID0gZmFsc2U7XG4gICAgfTtcbiAgICBjb25zdCBkcmFnZ2FibGUgPSBwYW5PbkRyYWcgPT09IHRydWUgfHwgKEFycmF5LmlzQXJyYXkocGFuT25EcmFnKSAmJiBwYW5PbkRyYWcuaW5jbHVkZXMoMCkpO1xuICAgIHJldHVybiAoanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19wYW5lJywgeyBkcmFnZ2FibGUsIGRyYWdnaW5nLCBzZWxlY3Rpb246IGlzU2VsZWN0aW5nIH1dKSwgb25DbGljazogaGFzQWN0aXZlU2VsZWN0aW9uID8gdW5kZWZpbmVkIDogd3JhcEhhbmRsZXIob25DbGljaywgY29udGFpbmVyKSwgb25Db250ZXh0TWVudTogd3JhcEhhbmRsZXIob25Db250ZXh0TWVudSwgY29udGFpbmVyKSwgb25XaGVlbDogd3JhcEhhbmRsZXIob25XaGVlbCwgY29udGFpbmVyKSwgb25Qb2ludGVyRW50ZXI6IGhhc0FjdGl2ZVNlbGVjdGlvbiA/IHVuZGVmaW5lZCA6IG9uUGFuZU1vdXNlRW50ZXIsIG9uUG9pbnRlckRvd246IGhhc0FjdGl2ZVNlbGVjdGlvbiA/IG9uUG9pbnRlckRvd24gOiBvblBhbmVNb3VzZU1vdmUsIG9uUG9pbnRlck1vdmU6IGhhc0FjdGl2ZVNlbGVjdGlvbiA/IG9uUG9pbnRlck1vdmUgOiBvblBhbmVNb3VzZU1vdmUsIG9uUG9pbnRlclVwOiBoYXNBY3RpdmVTZWxlY3Rpb24gPyBvblBvaW50ZXJVcCA6IHVuZGVmaW5lZCwgb25Qb2ludGVyTGVhdmU6IG9uUGFuZU1vdXNlTGVhdmUsIHJlZjogY29udGFpbmVyLCBzdHlsZTogY29udGFpbmVyU3R5bGUsIGNoaWxkcmVuOiBbY2hpbGRyZW4sIGpzeChVc2VyU2VsZWN0aW9uLCB7fSldIH0pKTtcbn1cblxuLypcbiAqIHRoaXMgaGFuZGxlciBpcyBjYWxsZWQgYnlcbiAqIDEuIHRoZSBjbGljayBoYW5kbGVyIHdoZW4gbm9kZSBpcyBub3QgZHJhZ2dhYmxlIG9yIHNlbGVjdE5vZGVzT25EcmFnID0gZmFsc2VcbiAqIG9yXG4gKiAyLiB0aGUgb24gZHJhZyBzdGFydCBoYW5kbGVyIHdoZW4gbm9kZSBpcyBkcmFnZ2FibGUgYW5kIHNlbGVjdE5vZGVzT25EcmFnID0gdHJ1ZVxuICovXG5mdW5jdGlvbiBoYW5kbGVOb2RlQ2xpY2soeyBpZCwgc3RvcmUsIHVuc2VsZWN0ID0gZmFsc2UsIG5vZGVSZWYsIH0pIHtcbiAgICBjb25zdCB7IGFkZFNlbGVjdGVkTm9kZXMsIHVuc2VsZWN0Tm9kZXNBbmRFZGdlcywgbXVsdGlTZWxlY3Rpb25BY3RpdmUsIG5vZGVMb29rdXAsIG9uRXJyb3IgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVMb29rdXAuZ2V0KGlkKTtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgb25FcnJvcj8uKCcwMTInLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAxMiddKGlkKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3RvcmUuc2V0U3RhdGUoeyBub2Rlc1NlbGVjdGlvbkFjdGl2ZTogZmFsc2UgfSk7XG4gICAgaWYgKCFub2RlLnNlbGVjdGVkKSB7XG4gICAgICAgIGFkZFNlbGVjdGVkTm9kZXMoW2lkXSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHVuc2VsZWN0IHx8IChub2RlLnNlbGVjdGVkICYmIG11bHRpU2VsZWN0aW9uQWN0aXZlKSkge1xuICAgICAgICB1bnNlbGVjdE5vZGVzQW5kRWRnZXMoeyBub2RlczogW25vZGVdLCBlZGdlczogW10gfSk7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiBub2RlUmVmPy5jdXJyZW50Py5ibHVyKCkpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBIb29rIGZvciBjYWxsaW5nIFhZRHJhZyBoZWxwZXIgZnJvbSBAeHlmbG93L3N5c3RlbS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdXNlRHJhZyh7IG5vZGVSZWYsIGRpc2FibGVkID0gZmFsc2UsIG5vRHJhZ0NsYXNzTmFtZSwgaGFuZGxlU2VsZWN0b3IsIG5vZGVJZCwgaXNTZWxlY3RhYmxlLCBub2RlQ2xpY2tEaXN0YW5jZSwgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCBbZHJhZ2dpbmcsIHNldERyYWdnaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCB4eURyYWcgPSB1c2VSZWYoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICB4eURyYWcuY3VycmVudCA9IFhZRHJhZyh7XG4gICAgICAgICAgICBnZXRTdG9yZUl0ZW1zOiAoKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLFxuICAgICAgICAgICAgb25Ob2RlTW91c2VEb3duOiAoaWQpID0+IHtcbiAgICAgICAgICAgICAgICBoYW5kbGVOb2RlQ2xpY2soe1xuICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUsXG4gICAgICAgICAgICAgICAgICAgIG5vZGVSZWYsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25EcmFnU3RhcnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBzZXREcmFnZ2luZyh0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkRyYWdTdG9wOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0RHJhZ2dpbmcoZmFsc2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfSwgW10pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgICAgICAgeHlEcmFnLmN1cnJlbnQ/LmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHh5RHJhZy5jdXJyZW50Py51cGRhdGUoe1xuICAgICAgICAgICAgICAgIG5vRHJhZ0NsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICBoYW5kbGVTZWxlY3RvcixcbiAgICAgICAgICAgICAgICBkb21Ob2RlOiBub2RlUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgaXNTZWxlY3RhYmxlLFxuICAgICAgICAgICAgICAgIG5vZGVJZCxcbiAgICAgICAgICAgICAgICBub2RlQ2xpY2tEaXN0YW5jZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICB4eURyYWcuY3VycmVudD8uZGVzdHJveSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIFtub0RyYWdDbGFzc05hbWUsIGhhbmRsZVNlbGVjdG9yLCBkaXNhYmxlZCwgaXNTZWxlY3RhYmxlLCBub2RlUmVmLCBub2RlSWRdKTtcbiAgICByZXR1cm4gZHJhZ2dpbmc7XG59XG5cbmNvbnN0IHNlbGVjdGVkQW5kRHJhZ2dhYmxlID0gKG5vZGVzRHJhZ2dhYmxlKSA9PiAobikgPT4gbi5zZWxlY3RlZCAmJiAobi5kcmFnZ2FibGUgfHwgKG5vZGVzRHJhZ2dhYmxlICYmIHR5cGVvZiBuLmRyYWdnYWJsZSA9PT0gJ3VuZGVmaW5lZCcpKTtcbi8qKlxuICogSG9vayBmb3IgdXBkYXRpbmcgbm9kZSBwb3NpdGlvbnMgYnkgcGFzc2luZyBhIGRpcmVjdGlvbiBhbmQgZmFjdG9yXG4gKlxuICogQGludGVybmFsXG4gKiBAcmV0dXJucyBmdW5jdGlvbiBmb3IgdXBkYXRpbmcgbm9kZSBwb3NpdGlvbnNcbiAqL1xuZnVuY3Rpb24gdXNlTW92ZVNlbGVjdGVkTm9kZXMoKSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IG1vdmVTZWxlY3RlZE5vZGVzID0gdXNlQ2FsbGJhY2soKHBhcmFtcykgPT4ge1xuICAgICAgICBjb25zdCB7IG5vZGVFeHRlbnQsIHNuYXBUb0dyaWQsIHNuYXBHcmlkLCBub2Rlc0RyYWdnYWJsZSwgb25FcnJvciwgdXBkYXRlTm9kZVBvc2l0aW9ucywgbm9kZUxvb2t1cCwgbm9kZU9yaWdpbiB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgY29uc3Qgbm9kZVVwZGF0ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSBzZWxlY3RlZEFuZERyYWdnYWJsZShub2Rlc0RyYWdnYWJsZSk7XG4gICAgICAgIC8qXG4gICAgICAgICAqIGJ5IGRlZmF1bHQgYSBub2RlIG1vdmVzIDVweCBvbiBlYWNoIGtleSBwcmVzc1xuICAgICAgICAgKiBpZiBzbmFwIGdyaWQgaXMgZW5hYmxlZCwgd2UgdXNlIHRoYXQgZm9yIHRoZSB2ZWxvY2l0eVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgeFZlbG8gPSBzbmFwVG9HcmlkID8gc25hcEdyaWRbMF0gOiA1O1xuICAgICAgICBjb25zdCB5VmVsbyA9IHNuYXBUb0dyaWQgPyBzbmFwR3JpZFsxXSA6IDU7XG4gICAgICAgIGNvbnN0IHhEaWZmID0gcGFyYW1zLmRpcmVjdGlvbi54ICogeFZlbG8gKiBwYXJhbXMuZmFjdG9yO1xuICAgICAgICBjb25zdCB5RGlmZiA9IHBhcmFtcy5kaXJlY3Rpb24ueSAqIHlWZWxvICogcGFyYW1zLmZhY3RvcjtcbiAgICAgICAgZm9yIChjb25zdCBbLCBub2RlXSBvZiBub2RlTG9va3VwKSB7XG4gICAgICAgICAgICBpZiAoIWlzU2VsZWN0ZWQobm9kZSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBuZXh0UG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeDogbm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS54ICsgeERpZmYsXG4gICAgICAgICAgICAgICAgeTogbm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS55ICsgeURpZmYsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHNuYXBUb0dyaWQpIHtcbiAgICAgICAgICAgICAgICBuZXh0UG9zaXRpb24gPSBzbmFwUG9zaXRpb24obmV4dFBvc2l0aW9uLCBzbmFwR3JpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHBvc2l0aW9uLCBwb3NpdGlvbkFic29sdXRlIH0gPSBjYWxjdWxhdGVOb2RlUG9zaXRpb24oe1xuICAgICAgICAgICAgICAgIG5vZGVJZDogbm9kZS5pZCxcbiAgICAgICAgICAgICAgICBuZXh0UG9zaXRpb24sXG4gICAgICAgICAgICAgICAgbm9kZUxvb2t1cCxcbiAgICAgICAgICAgICAgICBub2RlRXh0ZW50LFxuICAgICAgICAgICAgICAgIG5vZGVPcmlnaW4sXG4gICAgICAgICAgICAgICAgb25FcnJvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbm9kZS5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgbm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZSA9IHBvc2l0aW9uQWJzb2x1dGU7XG4gICAgICAgICAgICBub2RlVXBkYXRlcy5zZXQobm9kZS5pZCwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlTm9kZVBvc2l0aW9ucyhub2RlVXBkYXRlcyk7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBtb3ZlU2VsZWN0ZWROb2Rlcztcbn1cblxuY29uc3QgTm9kZUlkQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XG5jb25zdCBQcm92aWRlciA9IE5vZGVJZENvbnRleHQuUHJvdmlkZXI7XG5Ob2RlSWRDb250ZXh0LkNvbnN1bWVyO1xuLyoqXG4gKiBZb3UgY2FuIHVzZSB0aGlzIGhvb2sgdG8gZ2V0IHRoZSBpZCBvZiB0aGUgbm9kZSBpdCBpcyB1c2VkIGluc2lkZS4gSXQgaXMgdXNlZnVsXG4gKiBpZiB5b3UgbmVlZCB0aGUgbm9kZSdzIGlkIGRlZXBlciBpbiB0aGUgcmVuZGVyIHRyZWUgYnV0IGRvbid0IHdhbnQgdG8gbWFudWFsbHlcbiAqIGRyaWxsIGRvd24gdGhlIGlkIGFzIGEgcHJvcC5cbiAqXG4gKiBAcHVibGljXG4gKiBAcmV0dXJucyBUaGUgaWQgZm9yIGEgbm9kZSBpbiB0aGUgZmxvdy5cbiAqXG4gKiBAZXhhbXBsZVxuICpgYGBqc3hcbiAqaW1wb3J0IHsgdXNlTm9kZUlkIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDdXN0b21Ob2RlKCkge1xuICogIHJldHVybiAoXG4gKiAgICA8ZGl2PlxuICogICAgICA8c3Bhbj5UaGlzIG5vZGUgaGFzIGFuIGlkIG9mIDwvc3Bhbj5cbiAqICAgICAgPE5vZGVJZERpc3BsYXkgLz5cbiAqICAgIDwvZGl2PlxuICogICk7XG4gKn1cbiAqXG4gKmZ1bmN0aW9uIE5vZGVJZERpc3BsYXkoKSB7XG4gKiAgY29uc3Qgbm9kZUlkID0gdXNlTm9kZUlkKCk7XG4gKlxuICogIHJldHVybiA8c3Bhbj57bm9kZUlkfTwvc3Bhbj47XG4gKn1cbiAqYGBgXG4gKi9cbmNvbnN0IHVzZU5vZGVJZCA9ICgpID0+IHtcbiAgICBjb25zdCBub2RlSWQgPSB1c2VDb250ZXh0KE5vZGVJZENvbnRleHQpO1xuICAgIHJldHVybiBub2RlSWQ7XG59O1xuXG5jb25zdCBzZWxlY3RvciRnID0gKHMpID0+ICh7XG4gICAgY29ubmVjdE9uQ2xpY2s6IHMuY29ubmVjdE9uQ2xpY2ssXG4gICAgbm9QYW5DbGFzc05hbWU6IHMubm9QYW5DbGFzc05hbWUsXG4gICAgcmZJZDogcy5yZklkLFxufSk7XG5jb25zdCBjb25uZWN0aW5nU2VsZWN0b3IgPSAobm9kZUlkLCBoYW5kbGVJZCwgdHlwZSkgPT4gKHN0YXRlKSA9PiB7XG4gICAgY29uc3QgeyBjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZTogY2xpY2tIYW5kbGUsIGNvbm5lY3Rpb25Nb2RlLCBjb25uZWN0aW9uIH0gPSBzdGF0ZTtcbiAgICBjb25zdCB7IGZyb21IYW5kbGUsIHRvSGFuZGxlLCBpc1ZhbGlkIH0gPSBjb25uZWN0aW9uO1xuICAgIGNvbnN0IGNvbm5lY3RpbmdUbyA9IHRvSGFuZGxlPy5ub2RlSWQgPT09IG5vZGVJZCAmJiB0b0hhbmRsZT8uaWQgPT09IGhhbmRsZUlkICYmIHRvSGFuZGxlPy50eXBlID09PSB0eXBlO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbm5lY3RpbmdGcm9tOiBmcm9tSGFuZGxlPy5ub2RlSWQgPT09IG5vZGVJZCAmJiBmcm9tSGFuZGxlPy5pZCA9PT0gaGFuZGxlSWQgJiYgZnJvbUhhbmRsZT8udHlwZSA9PT0gdHlwZSxcbiAgICAgICAgY29ubmVjdGluZ1RvLFxuICAgICAgICBjbGlja0Nvbm5lY3Rpbmc6IGNsaWNrSGFuZGxlPy5ub2RlSWQgPT09IG5vZGVJZCAmJiBjbGlja0hhbmRsZT8uaWQgPT09IGhhbmRsZUlkICYmIGNsaWNrSGFuZGxlPy50eXBlID09PSB0eXBlLFxuICAgICAgICBpc1Bvc3NpYmxlRW5kSGFuZGxlOiBjb25uZWN0aW9uTW9kZSA9PT0gQ29ubmVjdGlvbk1vZGUuU3RyaWN0XG4gICAgICAgICAgICA/IGZyb21IYW5kbGU/LnR5cGUgIT09IHR5cGVcbiAgICAgICAgICAgIDogbm9kZUlkICE9PSBmcm9tSGFuZGxlPy5ub2RlSWQgfHwgaGFuZGxlSWQgIT09IGZyb21IYW5kbGU/LmlkLFxuICAgICAgICBjb25uZWN0aW9uSW5Qcm9jZXNzOiAhIWZyb21IYW5kbGUsXG4gICAgICAgIGNsaWNrQ29ubmVjdGlvbkluUHJvY2VzczogISFjbGlja0hhbmRsZSxcbiAgICAgICAgdmFsaWQ6IGNvbm5lY3RpbmdUbyAmJiBpc1ZhbGlkLFxuICAgIH07XG59O1xuZnVuY3Rpb24gSGFuZGxlQ29tcG9uZW50KHsgdHlwZSA9ICdzb3VyY2UnLCBwb3NpdGlvbiA9IFBvc2l0aW9uLlRvcCwgaXNWYWxpZENvbm5lY3Rpb24sIGlzQ29ubmVjdGFibGUgPSB0cnVlLCBpc0Nvbm5lY3RhYmxlU3RhcnQgPSB0cnVlLCBpc0Nvbm5lY3RhYmxlRW5kID0gdHJ1ZSwgaWQsIG9uQ29ubmVjdCwgY2hpbGRyZW4sIGNsYXNzTmFtZSwgb25Nb3VzZURvd24sIG9uVG91Y2hTdGFydCwgLi4ucmVzdCB9LCByZWYpIHtcbiAgICBjb25zdCBoYW5kbGVJZCA9IGlkIHx8IG51bGw7XG4gICAgY29uc3QgaXNUYXJnZXQgPSB0eXBlID09PSAndGFyZ2V0JztcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3Qgbm9kZUlkID0gdXNlTm9kZUlkKCk7XG4gICAgY29uc3QgeyBjb25uZWN0T25DbGljaywgbm9QYW5DbGFzc05hbWUsIHJmSWQgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJGcsIHNoYWxsb3cpO1xuICAgIGNvbnN0IHsgY29ubmVjdGluZ0Zyb20sIGNvbm5lY3RpbmdUbywgY2xpY2tDb25uZWN0aW5nLCBpc1Bvc3NpYmxlRW5kSGFuZGxlLCBjb25uZWN0aW9uSW5Qcm9jZXNzLCBjbGlja0Nvbm5lY3Rpb25JblByb2Nlc3MsIHZhbGlkLCB9ID0gdXNlU3RvcmUoY29ubmVjdGluZ1NlbGVjdG9yKG5vZGVJZCwgaGFuZGxlSWQsIHR5cGUpLCBzaGFsbG93KTtcbiAgICBpZiAoIW5vZGVJZCkge1xuICAgICAgICBzdG9yZS5nZXRTdGF0ZSgpLm9uRXJyb3I/LignMDEwJywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMTAnXSgpKTtcbiAgICB9XG4gICAgY29uc3Qgb25Db25uZWN0RXh0ZW5kZWQgPSAocGFyYW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZGVmYXVsdEVkZ2VPcHRpb25zLCBvbkNvbm5lY3Q6IG9uQ29ubmVjdEFjdGlvbiwgaGFzRGVmYXVsdEVkZ2VzIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBjb25zdCBlZGdlUGFyYW1zID0ge1xuICAgICAgICAgICAgLi4uZGVmYXVsdEVkZ2VPcHRpb25zLFxuICAgICAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoaGFzRGVmYXVsdEVkZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCB7IGVkZ2VzLCBzZXRFZGdlcyB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIHNldEVkZ2VzKGFkZEVkZ2UoZWRnZVBhcmFtcywgZWRnZXMpKTtcbiAgICAgICAgfVxuICAgICAgICBvbkNvbm5lY3RBY3Rpb24/LihlZGdlUGFyYW1zKTtcbiAgICAgICAgb25Db25uZWN0Py4oZWRnZVBhcmFtcyk7XG4gICAgfTtcbiAgICBjb25zdCBvblBvaW50ZXJEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmICghbm9kZUlkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNNb3VzZVRyaWdnZXJlZCA9IGlzTW91c2VFdmVudChldmVudC5uYXRpdmVFdmVudCk7XG4gICAgICAgIGlmIChpc0Nvbm5lY3RhYmxlU3RhcnQgJiZcbiAgICAgICAgICAgICgoaXNNb3VzZVRyaWdnZXJlZCAmJiBldmVudC5idXR0b24gPT09IDApIHx8ICFpc01vdXNlVHJpZ2dlcmVkKSkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFN0b3JlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIFhZSGFuZGxlLm9uUG9pbnRlckRvd24oZXZlbnQubmF0aXZlRXZlbnQsIHtcbiAgICAgICAgICAgICAgICBhdXRvUGFuT25Db25uZWN0OiBjdXJyZW50U3RvcmUuYXV0b1Bhbk9uQ29ubmVjdCxcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uTW9kZTogY3VycmVudFN0b3JlLmNvbm5lY3Rpb25Nb2RlLFxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25SYWRpdXM6IGN1cnJlbnRTdG9yZS5jb25uZWN0aW9uUmFkaXVzLFxuICAgICAgICAgICAgICAgIGRvbU5vZGU6IGN1cnJlbnRTdG9yZS5kb21Ob2RlLFxuICAgICAgICAgICAgICAgIG5vZGVMb29rdXA6IGN1cnJlbnRTdG9yZS5ub2RlTG9va3VwLFxuICAgICAgICAgICAgICAgIGxpYjogY3VycmVudFN0b3JlLmxpYixcbiAgICAgICAgICAgICAgICBpc1RhcmdldCxcbiAgICAgICAgICAgICAgICBoYW5kbGVJZCxcbiAgICAgICAgICAgICAgICBub2RlSWQsXG4gICAgICAgICAgICAgICAgZmxvd0lkOiBjdXJyZW50U3RvcmUucmZJZCxcbiAgICAgICAgICAgICAgICBwYW5CeTogY3VycmVudFN0b3JlLnBhbkJ5LFxuICAgICAgICAgICAgICAgIGNhbmNlbENvbm5lY3Rpb246IGN1cnJlbnRTdG9yZS5jYW5jZWxDb25uZWN0aW9uLFxuICAgICAgICAgICAgICAgIG9uQ29ubmVjdFN0YXJ0OiBjdXJyZW50U3RvcmUub25Db25uZWN0U3RhcnQsXG4gICAgICAgICAgICAgICAgb25Db25uZWN0RW5kOiBjdXJyZW50U3RvcmUub25Db25uZWN0RW5kLFxuICAgICAgICAgICAgICAgIHVwZGF0ZUNvbm5lY3Rpb246IGN1cnJlbnRTdG9yZS51cGRhdGVDb25uZWN0aW9uLFxuICAgICAgICAgICAgICAgIG9uQ29ubmVjdDogb25Db25uZWN0RXh0ZW5kZWQsXG4gICAgICAgICAgICAgICAgaXNWYWxpZENvbm5lY3Rpb246IGlzVmFsaWRDb25uZWN0aW9uIHx8IGN1cnJlbnRTdG9yZS5pc1ZhbGlkQ29ubmVjdGlvbixcbiAgICAgICAgICAgICAgICBnZXRUcmFuc2Zvcm06ICgpID0+IHN0b3JlLmdldFN0YXRlKCkudHJhbnNmb3JtLFxuICAgICAgICAgICAgICAgIGdldEZyb21IYW5kbGU6ICgpID0+IHN0b3JlLmdldFN0YXRlKCkuY29ubmVjdGlvbi5mcm9tSGFuZGxlLFxuICAgICAgICAgICAgICAgIGF1dG9QYW5TcGVlZDogY3VycmVudFN0b3JlLmF1dG9QYW5TcGVlZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc01vdXNlVHJpZ2dlcmVkKSB7XG4gICAgICAgICAgICBvbk1vdXNlRG93bj8uKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9uVG91Y2hTdGFydD8uKGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgb25DbGljayA9IChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCB7IG9uQ2xpY2tDb25uZWN0U3RhcnQsIG9uQ2xpY2tDb25uZWN0RW5kLCBjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZSwgY29ubmVjdGlvbk1vZGUsIGlzVmFsaWRDb25uZWN0aW9uOiBpc1ZhbGlkQ29ubmVjdGlvblN0b3JlLCBsaWIsIHJmSWQ6IGZsb3dJZCwgbm9kZUxvb2t1cCwgY29ubmVjdGlvbjogY29ubmVjdGlvblN0YXRlLCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgaWYgKCFub2RlSWQgfHwgKCFjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZSAmJiAhaXNDb25uZWN0YWJsZVN0YXJ0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGUpIHtcbiAgICAgICAgICAgIG9uQ2xpY2tDb25uZWN0U3RhcnQ/LihldmVudC5uYXRpdmVFdmVudCwgeyBub2RlSWQsIGhhbmRsZUlkLCBoYW5kbGVUeXBlOiB0eXBlIH0pO1xuICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZTogeyBub2RlSWQsIHR5cGUsIGlkOiBoYW5kbGVJZCB9IH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRvYyA9IGdldEhvc3RGb3JFbGVtZW50KGV2ZW50LnRhcmdldCk7XG4gICAgICAgIGNvbnN0IGlzVmFsaWRDb25uZWN0aW9uSGFuZGxlciA9IGlzVmFsaWRDb25uZWN0aW9uIHx8IGlzVmFsaWRDb25uZWN0aW9uU3RvcmU7XG4gICAgICAgIGNvbnN0IHsgY29ubmVjdGlvbiwgaXNWYWxpZCB9ID0gWFlIYW5kbGUuaXNWYWxpZChldmVudC5uYXRpdmVFdmVudCwge1xuICAgICAgICAgICAgaGFuZGxlOiB7XG4gICAgICAgICAgICAgICAgbm9kZUlkLFxuICAgICAgICAgICAgICAgIGlkOiBoYW5kbGVJZCxcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbm5lY3Rpb25Nb2RlLFxuICAgICAgICAgICAgZnJvbU5vZGVJZDogY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGUubm9kZUlkLFxuICAgICAgICAgICAgZnJvbUhhbmRsZUlkOiBjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZS5pZCB8fCBudWxsLFxuICAgICAgICAgICAgZnJvbVR5cGU6IGNvbm5lY3Rpb25DbGlja1N0YXJ0SGFuZGxlLnR5cGUsXG4gICAgICAgICAgICBpc1ZhbGlkQ29ubmVjdGlvbjogaXNWYWxpZENvbm5lY3Rpb25IYW5kbGVyLFxuICAgICAgICAgICAgZmxvd0lkLFxuICAgICAgICAgICAgZG9jLFxuICAgICAgICAgICAgbGliLFxuICAgICAgICAgICAgbm9kZUxvb2t1cCxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc1ZhbGlkICYmIGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIG9uQ29ubmVjdEV4dGVuZGVkKGNvbm5lY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb25DbG9uZSA9IHN0cnVjdHVyZWRDbG9uZShjb25uZWN0aW9uU3RhdGUpO1xuICAgICAgICBkZWxldGUgY29ubmVjdGlvbkNsb25lLmluUHJvZ3Jlc3M7XG4gICAgICAgIGNvbm5lY3Rpb25DbG9uZS50b1Bvc2l0aW9uID0gY29ubmVjdGlvbkNsb25lLnRvSGFuZGxlID8gY29ubmVjdGlvbkNsb25lLnRvSGFuZGxlLnBvc2l0aW9uIDogbnVsbDtcbiAgICAgICAgb25DbGlja0Nvbm5lY3RFbmQ/LihldmVudCwgY29ubmVjdGlvbkNsb25lKTtcbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZTogbnVsbCB9KTtcbiAgICB9O1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgXCJkYXRhLWhhbmRsZWlkXCI6IGhhbmRsZUlkLCBcImRhdGEtbm9kZWlkXCI6IG5vZGVJZCwgXCJkYXRhLWhhbmRsZXBvc1wiOiBwb3NpdGlvbiwgXCJkYXRhLWlkXCI6IGAke3JmSWR9LSR7bm9kZUlkfS0ke2hhbmRsZUlkfS0ke3R5cGV9YCwgY2xhc3NOYW1lOiBjYyhbXG4gICAgICAgICAgICAncmVhY3QtZmxvd19faGFuZGxlJyxcbiAgICAgICAgICAgIGByZWFjdC1mbG93X19oYW5kbGUtJHtwb3NpdGlvbn1gLFxuICAgICAgICAgICAgJ25vZHJhZycsXG4gICAgICAgICAgICBub1BhbkNsYXNzTmFtZSxcbiAgICAgICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6ICFpc1RhcmdldCxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGlzVGFyZ2V0LFxuICAgICAgICAgICAgICAgIGNvbm5lY3RhYmxlOiBpc0Nvbm5lY3RhYmxlLFxuICAgICAgICAgICAgICAgIGNvbm5lY3RhYmxlc3RhcnQ6IGlzQ29ubmVjdGFibGVTdGFydCxcbiAgICAgICAgICAgICAgICBjb25uZWN0YWJsZWVuZDogaXNDb25uZWN0YWJsZUVuZCxcbiAgICAgICAgICAgICAgICBjbGlja2Nvbm5lY3Rpbmc6IGNsaWNrQ29ubmVjdGluZyxcbiAgICAgICAgICAgICAgICBjb25uZWN0aW5nZnJvbTogY29ubmVjdGluZ0Zyb20sXG4gICAgICAgICAgICAgICAgY29ubmVjdGluZ3RvOiBjb25uZWN0aW5nVG8sXG4gICAgICAgICAgICAgICAgdmFsaWQsXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBzaG93cyB3aGVyZSB5b3UgY2FuIHN0YXJ0IGEgY29ubmVjdGlvbiBmcm9tXG4gICAgICAgICAgICAgICAgICogYW5kIHdoZXJlIHlvdSBjYW4gZW5kIGl0IHdoaWxlIGNvbm5lY3RpbmdcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uaW5kaWNhdG9yOiBpc0Nvbm5lY3RhYmxlICYmXG4gICAgICAgICAgICAgICAgICAgICghY29ubmVjdGlvbkluUHJvY2VzcyB8fCBpc1Bvc3NpYmxlRW5kSGFuZGxlKSAmJlxuICAgICAgICAgICAgICAgICAgICAoY29ubmVjdGlvbkluUHJvY2VzcyB8fCBjbGlja0Nvbm5lY3Rpb25JblByb2Nlc3MgPyBpc0Nvbm5lY3RhYmxlRW5kIDogaXNDb25uZWN0YWJsZVN0YXJ0KSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pLCBvbk1vdXNlRG93bjogb25Qb2ludGVyRG93biwgb25Ub3VjaFN0YXJ0OiBvblBvaW50ZXJEb3duLCBvbkNsaWNrOiBjb25uZWN0T25DbGljayA/IG9uQ2xpY2sgOiB1bmRlZmluZWQsIHJlZjogcmVmLCAuLi5yZXN0LCBjaGlsZHJlbjogY2hpbGRyZW4gfSkpO1xufVxuLyoqXG4gKiBUaGUgYDxIYW5kbGUgLz5gIGNvbXBvbmVudCBpcyB1c2VkIGluIHlvdXIgW2N1c3RvbSBub2Rlc10oL2xlYXJuL2N1c3RvbWl6YXRpb24vY3VzdG9tLW5vZGVzKVxuICogdG8gZGVmaW5lIGNvbm5lY3Rpb24gcG9pbnRzLlxuICpcbiAqQHB1YmxpY1xuICpcbiAqQGV4YW1wbGVcbiAqXG4gKmBgYGpzeFxuICppbXBvcnQgeyBIYW5kbGUsIFBvc2l0aW9uIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZnVuY3Rpb24gQ3VzdG9tTm9kZSh7IGRhdGEgfSkge1xuICogIHJldHVybiAoXG4gKiAgICA8PlxuICogICAgICA8ZGl2IHN0eWxlPXt7IHBhZGRpbmc6ICcxMHB4IDIwcHgnIH19PlxuICogICAgICAgIHtkYXRhLmxhYmVsfVxuICogICAgICA8L2Rpdj5cbiAqXG4gKiAgICAgIDxIYW5kbGUgdHlwZT1cInRhcmdldFwiIHBvc2l0aW9uPXtQb3NpdGlvbi5MZWZ0fSAvPlxuICogICAgICA8SGFuZGxlIHR5cGU9XCJzb3VyY2VcIiBwb3NpdGlvbj17UG9zaXRpb24uUmlnaHR9IC8+XG4gKiAgICA8Lz5cbiAqICApO1xuICp9O1xuICpgYGBcbiAqL1xuY29uc3QgSGFuZGxlID0gbWVtbyhmaXhlZEZvcndhcmRSZWYoSGFuZGxlQ29tcG9uZW50KSk7XG5cbmZ1bmN0aW9uIElucHV0Tm9kZSh7IGRhdGEsIGlzQ29ubmVjdGFibGUsIHNvdXJjZVBvc2l0aW9uID0gUG9zaXRpb24uQm90dG9tIH0pIHtcbiAgICByZXR1cm4gKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtkYXRhPy5sYWJlbCwganN4KEhhbmRsZSwgeyB0eXBlOiBcInNvdXJjZVwiLCBwb3NpdGlvbjogc291cmNlUG9zaXRpb24sIGlzQ29ubmVjdGFibGU6IGlzQ29ubmVjdGFibGUgfSldIH0pKTtcbn1cblxuZnVuY3Rpb24gRGVmYXVsdE5vZGUoeyBkYXRhLCBpc0Nvbm5lY3RhYmxlLCB0YXJnZXRQb3NpdGlvbiA9IFBvc2l0aW9uLlRvcCwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20sIH0pIHtcbiAgICByZXR1cm4gKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtqc3goSGFuZGxlLCB7IHR5cGU6IFwidGFyZ2V0XCIsIHBvc2l0aW9uOiB0YXJnZXRQb3NpdGlvbiwgaXNDb25uZWN0YWJsZTogaXNDb25uZWN0YWJsZSB9KSwgZGF0YT8ubGFiZWwsIGpzeChIYW5kbGUsIHsgdHlwZTogXCJzb3VyY2VcIiwgcG9zaXRpb246IHNvdXJjZVBvc2l0aW9uLCBpc0Nvbm5lY3RhYmxlOiBpc0Nvbm5lY3RhYmxlIH0pXSB9KSk7XG59XG5cbmZ1bmN0aW9uIEdyb3VwTm9kZSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gT3V0cHV0Tm9kZSh7IGRhdGEsIGlzQ29ubmVjdGFibGUsIHRhcmdldFBvc2l0aW9uID0gUG9zaXRpb24uVG9wIH0pIHtcbiAgICByZXR1cm4gKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtqc3goSGFuZGxlLCB7IHR5cGU6IFwidGFyZ2V0XCIsIHBvc2l0aW9uOiB0YXJnZXRQb3NpdGlvbiwgaXNDb25uZWN0YWJsZTogaXNDb25uZWN0YWJsZSB9KSwgZGF0YT8ubGFiZWxdIH0pKTtcbn1cblxuY29uc3QgYXJyb3dLZXlEaWZmcyA9IHtcbiAgICBBcnJvd1VwOiB7IHg6IDAsIHk6IC0xIH0sXG4gICAgQXJyb3dEb3duOiB7IHg6IDAsIHk6IDEgfSxcbiAgICBBcnJvd0xlZnQ6IHsgeDogLTEsIHk6IDAgfSxcbiAgICBBcnJvd1JpZ2h0OiB7IHg6IDEsIHk6IDAgfSxcbn07XG5jb25zdCBidWlsdGluTm9kZVR5cGVzID0ge1xuICAgIGlucHV0OiBJbnB1dE5vZGUsXG4gICAgZGVmYXVsdDogRGVmYXVsdE5vZGUsXG4gICAgb3V0cHV0OiBPdXRwdXROb2RlLFxuICAgIGdyb3VwOiBHcm91cE5vZGUsXG59O1xuZnVuY3Rpb24gZ2V0Tm9kZUlubGluZVN0eWxlRGltZW5zaW9ucyhub2RlKSB7XG4gICAgaWYgKG5vZGUuaW50ZXJuYWxzLmhhbmRsZUJvdW5kcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogbm9kZS53aWR0aCA/PyBub2RlLmluaXRpYWxXaWR0aCA/PyBub2RlLnN0eWxlPy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogbm9kZS5oZWlnaHQgPz8gbm9kZS5pbml0aWFsSGVpZ2h0ID8/IG5vZGUuc3R5bGU/LmhlaWdodCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IG5vZGUud2lkdGggPz8gbm9kZS5zdHlsZT8ud2lkdGgsXG4gICAgICAgIGhlaWdodDogbm9kZS5oZWlnaHQgPz8gbm9kZS5zdHlsZT8uaGVpZ2h0LFxuICAgIH07XG59XG5cbmNvbnN0IHNlbGVjdG9yJGYgPSAocykgPT4ge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgeCwgeSB9ID0gZ2V0SW50ZXJuYWxOb2Rlc0JvdW5kcyhzLm5vZGVMb29rdXAsIHtcbiAgICAgICAgZmlsdGVyOiAobm9kZSkgPT4gISFub2RlLnNlbGVjdGVkLFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiBpc051bWVyaWMod2lkdGgpID8gd2lkdGggOiBudWxsLFxuICAgICAgICBoZWlnaHQ6IGlzTnVtZXJpYyhoZWlnaHQpID8gaGVpZ2h0IDogbnVsbCxcbiAgICAgICAgdXNlclNlbGVjdGlvbkFjdGl2ZTogcy51c2VyU2VsZWN0aW9uQWN0aXZlLFxuICAgICAgICB0cmFuc2Zvcm1TdHJpbmc6IGB0cmFuc2xhdGUoJHtzLnRyYW5zZm9ybVswXX1weCwke3MudHJhbnNmb3JtWzFdfXB4KSBzY2FsZSgke3MudHJhbnNmb3JtWzJdfSkgdHJhbnNsYXRlKCR7eH1weCwke3l9cHgpYCxcbiAgICB9O1xufTtcbmZ1bmN0aW9uIE5vZGVzU2VsZWN0aW9uKHsgb25TZWxlY3Rpb25Db250ZXh0TWVudSwgbm9QYW5DbGFzc05hbWUsIGRpc2FibGVLZXlib2FyZEExMXksIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCB0cmFuc2Zvcm1TdHJpbmcsIHVzZXJTZWxlY3Rpb25BY3RpdmUgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJGYsIHNoYWxsb3cpO1xuICAgIGNvbnN0IG1vdmVTZWxlY3RlZE5vZGVzID0gdXNlTW92ZVNlbGVjdGVkTm9kZXMoKTtcbiAgICBjb25zdCBub2RlUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghZGlzYWJsZUtleWJvYXJkQTExeSkge1xuICAgICAgICAgICAgbm9kZVJlZi5jdXJyZW50Py5mb2N1cyh7XG4gICAgICAgICAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgW2Rpc2FibGVLZXlib2FyZEExMXldKTtcbiAgICB1c2VEcmFnKHtcbiAgICAgICAgbm9kZVJlZixcbiAgICB9KTtcbiAgICBpZiAodXNlclNlbGVjdGlvbkFjdGl2ZSB8fCAhd2lkdGggfHwgIWhlaWdodCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgb25Db250ZXh0TWVudSA9IG9uU2VsZWN0aW9uQ29udGV4dE1lbnVcbiAgICAgICAgPyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkTm9kZXMgPSBzdG9yZS5nZXRTdGF0ZSgpLm5vZGVzLmZpbHRlcigobikgPT4gbi5zZWxlY3RlZCk7XG4gICAgICAgICAgICBvblNlbGVjdGlvbkNvbnRleHRNZW51KGV2ZW50LCBzZWxlY3RlZE5vZGVzKTtcbiAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvbktleURvd24gPSAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhcnJvd0tleURpZmZzLCBldmVudC5rZXkpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgbW92ZVNlbGVjdGVkTm9kZXMoe1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogYXJyb3dLZXlEaWZmc1tldmVudC5rZXldLFxuICAgICAgICAgICAgICAgIGZhY3RvcjogZXZlbnQuc2hpZnRLZXkgPyA0IDogMSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19ub2Rlc3NlbGVjdGlvbicsICdyZWFjdC1mbG93X19jb250YWluZXInLCBub1BhbkNsYXNzTmFtZV0pLCBzdHlsZToge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm1TdHJpbmcsXG4gICAgICAgIH0sIGNoaWxkcmVuOiBqc3goXCJkaXZcIiwgeyByZWY6IG5vZGVSZWYsIGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19ub2Rlc3NlbGVjdGlvbi1yZWN0XCIsIG9uQ29udGV4dE1lbnU6IG9uQ29udGV4dE1lbnUsIHRhYkluZGV4OiBkaXNhYmxlS2V5Ym9hcmRBMTF5ID8gdW5kZWZpbmVkIDogLTEsIG9uS2V5RG93bjogZGlzYWJsZUtleWJvYXJkQTExeSA/IHVuZGVmaW5lZCA6IG9uS2V5RG93biwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICB9IH0pIH0pKTtcbn1cblxuY29uc3Qgd2luID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB1bmRlZmluZWQ7XG5jb25zdCBzZWxlY3RvciRlID0gKHMpID0+IHtcbiAgICByZXR1cm4geyBub2Rlc1NlbGVjdGlvbkFjdGl2ZTogcy5ub2Rlc1NlbGVjdGlvbkFjdGl2ZSwgdXNlclNlbGVjdGlvbkFjdGl2ZTogcy51c2VyU2VsZWN0aW9uQWN0aXZlIH07XG59O1xuZnVuY3Rpb24gRmxvd1JlbmRlcmVyQ29tcG9uZW50KHsgY2hpbGRyZW4sIG9uUGFuZUNsaWNrLCBvblBhbmVNb3VzZUVudGVyLCBvblBhbmVNb3VzZU1vdmUsIG9uUGFuZU1vdXNlTGVhdmUsIG9uUGFuZUNvbnRleHRNZW51LCBvblBhbmVTY3JvbGwsIHBhbmVDbGlja0Rpc3RhbmNlLCBkZWxldGVLZXlDb2RlLCBzZWxlY3Rpb25LZXlDb2RlLCBzZWxlY3Rpb25PbkRyYWcsIHNlbGVjdGlvbk1vZGUsIG9uU2VsZWN0aW9uU3RhcnQsIG9uU2VsZWN0aW9uRW5kLCBtdWx0aVNlbGVjdGlvbktleUNvZGUsIHBhbkFjdGl2YXRpb25LZXlDb2RlLCB6b29tQWN0aXZhdGlvbktleUNvZGUsIGVsZW1lbnRzU2VsZWN0YWJsZSwgem9vbU9uU2Nyb2xsLCB6b29tT25QaW5jaCwgcGFuT25TY3JvbGw6IF9wYW5PblNjcm9sbCwgcGFuT25TY3JvbGxTcGVlZCwgcGFuT25TY3JvbGxNb2RlLCB6b29tT25Eb3VibGVDbGljaywgcGFuT25EcmFnOiBfcGFuT25EcmFnLCBkZWZhdWx0Vmlld3BvcnQsIHRyYW5zbGF0ZUV4dGVudCwgbWluWm9vbSwgbWF4Wm9vbSwgcHJldmVudFNjcm9sbGluZywgb25TZWxlY3Rpb25Db250ZXh0TWVudSwgbm9XaGVlbENsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWUsIGRpc2FibGVLZXlib2FyZEExMXksIG9uVmlld3BvcnRDaGFuZ2UsIGlzQ29udHJvbGxlZFZpZXdwb3J0LCB9KSB7XG4gICAgY29uc3QgeyBub2Rlc1NlbGVjdGlvbkFjdGl2ZSwgdXNlclNlbGVjdGlvbkFjdGl2ZSB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkZSk7XG4gICAgY29uc3Qgc2VsZWN0aW9uS2V5UHJlc3NlZCA9IHVzZUtleVByZXNzKHNlbGVjdGlvbktleUNvZGUsIHsgdGFyZ2V0OiB3aW4gfSk7XG4gICAgY29uc3QgcGFuQWN0aXZhdGlvbktleVByZXNzZWQgPSB1c2VLZXlQcmVzcyhwYW5BY3RpdmF0aW9uS2V5Q29kZSwgeyB0YXJnZXQ6IHdpbiB9KTtcbiAgICBjb25zdCBwYW5PbkRyYWcgPSBwYW5BY3RpdmF0aW9uS2V5UHJlc3NlZCB8fCBfcGFuT25EcmFnO1xuICAgIGNvbnN0IHBhbk9uU2Nyb2xsID0gcGFuQWN0aXZhdGlvbktleVByZXNzZWQgfHwgX3Bhbk9uU2Nyb2xsO1xuICAgIGNvbnN0IF9zZWxlY3Rpb25PbkRyYWcgPSBzZWxlY3Rpb25PbkRyYWcgJiYgcGFuT25EcmFnICE9PSB0cnVlO1xuICAgIGNvbnN0IGlzU2VsZWN0aW5nID0gc2VsZWN0aW9uS2V5UHJlc3NlZCB8fCB1c2VyU2VsZWN0aW9uQWN0aXZlIHx8IF9zZWxlY3Rpb25PbkRyYWc7XG4gICAgdXNlR2xvYmFsS2V5SGFuZGxlcih7IGRlbGV0ZUtleUNvZGUsIG11bHRpU2VsZWN0aW9uS2V5Q29kZSB9KTtcbiAgICByZXR1cm4gKGpzeChab29tUGFuZSwgeyBvblBhbmVDb250ZXh0TWVudTogb25QYW5lQ29udGV4dE1lbnUsIGVsZW1lbnRzU2VsZWN0YWJsZTogZWxlbWVudHNTZWxlY3RhYmxlLCB6b29tT25TY3JvbGw6IHpvb21PblNjcm9sbCwgem9vbU9uUGluY2g6IHpvb21PblBpbmNoLCBwYW5PblNjcm9sbDogcGFuT25TY3JvbGwsIHBhbk9uU2Nyb2xsU3BlZWQ6IHBhbk9uU2Nyb2xsU3BlZWQsIHBhbk9uU2Nyb2xsTW9kZTogcGFuT25TY3JvbGxNb2RlLCB6b29tT25Eb3VibGVDbGljazogem9vbU9uRG91YmxlQ2xpY2ssIHBhbk9uRHJhZzogIXNlbGVjdGlvbktleVByZXNzZWQgJiYgcGFuT25EcmFnLCBkZWZhdWx0Vmlld3BvcnQ6IGRlZmF1bHRWaWV3cG9ydCwgdHJhbnNsYXRlRXh0ZW50OiB0cmFuc2xhdGVFeHRlbnQsIG1pblpvb206IG1pblpvb20sIG1heFpvb206IG1heFpvb20sIHpvb21BY3RpdmF0aW9uS2V5Q29kZTogem9vbUFjdGl2YXRpb25LZXlDb2RlLCBwcmV2ZW50U2Nyb2xsaW5nOiBwcmV2ZW50U2Nyb2xsaW5nLCBub1doZWVsQ2xhc3NOYW1lOiBub1doZWVsQ2xhc3NOYW1lLCBub1BhbkNsYXNzTmFtZTogbm9QYW5DbGFzc05hbWUsIG9uVmlld3BvcnRDaGFuZ2U6IG9uVmlld3BvcnRDaGFuZ2UsIGlzQ29udHJvbGxlZFZpZXdwb3J0OiBpc0NvbnRyb2xsZWRWaWV3cG9ydCwgcGFuZUNsaWNrRGlzdGFuY2U6IHBhbmVDbGlja0Rpc3RhbmNlLCBjaGlsZHJlbjoganN4cyhQYW5lLCB7IG9uU2VsZWN0aW9uU3RhcnQ6IG9uU2VsZWN0aW9uU3RhcnQsIG9uU2VsZWN0aW9uRW5kOiBvblNlbGVjdGlvbkVuZCwgb25QYW5lQ2xpY2s6IG9uUGFuZUNsaWNrLCBvblBhbmVNb3VzZUVudGVyOiBvblBhbmVNb3VzZUVudGVyLCBvblBhbmVNb3VzZU1vdmU6IG9uUGFuZU1vdXNlTW92ZSwgb25QYW5lTW91c2VMZWF2ZTogb25QYW5lTW91c2VMZWF2ZSwgb25QYW5lQ29udGV4dE1lbnU6IG9uUGFuZUNvbnRleHRNZW51LCBvblBhbmVTY3JvbGw6IG9uUGFuZVNjcm9sbCwgcGFuT25EcmFnOiBwYW5PbkRyYWcsIGlzU2VsZWN0aW5nOiAhIWlzU2VsZWN0aW5nLCBzZWxlY3Rpb25Nb2RlOiBzZWxlY3Rpb25Nb2RlLCBzZWxlY3Rpb25LZXlQcmVzc2VkOiBzZWxlY3Rpb25LZXlQcmVzc2VkLCBzZWxlY3Rpb25PbkRyYWc6IF9zZWxlY3Rpb25PbkRyYWcsIGNoaWxkcmVuOiBbY2hpbGRyZW4sIG5vZGVzU2VsZWN0aW9uQWN0aXZlICYmIChqc3goTm9kZXNTZWxlY3Rpb24sIHsgb25TZWxlY3Rpb25Db250ZXh0TWVudTogb25TZWxlY3Rpb25Db250ZXh0TWVudSwgbm9QYW5DbGFzc05hbWU6IG5vUGFuQ2xhc3NOYW1lLCBkaXNhYmxlS2V5Ym9hcmRBMTF5OiBkaXNhYmxlS2V5Ym9hcmRBMTF5IH0pKV0gfSkgfSkpO1xufVxuRmxvd1JlbmRlcmVyQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gJ0Zsb3dSZW5kZXJlcic7XG5jb25zdCBGbG93UmVuZGVyZXIgPSBtZW1vKEZsb3dSZW5kZXJlckNvbXBvbmVudCk7XG5cbmNvbnN0IHNlbGVjdG9yJGQgPSAob25seVJlbmRlclZpc2libGUpID0+IChzKSA9PiB7XG4gICAgcmV0dXJuIG9ubHlSZW5kZXJWaXNpYmxlXG4gICAgICAgID8gZ2V0Tm9kZXNJbnNpZGUocy5ub2RlTG9va3VwLCB7IHg6IDAsIHk6IDAsIHdpZHRoOiBzLndpZHRoLCBoZWlnaHQ6IHMuaGVpZ2h0IH0sIHMudHJhbnNmb3JtLCB0cnVlKS5tYXAoKG5vZGUpID0+IG5vZGUuaWQpXG4gICAgICAgIDogQXJyYXkuZnJvbShzLm5vZGVMb29rdXAua2V5cygpKTtcbn07XG4vKipcbiAqIEhvb2sgZm9yIGdldHRpbmcgdGhlIHZpc2libGUgbm9kZSBpZHMgZnJvbSB0aGUgc3RvcmUuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0gb25seVJlbmRlclZpc2libGVcbiAqIEByZXR1cm5zIGFycmF5IHdpdGggdmlzaWJsZSBub2RlIGlkc1xuICovXG5mdW5jdGlvbiB1c2VWaXNpYmxlTm9kZUlkcyhvbmx5UmVuZGVyVmlzaWJsZSkge1xuICAgIGNvbnN0IG5vZGVJZHMgPSB1c2VTdG9yZSh1c2VDYWxsYmFjayhzZWxlY3RvciRkKG9ubHlSZW5kZXJWaXNpYmxlKSwgW29ubHlSZW5kZXJWaXNpYmxlXSksIHNoYWxsb3cpO1xuICAgIHJldHVybiBub2RlSWRzO1xufVxuXG5jb25zdCBzZWxlY3RvciRjID0gKHMpID0+IHMudXBkYXRlTm9kZUludGVybmFscztcbmZ1bmN0aW9uIHVzZVJlc2l6ZU9ic2VydmVyKCkge1xuICAgIGNvbnN0IHVwZGF0ZU5vZGVJbnRlcm5hbHMgPSB1c2VTdG9yZShzZWxlY3RvciRjKTtcbiAgICBjb25zdCBbcmVzaXplT2JzZXJ2ZXJdID0gdXNlU3RhdGUoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIFJlc2l6ZU9ic2VydmVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZXNpemVPYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGVudHJpZXMuZm9yRWFjaCgoZW50cnkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZCA9IGVudHJ5LnRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVzLnNldChpZCwge1xuICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgbm9kZUVsZW1lbnQ6IGVudHJ5LnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgZm9yY2U6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHVwZGF0ZU5vZGVJbnRlcm5hbHModXBkYXRlcyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICByZXNpemVPYnNlcnZlcj8uZGlzY29ubmVjdCgpO1xuICAgICAgICB9O1xuICAgIH0sIFtyZXNpemVPYnNlcnZlcl0pO1xuICAgIHJldHVybiByZXNpemVPYnNlcnZlcjtcbn1cblxuLyoqXG4gKiBIb29rIHRvIGhhbmRsZSB0aGUgcmVzaXplIG9ic2VydmF0aW9uICsgaW50ZXJuYWwgdXBkYXRlcyBmb3IgdGhlIHBhc3NlZCBub2RlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHJldHVybnMgbm9kZVJlZiAtIHJlZmVyZW5jZSB0byB0aGUgbm9kZSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHVzZU5vZGVPYnNlcnZlcih7IG5vZGUsIG5vZGVUeXBlLCBoYXNEaW1lbnNpb25zLCByZXNpemVPYnNlcnZlciwgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCBub2RlUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IG9ic2VydmVkTm9kZSA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBwcmV2U291cmNlUG9zaXRpb24gPSB1c2VSZWYobm9kZS5zb3VyY2VQb3NpdGlvbik7XG4gICAgY29uc3QgcHJldlRhcmdldFBvc2l0aW9uID0gdXNlUmVmKG5vZGUudGFyZ2V0UG9zaXRpb24pO1xuICAgIGNvbnN0IHByZXZUeXBlID0gdXNlUmVmKG5vZGVUeXBlKTtcbiAgICBjb25zdCBpc0luaXRpYWxpemVkID0gaGFzRGltZW5zaW9ucyAmJiAhIW5vZGUuaW50ZXJuYWxzLmhhbmRsZUJvdW5kcztcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAobm9kZVJlZi5jdXJyZW50ICYmICFub2RlLmhpZGRlbiAmJiAoIWlzSW5pdGlhbGl6ZWQgfHwgb2JzZXJ2ZWROb2RlLmN1cnJlbnQgIT09IG5vZGVSZWYuY3VycmVudCkpIHtcbiAgICAgICAgICAgIGlmIChvYnNlcnZlZE5vZGUuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyPy51bm9ic2VydmUob2JzZXJ2ZWROb2RlLmN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXI/Lm9ic2VydmUobm9kZVJlZi5jdXJyZW50KTtcbiAgICAgICAgICAgIG9ic2VydmVkTm9kZS5jdXJyZW50ID0gbm9kZVJlZi5jdXJyZW50O1xuICAgICAgICB9XG4gICAgfSwgW2lzSW5pdGlhbGl6ZWQsIG5vZGUuaGlkZGVuXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGlmIChvYnNlcnZlZE5vZGUuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyPy51bm9ic2VydmUob2JzZXJ2ZWROb2RlLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIG9ic2VydmVkTm9kZS5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKG5vZGVSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIHdoZW4gdGhlIHVzZXIgcHJvZ3JhbW1hdGljYWxseSBjaGFuZ2VzIHRoZSBzb3VyY2Ugb3IgaGFuZGxlIHBvc2l0aW9uLCB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgaW50ZXJuYWxzXG4gICAgICAgICAgICAgKiB0byBtYWtlIHN1cmUgdGhlIGVkZ2VzIGFyZSB1cGRhdGVkIGNvcnJlY3RseVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCB0eXBlQ2hhbmdlZCA9IHByZXZUeXBlLmN1cnJlbnQgIT09IG5vZGVUeXBlO1xuICAgICAgICAgICAgY29uc3Qgc291cmNlUG9zQ2hhbmdlZCA9IHByZXZTb3VyY2VQb3NpdGlvbi5jdXJyZW50ICE9PSBub2RlLnNvdXJjZVBvc2l0aW9uO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0UG9zQ2hhbmdlZCA9IHByZXZUYXJnZXRQb3NpdGlvbi5jdXJyZW50ICE9PSBub2RlLnRhcmdldFBvc2l0aW9uO1xuICAgICAgICAgICAgaWYgKHR5cGVDaGFuZ2VkIHx8IHNvdXJjZVBvc0NoYW5nZWQgfHwgdGFyZ2V0UG9zQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHByZXZUeXBlLmN1cnJlbnQgPSBub2RlVHlwZTtcbiAgICAgICAgICAgICAgICBwcmV2U291cmNlUG9zaXRpb24uY3VycmVudCA9IG5vZGUuc291cmNlUG9zaXRpb247XG4gICAgICAgICAgICAgICAgcHJldlRhcmdldFBvc2l0aW9uLmN1cnJlbnQgPSBub2RlLnRhcmdldFBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIHN0b3JlXG4gICAgICAgICAgICAgICAgICAgIC5nZXRTdGF0ZSgpXG4gICAgICAgICAgICAgICAgICAgIC51cGRhdGVOb2RlSW50ZXJuYWxzKG5ldyBNYXAoW1tub2RlLmlkLCB7IGlkOiBub2RlLmlkLCBub2RlRWxlbWVudDogbm9kZVJlZi5jdXJyZW50LCBmb3JjZTogdHJ1ZSB9XV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtub2RlLmlkLCBub2RlVHlwZSwgbm9kZS5zb3VyY2VQb3NpdGlvbiwgbm9kZS50YXJnZXRQb3NpdGlvbl0pO1xuICAgIHJldHVybiBub2RlUmVmO1xufVxuXG5mdW5jdGlvbiBOb2RlV3JhcHBlcih7IGlkLCBvbkNsaWNrLCBvbk1vdXNlRW50ZXIsIG9uTW91c2VNb3ZlLCBvbk1vdXNlTGVhdmUsIG9uQ29udGV4dE1lbnUsIG9uRG91YmxlQ2xpY2ssIG5vZGVzRHJhZ2dhYmxlLCBlbGVtZW50c1NlbGVjdGFibGUsIG5vZGVzQ29ubmVjdGFibGUsIG5vZGVzRm9jdXNhYmxlLCByZXNpemVPYnNlcnZlciwgbm9EcmFnQ2xhc3NOYW1lLCBub1BhbkNsYXNzTmFtZSwgZGlzYWJsZUtleWJvYXJkQTExeSwgcmZJZCwgbm9kZVR5cGVzLCBub2RlQ2xpY2tEaXN0YW5jZSwgb25FcnJvciwgfSkge1xuICAgIGNvbnN0IHsgbm9kZSwgaW50ZXJuYWxzLCBpc1BhcmVudCB9ID0gdXNlU3RvcmUoKHMpID0+IHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHMubm9kZUxvb2t1cC5nZXQoaWQpO1xuICAgICAgICBjb25zdCBpc1BhcmVudCA9IHMucGFyZW50TG9va3VwLmhhcyhpZCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgaW50ZXJuYWxzOiBub2RlLmludGVybmFscyxcbiAgICAgICAgICAgIGlzUGFyZW50LFxuICAgICAgICB9O1xuICAgIH0sIHNoYWxsb3cpO1xuICAgIGxldCBub2RlVHlwZSA9IG5vZGUudHlwZSB8fCAnZGVmYXVsdCc7XG4gICAgbGV0IE5vZGVDb21wb25lbnQgPSBub2RlVHlwZXM/Lltub2RlVHlwZV0gfHwgYnVpbHRpbk5vZGVUeXBlc1tub2RlVHlwZV07XG4gICAgaWYgKE5vZGVDb21wb25lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvbkVycm9yPy4oJzAwMycsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDAzJ10obm9kZVR5cGUpKTtcbiAgICAgICAgbm9kZVR5cGUgPSAnZGVmYXVsdCc7XG4gICAgICAgIE5vZGVDb21wb25lbnQgPSBidWlsdGluTm9kZVR5cGVzLmRlZmF1bHQ7XG4gICAgfVxuICAgIGNvbnN0IGlzRHJhZ2dhYmxlID0gISEobm9kZS5kcmFnZ2FibGUgfHwgKG5vZGVzRHJhZ2dhYmxlICYmIHR5cGVvZiBub2RlLmRyYWdnYWJsZSA9PT0gJ3VuZGVmaW5lZCcpKTtcbiAgICBjb25zdCBpc1NlbGVjdGFibGUgPSAhIShub2RlLnNlbGVjdGFibGUgfHwgKGVsZW1lbnRzU2VsZWN0YWJsZSAmJiB0eXBlb2Ygbm9kZS5zZWxlY3RhYmxlID09PSAndW5kZWZpbmVkJykpO1xuICAgIGNvbnN0IGlzQ29ubmVjdGFibGUgPSAhIShub2RlLmNvbm5lY3RhYmxlIHx8IChub2Rlc0Nvbm5lY3RhYmxlICYmIHR5cGVvZiBub2RlLmNvbm5lY3RhYmxlID09PSAndW5kZWZpbmVkJykpO1xuICAgIGNvbnN0IGlzRm9jdXNhYmxlID0gISEobm9kZS5mb2N1c2FibGUgfHwgKG5vZGVzRm9jdXNhYmxlICYmIHR5cGVvZiBub2RlLmZvY3VzYWJsZSA9PT0gJ3VuZGVmaW5lZCcpKTtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgaGFzRGltZW5zaW9ucyA9IG5vZGVIYXNEaW1lbnNpb25zKG5vZGUpO1xuICAgIGNvbnN0IG5vZGVSZWYgPSB1c2VOb2RlT2JzZXJ2ZXIoeyBub2RlLCBub2RlVHlwZSwgaGFzRGltZW5zaW9ucywgcmVzaXplT2JzZXJ2ZXIgfSk7XG4gICAgY29uc3QgZHJhZ2dpbmcgPSB1c2VEcmFnKHtcbiAgICAgICAgbm9kZVJlZixcbiAgICAgICAgZGlzYWJsZWQ6IG5vZGUuaGlkZGVuIHx8ICFpc0RyYWdnYWJsZSxcbiAgICAgICAgbm9EcmFnQ2xhc3NOYW1lLFxuICAgICAgICBoYW5kbGVTZWxlY3Rvcjogbm9kZS5kcmFnSGFuZGxlLFxuICAgICAgICBub2RlSWQ6IGlkLFxuICAgICAgICBpc1NlbGVjdGFibGUsXG4gICAgICAgIG5vZGVDbGlja0Rpc3RhbmNlLFxuICAgIH0pO1xuICAgIGNvbnN0IG1vdmVTZWxlY3RlZE5vZGVzID0gdXNlTW92ZVNlbGVjdGVkTm9kZXMoKTtcbiAgICBpZiAobm9kZS5oaWRkZW4pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG5vZGVEaW1lbnNpb25zID0gZ2V0Tm9kZURpbWVuc2lvbnMobm9kZSk7XG4gICAgY29uc3QgaW5saW5lRGltZW5zaW9ucyA9IGdldE5vZGVJbmxpbmVTdHlsZURpbWVuc2lvbnMobm9kZSk7XG4gICAgY29uc3QgaGFzUG9pbnRlckV2ZW50cyA9IGlzU2VsZWN0YWJsZSB8fCBpc0RyYWdnYWJsZSB8fCBvbkNsaWNrIHx8IG9uTW91c2VFbnRlciB8fCBvbk1vdXNlTW92ZSB8fCBvbk1vdXNlTGVhdmU7XG4gICAgY29uc3Qgb25Nb3VzZUVudGVySGFuZGxlciA9IG9uTW91c2VFbnRlclxuICAgICAgICA/IChldmVudCkgPT4gb25Nb3VzZUVudGVyKGV2ZW50LCB7IC4uLmludGVybmFscy51c2VyTm9kZSB9KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvbk1vdXNlTW92ZUhhbmRsZXIgPSBvbk1vdXNlTW92ZVxuICAgICAgICA/IChldmVudCkgPT4gb25Nb3VzZU1vdmUoZXZlbnQsIHsgLi4uaW50ZXJuYWxzLnVzZXJOb2RlIH0pXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9uTW91c2VMZWF2ZUhhbmRsZXIgPSBvbk1vdXNlTGVhdmVcbiAgICAgICAgPyAoZXZlbnQpID0+IG9uTW91c2VMZWF2ZShldmVudCwgeyAuLi5pbnRlcm5hbHMudXNlck5vZGUgfSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25Db250ZXh0TWVudUhhbmRsZXIgPSBvbkNvbnRleHRNZW51XG4gICAgICAgID8gKGV2ZW50KSA9PiBvbkNvbnRleHRNZW51KGV2ZW50LCB7IC4uLmludGVybmFscy51c2VyTm9kZSB9KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvbkRvdWJsZUNsaWNrSGFuZGxlciA9IG9uRG91YmxlQ2xpY2tcbiAgICAgICAgPyAoZXZlbnQpID0+IG9uRG91YmxlQ2xpY2soZXZlbnQsIHsgLi4uaW50ZXJuYWxzLnVzZXJOb2RlIH0pXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9uU2VsZWN0Tm9kZUhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgeyBzZWxlY3ROb2Rlc09uRHJhZywgbm9kZURyYWdUaHJlc2hvbGQgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGlmIChpc1NlbGVjdGFibGUgJiYgKCFzZWxlY3ROb2Rlc09uRHJhZyB8fCAhaXNEcmFnZ2FibGUgfHwgbm9kZURyYWdUaHJlc2hvbGQgPiAwKSkge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIHRoaXMgaGFuZGxlciBnZXRzIGNhbGxlZCBieSBYWURyYWcgb24gZHJhZyBzdGFydCB3aGVuIHNlbGVjdE5vZGVzT25EcmFnPXRydWVcbiAgICAgICAgICAgICAqIGhlcmUgd2Ugb25seSBuZWVkIHRvIGNhbGwgaXQgd2hlbiBzZWxlY3ROb2Rlc09uRHJhZz1mYWxzZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBoYW5kbGVOb2RlQ2xpY2soe1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIHN0b3JlLFxuICAgICAgICAgICAgICAgIG5vZGVSZWYsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25DbGljaykge1xuICAgICAgICAgICAgb25DbGljayhldmVudCwgeyAuLi5pbnRlcm5hbHMudXNlck5vZGUgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG9uS2V5RG93biA9IChldmVudCkgPT4ge1xuICAgICAgICBpZiAoaXNJbnB1dERPTU5vZGUoZXZlbnQubmF0aXZlRXZlbnQpIHx8IGRpc2FibGVLZXlib2FyZEExMXkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxlbWVudFNlbGVjdGlvbktleXMuaW5jbHVkZXMoZXZlbnQua2V5KSAmJiBpc1NlbGVjdGFibGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHVuc2VsZWN0ID0gZXZlbnQua2V5ID09PSAnRXNjYXBlJztcbiAgICAgICAgICAgIGhhbmRsZU5vZGVDbGljayh7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgc3RvcmUsXG4gICAgICAgICAgICAgICAgdW5zZWxlY3QsXG4gICAgICAgICAgICAgICAgbm9kZVJlZixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRHJhZ2dhYmxlICYmIG5vZGUuc2VsZWN0ZWQgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFycm93S2V5RGlmZnMsIGV2ZW50LmtleSkpIHtcbiAgICAgICAgICAgIC8vIHByZXZlbnQgZGVmYXVsdCBzY3JvbGxpbmcgYmVoYXZpb3Igb24gYXJyb3cga2V5IHByZXNzIHdoZW4gbm9kZSBpcyBtb3ZlZFxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgYXJpYUxhYmVsQ29uZmlnIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGFyaWFMaXZlTWVzc2FnZTogYXJpYUxhYmVsQ29uZmlnWydub2RlLmExMXlEZXNjcmlwdGlvbi5hcmlhTGl2ZU1lc3NhZ2UnXSh7XG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogZXZlbnQua2V5LnJlcGxhY2UoJ0Fycm93JywgJycpLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgICAgIHg6IH5+aW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueCxcbiAgICAgICAgICAgICAgICAgICAgeTogfn5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS55LFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBtb3ZlU2VsZWN0ZWROb2Rlcyh7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBhcnJvd0tleURpZmZzW2V2ZW50LmtleV0sXG4gICAgICAgICAgICAgICAgZmFjdG9yOiBldmVudC5zaGlmdEtleSA/IDQgOiAxLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG9uRm9jdXMgPSAoKSA9PiB7XG4gICAgICAgIGlmIChkaXNhYmxlS2V5Ym9hcmRBMTF5IHx8ICFub2RlUmVmLmN1cnJlbnQ/Lm1hdGNoZXMoJzpmb2N1cy12aXNpYmxlJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHRyYW5zZm9ybSwgd2lkdGgsIGhlaWdodCwgYXV0b1Bhbk9uTm9kZUZvY3VzLCBzZXRDZW50ZXIgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGlmICghYXV0b1Bhbk9uTm9kZUZvY3VzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd2l0aGluVmlld3BvcnQgPSBnZXROb2Rlc0luc2lkZShuZXcgTWFwKFtbaWQsIG5vZGVdXSksIHsgeDogMCwgeTogMCwgd2lkdGgsIGhlaWdodCB9LCB0cmFuc2Zvcm0sIHRydWUpLmxlbmd0aCA+IDA7XG4gICAgICAgIGlmICghd2l0aGluVmlld3BvcnQpIHtcbiAgICAgICAgICAgIHNldENlbnRlcihub2RlLnBvc2l0aW9uLnggKyBub2RlRGltZW5zaW9ucy53aWR0aCAvIDIsIG5vZGUucG9zaXRpb24ueSArIG5vZGVEaW1lbnNpb25zLmhlaWdodCAvIDIsIHtcbiAgICAgICAgICAgICAgICB6b29tOiB0cmFuc2Zvcm1bMl0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNjKFtcbiAgICAgICAgICAgICdyZWFjdC1mbG93X19ub2RlJyxcbiAgICAgICAgICAgIGByZWFjdC1mbG93X19ub2RlLSR7bm9kZVR5cGV9YCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIG92ZXJ3cml0YWJsZSBieSBwYXNzaW5nIGBub3BhbmAgYXMgYSBjbGFzcyBuYW1lXG4gICAgICAgICAgICAgICAgW25vUGFuQ2xhc3NOYW1lXTogaXNEcmFnZ2FibGUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbm9kZS5jbGFzc05hbWUsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQ6IG5vZGUuc2VsZWN0ZWQsXG4gICAgICAgICAgICAgICAgc2VsZWN0YWJsZTogaXNTZWxlY3RhYmxlLFxuICAgICAgICAgICAgICAgIHBhcmVudDogaXNQYXJlbnQsXG4gICAgICAgICAgICAgICAgZHJhZ2dhYmxlOiBpc0RyYWdnYWJsZSxcbiAgICAgICAgICAgICAgICBkcmFnZ2luZyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pLCByZWY6IG5vZGVSZWYsIHN0eWxlOiB7XG4gICAgICAgICAgICB6SW5kZXg6IGludGVybmFscy56LFxuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7aW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueH1weCwke2ludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnl9cHgpYCxcbiAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6IGhhc1BvaW50ZXJFdmVudHMgPyAnYWxsJyA6ICdub25lJyxcbiAgICAgICAgICAgIHZpc2liaWxpdHk6IGhhc0RpbWVuc2lvbnMgPyAndmlzaWJsZScgOiAnaGlkZGVuJyxcbiAgICAgICAgICAgIC4uLm5vZGUuc3R5bGUsXG4gICAgICAgICAgICAuLi5pbmxpbmVEaW1lbnNpb25zLFxuICAgICAgICB9LCBcImRhdGEtaWRcIjogaWQsIFwiZGF0YS10ZXN0aWRcIjogYHJmX19ub2RlLSR7aWR9YCwgb25Nb3VzZUVudGVyOiBvbk1vdXNlRW50ZXJIYW5kbGVyLCBvbk1vdXNlTW92ZTogb25Nb3VzZU1vdmVIYW5kbGVyLCBvbk1vdXNlTGVhdmU6IG9uTW91c2VMZWF2ZUhhbmRsZXIsIG9uQ29udGV4dE1lbnU6IG9uQ29udGV4dE1lbnVIYW5kbGVyLCBvbkNsaWNrOiBvblNlbGVjdE5vZGVIYW5kbGVyLCBvbkRvdWJsZUNsaWNrOiBvbkRvdWJsZUNsaWNrSGFuZGxlciwgb25LZXlEb3duOiBpc0ZvY3VzYWJsZSA/IG9uS2V5RG93biA6IHVuZGVmaW5lZCwgdGFiSW5kZXg6IGlzRm9jdXNhYmxlID8gMCA6IHVuZGVmaW5lZCwgb25Gb2N1czogaXNGb2N1c2FibGUgPyBvbkZvY3VzIDogdW5kZWZpbmVkLCByb2xlOiBub2RlLmFyaWFSb2xlID8/IChpc0ZvY3VzYWJsZSA/ICdncm91cCcgOiB1bmRlZmluZWQpLCBcImFyaWEtcm9sZWRlc2NyaXB0aW9uXCI6IFwibm9kZVwiLCBcImFyaWEtZGVzY3JpYmVkYnlcIjogZGlzYWJsZUtleWJvYXJkQTExeSA/IHVuZGVmaW5lZCA6IGAke0FSSUFfTk9ERV9ERVNDX0tFWX0tJHtyZklkfWAsIFwiYXJpYS1sYWJlbFwiOiBub2RlLmFyaWFMYWJlbCwgLi4ubm9kZS5kb21BdHRyaWJ1dGVzLCBjaGlsZHJlbjoganN4KFByb3ZpZGVyLCB7IHZhbHVlOiBpZCwgY2hpbGRyZW46IGpzeChOb2RlQ29tcG9uZW50LCB7IGlkOiBpZCwgZGF0YTogbm9kZS5kYXRhLCB0eXBlOiBub2RlVHlwZSwgcG9zaXRpb25BYnNvbHV0ZVg6IGludGVybmFscy5wb3NpdGlvbkFic29sdXRlLngsIHBvc2l0aW9uQWJzb2x1dGVZOiBpbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS55LCBzZWxlY3RlZDogbm9kZS5zZWxlY3RlZCA/PyBmYWxzZSwgc2VsZWN0YWJsZTogaXNTZWxlY3RhYmxlLCBkcmFnZ2FibGU6IGlzRHJhZ2dhYmxlLCBkZWxldGFibGU6IG5vZGUuZGVsZXRhYmxlID8/IHRydWUsIGlzQ29ubmVjdGFibGU6IGlzQ29ubmVjdGFibGUsIHNvdXJjZVBvc2l0aW9uOiBub2RlLnNvdXJjZVBvc2l0aW9uLCB0YXJnZXRQb3NpdGlvbjogbm9kZS50YXJnZXRQb3NpdGlvbiwgZHJhZ2dpbmc6IGRyYWdnaW5nLCBkcmFnSGFuZGxlOiBub2RlLmRyYWdIYW5kbGUsIHpJbmRleDogaW50ZXJuYWxzLnosIHBhcmVudElkOiBub2RlLnBhcmVudElkLCAuLi5ub2RlRGltZW5zaW9ucyB9KSB9KSB9KSk7XG59XG5cbmNvbnN0IHNlbGVjdG9yJGIgPSAocykgPT4gKHtcbiAgICBub2Rlc0RyYWdnYWJsZTogcy5ub2Rlc0RyYWdnYWJsZSxcbiAgICBub2Rlc0Nvbm5lY3RhYmxlOiBzLm5vZGVzQ29ubmVjdGFibGUsXG4gICAgbm9kZXNGb2N1c2FibGU6IHMubm9kZXNGb2N1c2FibGUsXG4gICAgZWxlbWVudHNTZWxlY3RhYmxlOiBzLmVsZW1lbnRzU2VsZWN0YWJsZSxcbiAgICBvbkVycm9yOiBzLm9uRXJyb3IsXG59KTtcbmZ1bmN0aW9uIE5vZGVSZW5kZXJlckNvbXBvbmVudChwcm9wcykge1xuICAgIGNvbnN0IHsgbm9kZXNEcmFnZ2FibGUsIG5vZGVzQ29ubmVjdGFibGUsIG5vZGVzRm9jdXNhYmxlLCBlbGVtZW50c1NlbGVjdGFibGUsIG9uRXJyb3IgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJGIsIHNoYWxsb3cpO1xuICAgIGNvbnN0IG5vZGVJZHMgPSB1c2VWaXNpYmxlTm9kZUlkcyhwcm9wcy5vbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzKTtcbiAgICBjb25zdCByZXNpemVPYnNlcnZlciA9IHVzZVJlc2l6ZU9ic2VydmVyKCk7XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fbm9kZXNcIiwgc3R5bGU6IGNvbnRhaW5lclN0eWxlLCBjaGlsZHJlbjogbm9kZUlkcy5tYXAoKG5vZGVJZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBUaGUgc3BsaXQgb2YgcmVzcG9uc2liaWxpdGllcyBiZXR3ZWVuIE5vZGVSZW5kZXJlciBhbmRcbiAgICAgICAgICAgICAqIE5vZGVDb21wb25lbnRXcmFwcGVyIG1heSBhcHBlYXIgd2VpcmQuIEhvd2V2ZXIsIGl04oCZcyBkZXNpZ25lZCB0b1xuICAgICAgICAgICAgICogbWluaW1pemUgdGhlIGNvc3Qgb2YgdXBkYXRlcyB3aGVuIGluZGl2aWR1YWwgbm9kZXMgY2hhbmdlLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEZvciBleGFtcGxlLCB3aGVuIHlvdeKAmXJlIGRyYWdnaW5nIGEgc2luZ2xlIG5vZGUsIHRoYXQgbm9kZSBnZXRzXG4gICAgICAgICAgICAgKiB1cGRhdGVkIG11bHRpcGxlIHRpbWVzIHBlciBzZWNvbmQuIElmIGBOb2RlUmVuZGVyZXJgIHdlcmUgdG8gdXBkYXRlXG4gICAgICAgICAgICAgKiBldmVyeSB0aW1lLCBpdCB3b3VsZCBoYXZlIHRvIHJlLXJ1biB0aGUgYG5vZGVzLm1hcCgpYCBsb29wIGV2ZXJ5XG4gICAgICAgICAgICAgKiB0aW1lLiBUaGlzIGdldHMgcHJpY2V5IHdpdGggaHVuZHJlZHMgb2Ygbm9kZXMsIGVzcGVjaWFsbHkgaWYgZXZlcnlcbiAgICAgICAgICAgICAqIGxvb3AgY3ljbGUgZG9lcyBtb3JlIHRoYW4ganVzdCByZW5kZXJpbmcgYSBKU1ggZWxlbWVudCFcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBBcyBhIHJlc3VsdCBvZiB0aGlzIGNob2ljZSwgd2UgdG9vayB0aGUgZm9sbG93aW5nIGltcGxlbWVudGF0aW9uXG4gICAgICAgICAgICAgKiBkZWNpc2lvbnM6XG4gICAgICAgICAgICAgKiAtIE5vZGVSZW5kZXJlciBzdWJzY3JpYmVzICpvbmx5KiB0byBub2RlIElEcyDigJMgYW5kIHRoZXJlZm9yZVxuICAgICAgICAgICAgICogICByZXJlbmRlciAqb25seSogd2hlbiB2aXNpYmxlIG5vZGVzIGFyZSBhZGRlZCBvciByZW1vdmVkLlxuICAgICAgICAgICAgICogLSBOb2RlUmVuZGVyZXIgcGVyZm9ybXMgYWxsIG9wZXJhdGlvbnMgdGhlIHJlc3VsdCBvZiB3aGljaCBjYW4gYmVcbiAgICAgICAgICAgICAqICAgc2hhcmVkIGJldHdlZW4gbm9kZXMgKHN1Y2ggYXMgY3JlYXRpbmcgdGhlIGBSZXNpemVPYnNlcnZlcmBcbiAgICAgICAgICAgICAqICAgaW5zdGFuY2UsIG9yIHN1YnNjcmliaW5nIHRvIGBzZWxlY3RvcmApLiBUaGlzIG1lYW5zIGV4dHJhIHByb3BcbiAgICAgICAgICAgICAqICAgZHJpbGxpbmcgaW50byBgTm9kZUNvbXBvbmVudFdyYXBwZXJgLCBidXQgaXQgbWVhbnMgd2UgbmVlZCB0byBydW5cbiAgICAgICAgICAgICAqICAgdGhlc2Ugb3BlcmF0aW9ucyBvbmx5IG9uY2Ug4oCTIGluc3RlYWQgb2Ygb25jZSBwZXIgbm9kZS5cbiAgICAgICAgICAgICAqIC0gQW55IG9wZXJhdGlvbnMgdGhhdCB5b3XigJlkIG5vcm1hbGx5IHdyaXRlIGluc2lkZSBgbm9kZXMubWFwYCBhcmVcbiAgICAgICAgICAgICAqICAgbW92ZWQgaW50byBgTm9kZUNvbXBvbmVudFdyYXBwZXJgLiBUaGlzIGVuc3VyZXMgdGhleSBhcmVcbiAgICAgICAgICAgICAqICAgbWVtb3JpemVkIOKAkyBzbyBpZiBgTm9kZVJlbmRlcmVyYCAqaGFzKiB0byByZXJlbmRlciwgaXQgb25seVxuICAgICAgICAgICAgICogICBuZWVkcyB0byByZWdlbmVyYXRlIHRoZSBsaXN0IG9mIG5vZGVzLCBub3RoaW5nIGVsc2UuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGpzeChOb2RlV3JhcHBlciwgeyBpZDogbm9kZUlkLCBub2RlVHlwZXM6IHByb3BzLm5vZGVUeXBlcywgbm9kZUV4dGVudDogcHJvcHMubm9kZUV4dGVudCwgb25DbGljazogcHJvcHMub25Ob2RlQ2xpY2ssIG9uTW91c2VFbnRlcjogcHJvcHMub25Ob2RlTW91c2VFbnRlciwgb25Nb3VzZU1vdmU6IHByb3BzLm9uTm9kZU1vdXNlTW92ZSwgb25Nb3VzZUxlYXZlOiBwcm9wcy5vbk5vZGVNb3VzZUxlYXZlLCBvbkNvbnRleHRNZW51OiBwcm9wcy5vbk5vZGVDb250ZXh0TWVudSwgb25Eb3VibGVDbGljazogcHJvcHMub25Ob2RlRG91YmxlQ2xpY2ssIG5vRHJhZ0NsYXNzTmFtZTogcHJvcHMubm9EcmFnQ2xhc3NOYW1lLCBub1BhbkNsYXNzTmFtZTogcHJvcHMubm9QYW5DbGFzc05hbWUsIHJmSWQ6IHByb3BzLnJmSWQsIGRpc2FibGVLZXlib2FyZEExMXk6IHByb3BzLmRpc2FibGVLZXlib2FyZEExMXksIHJlc2l6ZU9ic2VydmVyOiByZXNpemVPYnNlcnZlciwgbm9kZXNEcmFnZ2FibGU6IG5vZGVzRHJhZ2dhYmxlLCBub2Rlc0Nvbm5lY3RhYmxlOiBub2Rlc0Nvbm5lY3RhYmxlLCBub2Rlc0ZvY3VzYWJsZTogbm9kZXNGb2N1c2FibGUsIGVsZW1lbnRzU2VsZWN0YWJsZTogZWxlbWVudHNTZWxlY3RhYmxlLCBub2RlQ2xpY2tEaXN0YW5jZTogcHJvcHMubm9kZUNsaWNrRGlzdGFuY2UsIG9uRXJyb3I6IG9uRXJyb3IgfSwgbm9kZUlkKSk7XG4gICAgICAgIH0pIH0pKTtcbn1cbk5vZGVSZW5kZXJlckNvbXBvbmVudC5kaXNwbGF5TmFtZSA9ICdOb2RlUmVuZGVyZXInO1xuY29uc3QgTm9kZVJlbmRlcmVyID0gbWVtbyhOb2RlUmVuZGVyZXJDb21wb25lbnQpO1xuXG4vKipcbiAqIEhvb2sgZm9yIGdldHRpbmcgdGhlIHZpc2libGUgZWRnZSBpZHMgZnJvbSB0aGUgc3RvcmUuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0gb25seVJlbmRlclZpc2libGVcbiAqIEByZXR1cm5zIGFycmF5IHdpdGggdmlzaWJsZSBlZGdlIGlkc1xuICovXG5mdW5jdGlvbiB1c2VWaXNpYmxlRWRnZUlkcyhvbmx5UmVuZGVyVmlzaWJsZSkge1xuICAgIGNvbnN0IGVkZ2VJZHMgPSB1c2VTdG9yZSh1c2VDYWxsYmFjaygocykgPT4ge1xuICAgICAgICBpZiAoIW9ubHlSZW5kZXJWaXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gcy5lZGdlcy5tYXAoKGVkZ2UpID0+IGVkZ2UuaWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZpc2libGVFZGdlSWRzID0gW107XG4gICAgICAgIGlmIChzLndpZHRoICYmIHMuaGVpZ2h0KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVkZ2Ugb2Ygcy5lZGdlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZU5vZGUgPSBzLm5vZGVMb29rdXAuZ2V0KGVkZ2Uuc291cmNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXROb2RlID0gcy5ub2RlTG9va3VwLmdldChlZGdlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZU5vZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSAmJlxuICAgICAgICAgICAgICAgICAgICBpc0VkZ2VWaXNpYmxlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZU5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXROb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHMud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHMuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBzLnRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJsZUVkZ2VJZHMucHVzaChlZGdlLmlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZpc2libGVFZGdlSWRzO1xuICAgIH0sIFtvbmx5UmVuZGVyVmlzaWJsZV0pLCBzaGFsbG93KTtcbiAgICByZXR1cm4gZWRnZUlkcztcbn1cblxuY29uc3QgQXJyb3dTeW1ib2wgPSAoeyBjb2xvciA9ICdub25lJywgc3Ryb2tlV2lkdGggPSAxIH0pID0+IHtcbiAgICByZXR1cm4gKGpzeChcInBvbHlsaW5lXCIsIHsgc3R5bGU6IHtcbiAgICAgICAgICAgIHN0cm9rZTogY29sb3IsXG4gICAgICAgICAgICBzdHJva2VXaWR0aCxcbiAgICAgICAgfSwgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLCBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiLCBmaWxsOiBcIm5vbmVcIiwgcG9pbnRzOiBcIi01LC00IDAsMCAtNSw0XCIgfSkpO1xufTtcbmNvbnN0IEFycm93Q2xvc2VkU3ltYm9sID0gKHsgY29sb3IgPSAnbm9uZScsIHN0cm9rZVdpZHRoID0gMSB9KSA9PiB7XG4gICAgcmV0dXJuIChqc3goXCJwb2x5bGluZVwiLCB7IHN0eWxlOiB7XG4gICAgICAgICAgICBzdHJva2U6IGNvbG9yLFxuICAgICAgICAgICAgZmlsbDogY29sb3IsXG4gICAgICAgICAgICBzdHJva2VXaWR0aCxcbiAgICAgICAgfSwgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLCBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiLCBwb2ludHM6IFwiLTUsLTQgMCwwIC01LDQgLTUsLTRcIiB9KSk7XG59O1xuY29uc3QgTWFya2VyU3ltYm9scyA9IHtcbiAgICBbTWFya2VyVHlwZS5BcnJvd106IEFycm93U3ltYm9sLFxuICAgIFtNYXJrZXJUeXBlLkFycm93Q2xvc2VkXTogQXJyb3dDbG9zZWRTeW1ib2wsXG59O1xuZnVuY3Rpb24gdXNlTWFya2VyU3ltYm9sKHR5cGUpIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3Qgc3ltYm9sID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN5bWJvbEV4aXN0cyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChNYXJrZXJTeW1ib2xzLCB0eXBlKTtcbiAgICAgICAgaWYgKCFzeW1ib2xFeGlzdHMpIHtcbiAgICAgICAgICAgIHN0b3JlLmdldFN0YXRlKCkub25FcnJvcj8uKCcwMDknLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAwOSddKHR5cGUpKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXJrZXJTeW1ib2xzW3R5cGVdO1xuICAgIH0sIFt0eXBlXSk7XG4gICAgcmV0dXJuIHN5bWJvbDtcbn1cblxuY29uc3QgTWFya2VyID0gKHsgaWQsIHR5cGUsIGNvbG9yLCB3aWR0aCA9IDEyLjUsIGhlaWdodCA9IDEyLjUsIG1hcmtlclVuaXRzID0gJ3N0cm9rZVdpZHRoJywgc3Ryb2tlV2lkdGgsIG9yaWVudCA9ICdhdXRvLXN0YXJ0LXJldmVyc2UnLCB9KSA9PiB7XG4gICAgY29uc3QgU3ltYm9sID0gdXNlTWFya2VyU3ltYm9sKHR5cGUpO1xuICAgIGlmICghU3ltYm9sKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeChcIm1hcmtlclwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19hcnJvd2hlYWRcIiwgaWQ6IGlkLCBtYXJrZXJXaWR0aDogYCR7d2lkdGh9YCwgbWFya2VySGVpZ2h0OiBgJHtoZWlnaHR9YCwgdmlld0JveDogXCItMTAgLTEwIDIwIDIwXCIsIG1hcmtlclVuaXRzOiBtYXJrZXJVbml0cywgb3JpZW50OiBvcmllbnQsIHJlZlg6IFwiMFwiLCByZWZZOiBcIjBcIiwgY2hpbGRyZW46IGpzeChTeW1ib2wsIHsgY29sb3I6IGNvbG9yLCBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGggfSkgfSkpO1xufTtcbi8qXG4gKiB3aGVuIHlvdSBoYXZlIG11bHRpcGxlIGZsb3dzIG9uIGEgcGFnZSBhbmQgeW91IGhpZGUgdGhlIGZpcnN0IG9uZSwgdGhlIG90aGVyIG9uZXMgaGF2ZSBubyBtYXJrZXJzIGFueW1vcmVcbiAqIHdoZW4gdGhleSBkbyBoYXZlIG1hcmtlcnMgd2l0aCB0aGUgc2FtZSBpZHMuIFRvIHByZXZlbnQgdGhpcyB0aGUgdXNlciBjYW4gcGFzcyBhIHVuaXF1ZSBpZCB0byB0aGUgcmVhY3QgZmxvdyB3cmFwcGVyXG4gKiB0aGF0IHdlIGNhbiB0aGVuIHVzZSBmb3IgY3JlYXRpbmcgb3VyIHVuaXF1ZSBtYXJrZXIgaWRzXG4gKi9cbmNvbnN0IE1hcmtlckRlZmluaXRpb25zID0gKHsgZGVmYXVsdENvbG9yLCByZklkIH0pID0+IHtcbiAgICBjb25zdCBlZGdlcyA9IHVzZVN0b3JlKChzKSA9PiBzLmVkZ2VzKTtcbiAgICBjb25zdCBkZWZhdWx0RWRnZU9wdGlvbnMgPSB1c2VTdG9yZSgocykgPT4gcy5kZWZhdWx0RWRnZU9wdGlvbnMpO1xuICAgIGNvbnN0IG1hcmtlcnMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgY29uc3QgbWFya2VycyA9IGNyZWF0ZU1hcmtlcklkcyhlZGdlcywge1xuICAgICAgICAgICAgaWQ6IHJmSWQsXG4gICAgICAgICAgICBkZWZhdWx0Q29sb3IsXG4gICAgICAgICAgICBkZWZhdWx0TWFya2VyU3RhcnQ6IGRlZmF1bHRFZGdlT3B0aW9ucz8ubWFya2VyU3RhcnQsXG4gICAgICAgICAgICBkZWZhdWx0TWFya2VyRW5kOiBkZWZhdWx0RWRnZU9wdGlvbnM/Lm1hcmtlckVuZCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtYXJrZXJzO1xuICAgIH0sIFtlZGdlcywgZGVmYXVsdEVkZ2VPcHRpb25zLCByZklkLCBkZWZhdWx0Q29sb3JdKTtcbiAgICBpZiAoIW1hcmtlcnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeChcInN2Z1wiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19tYXJrZXJcIiwgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIiwgY2hpbGRyZW46IGpzeChcImRlZnNcIiwgeyBjaGlsZHJlbjogbWFya2Vycy5tYXAoKG1hcmtlcikgPT4gKGpzeChNYXJrZXIsIHsgaWQ6IG1hcmtlci5pZCwgdHlwZTogbWFya2VyLnR5cGUsIGNvbG9yOiBtYXJrZXIuY29sb3IsIHdpZHRoOiBtYXJrZXIud2lkdGgsIGhlaWdodDogbWFya2VyLmhlaWdodCwgbWFya2VyVW5pdHM6IG1hcmtlci5tYXJrZXJVbml0cywgc3Ryb2tlV2lkdGg6IG1hcmtlci5zdHJva2VXaWR0aCwgb3JpZW50OiBtYXJrZXIub3JpZW50IH0sIG1hcmtlci5pZCkpKSB9KSB9KSk7XG59O1xuTWFya2VyRGVmaW5pdGlvbnMuZGlzcGxheU5hbWUgPSAnTWFya2VyRGVmaW5pdGlvbnMnO1xudmFyIE1hcmtlckRlZmluaXRpb25zJDEgPSBtZW1vKE1hcmtlckRlZmluaXRpb25zKTtcblxuZnVuY3Rpb24gRWRnZVRleHRDb21wb25lbnQoeyB4LCB5LCBsYWJlbCwgbGFiZWxTdHlsZSwgbGFiZWxTaG93QmcgPSB0cnVlLCBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nID0gWzIsIDRdLCBsYWJlbEJnQm9yZGVyUmFkaXVzID0gMiwgY2hpbGRyZW4sIGNsYXNzTmFtZSwgLi4ucmVzdCB9KSB7XG4gICAgY29uc3QgW2VkZ2VUZXh0QmJveCwgc2V0RWRnZVRleHRCYm94XSA9IHVzZVN0YXRlKHsgeDogMSwgeTogMCwgd2lkdGg6IDAsIGhlaWdodDogMCB9KTtcbiAgICBjb25zdCBlZGdlVGV4dENsYXNzZXMgPSBjYyhbJ3JlYWN0LWZsb3dfX2VkZ2UtdGV4dHdyYXBwZXInLCBjbGFzc05hbWVdKTtcbiAgICBjb25zdCBlZGdlVGV4dFJlZiA9IHVzZVJlZihudWxsKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoZWRnZVRleHRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgY29uc3QgdGV4dEJib3ggPSBlZGdlVGV4dFJlZi5jdXJyZW50LmdldEJCb3goKTtcbiAgICAgICAgICAgIHNldEVkZ2VUZXh0QmJveCh7XG4gICAgICAgICAgICAgICAgeDogdGV4dEJib3gueCxcbiAgICAgICAgICAgICAgICB5OiB0ZXh0QmJveC55LFxuICAgICAgICAgICAgICAgIHdpZHRoOiB0ZXh0QmJveC53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRleHRCYm94LmhlaWdodCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgW2xhYmVsXSk7XG4gICAgaWYgKCFsYWJlbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChqc3hzKFwiZ1wiLCB7IHRyYW5zZm9ybTogYHRyYW5zbGF0ZSgke3ggLSBlZGdlVGV4dEJib3gud2lkdGggLyAyfSAke3kgLSBlZGdlVGV4dEJib3guaGVpZ2h0IC8gMn0pYCwgY2xhc3NOYW1lOiBlZGdlVGV4dENsYXNzZXMsIHZpc2liaWxpdHk6IGVkZ2VUZXh0QmJveC53aWR0aCA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nLCAuLi5yZXN0LCBjaGlsZHJlbjogW2xhYmVsU2hvd0JnICYmIChqc3goXCJyZWN0XCIsIHsgd2lkdGg6IGVkZ2VUZXh0QmJveC53aWR0aCArIDIgKiBsYWJlbEJnUGFkZGluZ1swXSwgeDogLWxhYmVsQmdQYWRkaW5nWzBdLCB5OiAtbGFiZWxCZ1BhZGRpbmdbMV0sIGhlaWdodDogZWRnZVRleHRCYm94LmhlaWdodCArIDIgKiBsYWJlbEJnUGFkZGluZ1sxXSwgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2VkZ2UtdGV4dGJnXCIsIHN0eWxlOiBsYWJlbEJnU3R5bGUsIHJ4OiBsYWJlbEJnQm9yZGVyUmFkaXVzLCByeTogbGFiZWxCZ0JvcmRlclJhZGl1cyB9KSksIGpzeChcInRleHRcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fZWRnZS10ZXh0XCIsIHk6IGVkZ2VUZXh0QmJveC5oZWlnaHQgLyAyLCBkeTogXCIwLjNlbVwiLCByZWY6IGVkZ2VUZXh0UmVmLCBzdHlsZTogbGFiZWxTdHlsZSwgY2hpbGRyZW46IGxhYmVsIH0pLCBjaGlsZHJlbl0gfSkpO1xufVxuRWRnZVRleHRDb21wb25lbnQuZGlzcGxheU5hbWUgPSAnRWRnZVRleHQnO1xuLyoqXG4gKiBZb3UgY2FuIHVzZSB0aGUgYDxFZGdlVGV4dCAvPmAgY29tcG9uZW50IGFzIGEgaGVscGVyIGNvbXBvbmVudCB0byBkaXNwbGF5IHRleHRcbiAqIHdpdGhpbiB5b3VyIGN1c3RvbSBlZGdlcy5cbiAqXG4gKiBAcHVibGljXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzeFxuICogaW1wb3J0IHsgRWRnZVRleHQgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKiBleHBvcnQgZnVuY3Rpb24gQ3VzdG9tRWRnZUxhYmVsKHsgbGFiZWwgfSkge1xuICogICByZXR1cm4gKFxuICogICAgIDxFZGdlVGV4dFxuICogICAgICAgeD17MTAwfVxuICogICAgICAgeT17MTAwfVxuICogICAgICAgbGFiZWw9e2xhYmVsfVxuICogICAgICAgbGFiZWxTdHlsZT17eyBmaWxsOiAnd2hpdGUnIH19XG4gKiAgICAgICBsYWJlbFNob3dCZ1xuICogICAgICAgbGFiZWxCZ1N0eWxlPXt7IGZpbGw6ICdyZWQnIH19XG4gKiAgICAgICBsYWJlbEJnUGFkZGluZz17WzIsIDRdfVxuICogICAgICAgbGFiZWxCZ0JvcmRlclJhZGl1cz17Mn1cbiAqICAgICAvPlxuICogICApO1xuICogfVxuICpgYGBcbiAqL1xuY29uc3QgRWRnZVRleHQgPSBtZW1vKEVkZ2VUZXh0Q29tcG9uZW50KTtcblxuLyoqXG4gKiBUaGUgYDxCYXNlRWRnZSAvPmAgY29tcG9uZW50IGdldHMgdXNlZCBpbnRlcm5hbGx5IGZvciBhbGwgdGhlIGVkZ2VzLiBJdCBjYW4gYmVcbiAqIHVzZWQgaW5zaWRlIGEgY3VzdG9tIGVkZ2UgYW5kIGhhbmRsZXMgdGhlIGludmlzaWJsZSBoZWxwZXIgZWRnZSBhbmQgdGhlIGVkZ2UgbGFiZWxcbiAqIGZvciB5b3UuXG4gKlxuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqIGBgYGpzeFxuICppbXBvcnQgeyBCYXNlRWRnZSB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZXhwb3J0IGZ1bmN0aW9uIEN1c3RvbUVkZ2UoeyBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZLCAuLi5wcm9wcyB9KSB7XG4gKiAgY29uc3QgW2VkZ2VQYXRoXSA9IGdldFN0cmFpZ2h0UGF0aCh7XG4gKiAgICBzb3VyY2VYLFxuICogICAgc291cmNlWSxcbiAqICAgIHRhcmdldFgsXG4gKiAgICB0YXJnZXRZLFxuICogIH0pO1xuICpcbiAqICByZXR1cm4gPEJhc2VFZGdlIHBhdGg9e2VkZ2VQYXRofSB7Li4ucHJvcHN9IC8+O1xuICp9XG4gKmBgYFxuICpcbiAqIEByZW1hcmtzIElmIHlvdSB3YW50IHRvIHVzZSBhbiBlZGdlIG1hcmtlciB3aXRoIHRoZSBbYDxCYXNlRWRnZSAvPmBdKC9hcGktcmVmZXJlbmNlL2NvbXBvbmVudHMvYmFzZS1lZGdlKSBjb21wb25lbnQsXG4gKiB5b3UgY2FuIHBhc3MgdGhlIGBtYXJrZXJTdGFydGAgb3IgYG1hcmtlckVuZGAgcHJvcHMgcGFzc2VkIHRvIHlvdXIgY3VzdG9tIGVkZ2VcbiAqIHRocm91Z2ggdG8gdGhlIFtgPEJhc2VFZGdlIC8+YF0oL2FwaS1yZWZlcmVuY2UvY29tcG9uZW50cy9iYXNlLWVkZ2UpIGNvbXBvbmVudC5cbiAqIFlvdSBjYW4gc2VlIGFsbCB0aGUgcHJvcHMgcGFzc2VkIHRvIGEgY3VzdG9tIGVkZ2UgYnkgbG9va2luZyBhdCB0aGUgW2BFZGdlUHJvcHNgXSgvYXBpLXJlZmVyZW5jZS90eXBlcy9lZGdlLXByb3BzKSB0eXBlLlxuICovXG5mdW5jdGlvbiBCYXNlRWRnZSh7IHBhdGgsIGxhYmVsWCwgbGFiZWxZLCBsYWJlbCwgbGFiZWxTdHlsZSwgbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXMsIGludGVyYWN0aW9uV2lkdGggPSAyMCwgLi4ucHJvcHMgfSkge1xuICAgIHJldHVybiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW2pzeChcInBhdGhcIiwgeyAuLi5wcm9wcywgZDogcGF0aCwgZmlsbDogXCJub25lXCIsIGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19lZGdlLXBhdGgnLCBwcm9wcy5jbGFzc05hbWVdKSB9KSwgaW50ZXJhY3Rpb25XaWR0aCAmJiAoanN4KFwicGF0aFwiLCB7IGQ6IHBhdGgsIGZpbGw6IFwibm9uZVwiLCBzdHJva2VPcGFjaXR5OiAwLCBzdHJva2VXaWR0aDogaW50ZXJhY3Rpb25XaWR0aCwgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2VkZ2UtaW50ZXJhY3Rpb25cIiB9KSksIGxhYmVsICYmIGlzTnVtZXJpYyhsYWJlbFgpICYmIGlzTnVtZXJpYyhsYWJlbFkpID8gKGpzeChFZGdlVGV4dCwgeyB4OiBsYWJlbFgsIHk6IGxhYmVsWSwgbGFiZWw6IGxhYmVsLCBsYWJlbFN0eWxlOiBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZzogbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZTogbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZzogbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXM6IGxhYmVsQmdCb3JkZXJSYWRpdXMgfSkpIDogbnVsbF0gfSkpO1xufVxuXG5mdW5jdGlvbiBnZXRDb250cm9sKHsgcG9zLCB4MSwgeTEsIHgyLCB5MiB9KSB7XG4gICAgaWYgKHBvcyA9PT0gUG9zaXRpb24uTGVmdCB8fCBwb3MgPT09IFBvc2l0aW9uLlJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBbMC41ICogKHgxICsgeDIpLCB5MV07XG4gICAgfVxuICAgIHJldHVybiBbeDEsIDAuNSAqICh5MSArIHkyKV07XG59XG4vKipcbiAqIFRoZSBgZ2V0U2ltcGxlQmV6aWVyUGF0aGAgdXRpbCByZXR1cm5zIGV2ZXJ5dGhpbmcgeW91IG5lZWQgdG8gcmVuZGVyIGEgc2ltcGxlXG4gKiBiZXppZXIgZWRnZSBiZXR3ZWVuIHR3byBub2Rlcy5cbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zXG4gKiAtIGBwYXRoYDogdGhlIHBhdGggdG8gdXNlIGluIGFuIFNWRyBgPHBhdGg+YCBlbGVtZW50LlxuICogLSBgbGFiZWxYYDogdGhlIGB4YCBwb3NpdGlvbiB5b3UgY2FuIHVzZSB0byByZW5kZXIgYSBsYWJlbCBmb3IgdGhpcyBlZGdlLlxuICogLSBgbGFiZWxZYDogdGhlIGB5YCBwb3NpdGlvbiB5b3UgY2FuIHVzZSB0byByZW5kZXIgYSBsYWJlbCBmb3IgdGhpcyBlZGdlLlxuICogLSBgb2Zmc2V0WGA6IHRoZSBhYnNvbHV0ZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIHNvdXJjZSBgeGAgcG9zaXRpb24gYW5kIHRoZSBgeGAgcG9zaXRpb24gb2YgdGhlXG4gKiBtaWRkbGUgb2YgdGhpcyBwYXRoLlxuICogLSBgb2Zmc2V0WWA6IHRoZSBhYnNvbHV0ZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIHNvdXJjZSBgeWAgcG9zaXRpb24gYW5kIHRoZSBgeWAgcG9zaXRpb24gb2YgdGhlXG4gKiBtaWRkbGUgb2YgdGhpcyBwYXRoLlxuICovXG5mdW5jdGlvbiBnZXRTaW1wbGVCZXppZXJQYXRoKHsgc291cmNlWCwgc291cmNlWSwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20sIHRhcmdldFgsIHRhcmdldFksIHRhcmdldFBvc2l0aW9uID0gUG9zaXRpb24uVG9wLCB9KSB7XG4gICAgY29uc3QgW3NvdXJjZUNvbnRyb2xYLCBzb3VyY2VDb250cm9sWV0gPSBnZXRDb250cm9sKHtcbiAgICAgICAgcG9zOiBzb3VyY2VQb3NpdGlvbixcbiAgICAgICAgeDE6IHNvdXJjZVgsXG4gICAgICAgIHkxOiBzb3VyY2VZLFxuICAgICAgICB4MjogdGFyZ2V0WCxcbiAgICAgICAgeTI6IHRhcmdldFksXG4gICAgfSk7XG4gICAgY29uc3QgW3RhcmdldENvbnRyb2xYLCB0YXJnZXRDb250cm9sWV0gPSBnZXRDb250cm9sKHtcbiAgICAgICAgcG9zOiB0YXJnZXRQb3NpdGlvbixcbiAgICAgICAgeDE6IHRhcmdldFgsXG4gICAgICAgIHkxOiB0YXJnZXRZLFxuICAgICAgICB4Mjogc291cmNlWCxcbiAgICAgICAgeTI6IHNvdXJjZVksXG4gICAgfSk7XG4gICAgY29uc3QgW2xhYmVsWCwgbGFiZWxZLCBvZmZzZXRYLCBvZmZzZXRZXSA9IGdldEJlemllckVkZ2VDZW50ZXIoe1xuICAgICAgICBzb3VyY2VYLFxuICAgICAgICBzb3VyY2VZLFxuICAgICAgICB0YXJnZXRYLFxuICAgICAgICB0YXJnZXRZLFxuICAgICAgICBzb3VyY2VDb250cm9sWCxcbiAgICAgICAgc291cmNlQ29udHJvbFksXG4gICAgICAgIHRhcmdldENvbnRyb2xYLFxuICAgICAgICB0YXJnZXRDb250cm9sWSxcbiAgICB9KTtcbiAgICByZXR1cm4gW1xuICAgICAgICBgTSR7c291cmNlWH0sJHtzb3VyY2VZfSBDJHtzb3VyY2VDb250cm9sWH0sJHtzb3VyY2VDb250cm9sWX0gJHt0YXJnZXRDb250cm9sWH0sJHt0YXJnZXRDb250cm9sWX0gJHt0YXJnZXRYfSwke3RhcmdldFl9YCxcbiAgICAgICAgbGFiZWxYLFxuICAgICAgICBsYWJlbFksXG4gICAgICAgIG9mZnNldFgsXG4gICAgICAgIG9mZnNldFksXG4gICAgXTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNpbXBsZUJlemllckVkZ2UocGFyYW1zKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L2Rpc3BsYXktbmFtZVxuICAgIHJldHVybiBtZW1vKCh7IGlkLCBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZLCBzb3VyY2VQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb24sIGxhYmVsLCBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZywgbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1cywgc3R5bGUsIG1hcmtlckVuZCwgbWFya2VyU3RhcnQsIGludGVyYWN0aW9uV2lkdGgsIH0pID0+IHtcbiAgICAgICAgY29uc3QgW3BhdGgsIGxhYmVsWCwgbGFiZWxZXSA9IGdldFNpbXBsZUJlemllclBhdGgoe1xuICAgICAgICAgICAgc291cmNlWCxcbiAgICAgICAgICAgIHNvdXJjZVksXG4gICAgICAgICAgICBzb3VyY2VQb3NpdGlvbixcbiAgICAgICAgICAgIHRhcmdldFgsXG4gICAgICAgICAgICB0YXJnZXRZLFxuICAgICAgICAgICAgdGFyZ2V0UG9zaXRpb24sXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBfaWQgPSBwYXJhbXMuaXNJbnRlcm5hbCA/IHVuZGVmaW5lZCA6IGlkO1xuICAgICAgICByZXR1cm4gKGpzeChCYXNlRWRnZSwgeyBpZDogX2lkLCBwYXRoOiBwYXRoLCBsYWJlbFg6IGxhYmVsWCwgbGFiZWxZOiBsYWJlbFksIGxhYmVsOiBsYWJlbCwgbGFiZWxTdHlsZTogbGFiZWxTdHlsZSwgbGFiZWxTaG93Qmc6IGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGU6IGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmc6IGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzOiBsYWJlbEJnQm9yZGVyUmFkaXVzLCBzdHlsZTogc3R5bGUsIG1hcmtlckVuZDogbWFya2VyRW5kLCBtYXJrZXJTdGFydDogbWFya2VyU3RhcnQsIGludGVyYWN0aW9uV2lkdGg6IGludGVyYWN0aW9uV2lkdGggfSkpO1xuICAgIH0pO1xufVxuY29uc3QgU2ltcGxlQmV6aWVyRWRnZSA9IGNyZWF0ZVNpbXBsZUJlemllckVkZ2UoeyBpc0ludGVybmFsOiBmYWxzZSB9KTtcbmNvbnN0IFNpbXBsZUJlemllckVkZ2VJbnRlcm5hbCA9IGNyZWF0ZVNpbXBsZUJlemllckVkZ2UoeyBpc0ludGVybmFsOiB0cnVlIH0pO1xuU2ltcGxlQmV6aWVyRWRnZS5kaXNwbGF5TmFtZSA9ICdTaW1wbGVCZXppZXJFZGdlJztcblNpbXBsZUJlemllckVkZ2VJbnRlcm5hbC5kaXNwbGF5TmFtZSA9ICdTaW1wbGVCZXppZXJFZGdlSW50ZXJuYWwnO1xuXG5mdW5jdGlvbiBjcmVhdGVTbW9vdGhTdGVwRWRnZShwYXJhbXMpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvZGlzcGxheS1uYW1lXG4gICAgcmV0dXJuIG1lbW8oKHsgaWQsIHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIGxhYmVsLCBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZywgbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1cywgc3R5bGUsIHNvdXJjZVBvc2l0aW9uID0gUG9zaXRpb24uQm90dG9tLCB0YXJnZXRQb3NpdGlvbiA9IFBvc2l0aW9uLlRvcCwgbWFya2VyRW5kLCBtYXJrZXJTdGFydCwgcGF0aE9wdGlvbnMsIGludGVyYWN0aW9uV2lkdGgsIH0pID0+IHtcbiAgICAgICAgY29uc3QgW3BhdGgsIGxhYmVsWCwgbGFiZWxZXSA9IGdldFNtb290aFN0ZXBQYXRoKHtcbiAgICAgICAgICAgIHNvdXJjZVgsXG4gICAgICAgICAgICBzb3VyY2VZLFxuICAgICAgICAgICAgc291cmNlUG9zaXRpb24sXG4gICAgICAgICAgICB0YXJnZXRYLFxuICAgICAgICAgICAgdGFyZ2V0WSxcbiAgICAgICAgICAgIHRhcmdldFBvc2l0aW9uLFxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiBwYXRoT3B0aW9ucz8uYm9yZGVyUmFkaXVzLFxuICAgICAgICAgICAgb2Zmc2V0OiBwYXRoT3B0aW9ucz8ub2Zmc2V0LFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgX2lkID0gcGFyYW1zLmlzSW50ZXJuYWwgPyB1bmRlZmluZWQgOiBpZDtcbiAgICAgICAgcmV0dXJuIChqc3goQmFzZUVkZ2UsIHsgaWQ6IF9pZCwgcGF0aDogcGF0aCwgbGFiZWxYOiBsYWJlbFgsIGxhYmVsWTogbGFiZWxZLCBsYWJlbDogbGFiZWwsIGxhYmVsU3R5bGU6IGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnOiBsYWJlbFNob3dCZywgbGFiZWxCZ1N0eWxlOiBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nOiBsYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1czogbGFiZWxCZ0JvcmRlclJhZGl1cywgc3R5bGU6IHN0eWxlLCBtYXJrZXJFbmQ6IG1hcmtlckVuZCwgbWFya2VyU3RhcnQ6IG1hcmtlclN0YXJ0LCBpbnRlcmFjdGlvbldpZHRoOiBpbnRlcmFjdGlvbldpZHRoIH0pKTtcbiAgICB9KTtcbn1cbi8qKlxuICogQ29tcG9uZW50IHRoYXQgY2FuIGJlIHVzZWQgaW5zaWRlIGEgY3VzdG9tIGVkZ2UgdG8gcmVuZGVyIGEgc21vb3RoIHN0ZXAgZWRnZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzeFxuICogaW1wb3J0IHsgU21vb3RoU3RlcEVkZ2UgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKiBmdW5jdGlvbiBDdXN0b21FZGdlKHsgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgc291cmNlUG9zaXRpb24sIHRhcmdldFBvc2l0aW9uIH0pIHtcbiAqICAgcmV0dXJuIChcbiAqICAgICA8U21vb3RoU3RlcEVkZ2VcbiAqICAgICAgIHNvdXJjZVg9e3NvdXJjZVh9XG4gKiAgICAgICBzb3VyY2VZPXtzb3VyY2VZfVxuICogICAgICAgdGFyZ2V0WD17dGFyZ2V0WH1cbiAqICAgICAgIHRhcmdldFk9e3RhcmdldFl9XG4gKiAgICAgICBzb3VyY2VQb3NpdGlvbj17c291cmNlUG9zaXRpb259XG4gKiAgICAgICB0YXJnZXRQb3NpdGlvbj17dGFyZ2V0UG9zaXRpb259XG4gKiAgICAgLz5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICovXG5jb25zdCBTbW9vdGhTdGVwRWRnZSA9IGNyZWF0ZVNtb290aFN0ZXBFZGdlKHsgaXNJbnRlcm5hbDogZmFsc2UgfSk7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBTbW9vdGhTdGVwRWRnZUludGVybmFsID0gY3JlYXRlU21vb3RoU3RlcEVkZ2UoeyBpc0ludGVybmFsOiB0cnVlIH0pO1xuU21vb3RoU3RlcEVkZ2UuZGlzcGxheU5hbWUgPSAnU21vb3RoU3RlcEVkZ2UnO1xuU21vb3RoU3RlcEVkZ2VJbnRlcm5hbC5kaXNwbGF5TmFtZSA9ICdTbW9vdGhTdGVwRWRnZUludGVybmFsJztcblxuZnVuY3Rpb24gY3JlYXRlU3RlcEVkZ2UocGFyYW1zKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L2Rpc3BsYXktbmFtZVxuICAgIHJldHVybiBtZW1vKCh7IGlkLCAuLi5wcm9wcyB9KSA9PiB7XG4gICAgICAgIGNvbnN0IF9pZCA9IHBhcmFtcy5pc0ludGVybmFsID8gdW5kZWZpbmVkIDogaWQ7XG4gICAgICAgIHJldHVybiAoanN4KFNtb290aFN0ZXBFZGdlLCB7IC4uLnByb3BzLCBpZDogX2lkLCBwYXRoT3B0aW9uczogdXNlTWVtbygoKSA9PiAoeyBib3JkZXJSYWRpdXM6IDAsIG9mZnNldDogcHJvcHMucGF0aE9wdGlvbnM/Lm9mZnNldCB9KSwgW3Byb3BzLnBhdGhPcHRpb25zPy5vZmZzZXRdKSB9KSk7XG4gICAgfSk7XG59XG4vKipcbiAqIENvbXBvbmVudCB0aGF0IGNhbiBiZSB1c2VkIGluc2lkZSBhIGN1c3RvbSBlZGdlIHRvIHJlbmRlciBhIHN0ZXAgZWRnZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzeFxuICogaW1wb3J0IHsgU3RlcEVkZ2UgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKiBmdW5jdGlvbiBDdXN0b21FZGdlKHsgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgc291cmNlUG9zaXRpb24sIHRhcmdldFBvc2l0aW9uIH0pIHtcbiAqICAgcmV0dXJuIChcbiAqICAgICA8U3RlcEVkZ2VcbiAqICAgICAgIHNvdXJjZVg9e3NvdXJjZVh9XG4gKiAgICAgICBzb3VyY2VZPXtzb3VyY2VZfVxuICogICAgICAgdGFyZ2V0WD17dGFyZ2V0WH1cbiAqICAgICAgIHRhcmdldFk9e3RhcmdldFl9XG4gKiAgICAgICBzb3VyY2VQb3NpdGlvbj17c291cmNlUG9zaXRpb259XG4gKiAgICAgICB0YXJnZXRQb3NpdGlvbj17dGFyZ2V0UG9zaXRpb259XG4gKiAgICAgLz5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICovXG5jb25zdCBTdGVwRWRnZSA9IGNyZWF0ZVN0ZXBFZGdlKHsgaXNJbnRlcm5hbDogZmFsc2UgfSk7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBTdGVwRWRnZUludGVybmFsID0gY3JlYXRlU3RlcEVkZ2UoeyBpc0ludGVybmFsOiB0cnVlIH0pO1xuU3RlcEVkZ2UuZGlzcGxheU5hbWUgPSAnU3RlcEVkZ2UnO1xuU3RlcEVkZ2VJbnRlcm5hbC5kaXNwbGF5TmFtZSA9ICdTdGVwRWRnZUludGVybmFsJztcblxuZnVuY3Rpb24gY3JlYXRlU3RyYWlnaHRFZGdlKHBhcmFtcykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9kaXNwbGF5LW5hbWVcbiAgICByZXR1cm4gbWVtbygoeyBpZCwgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgbGFiZWwsIGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzLCBzdHlsZSwgbWFya2VyRW5kLCBtYXJrZXJTdGFydCwgaW50ZXJhY3Rpb25XaWR0aCwgfSkgPT4ge1xuICAgICAgICBjb25zdCBbcGF0aCwgbGFiZWxYLCBsYWJlbFldID0gZ2V0U3RyYWlnaHRQYXRoKHsgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSB9KTtcbiAgICAgICAgY29uc3QgX2lkID0gcGFyYW1zLmlzSW50ZXJuYWwgPyB1bmRlZmluZWQgOiBpZDtcbiAgICAgICAgcmV0dXJuIChqc3goQmFzZUVkZ2UsIHsgaWQ6IF9pZCwgcGF0aDogcGF0aCwgbGFiZWxYOiBsYWJlbFgsIGxhYmVsWTogbGFiZWxZLCBsYWJlbDogbGFiZWwsIGxhYmVsU3R5bGU6IGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnOiBsYWJlbFNob3dCZywgbGFiZWxCZ1N0eWxlOiBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nOiBsYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1czogbGFiZWxCZ0JvcmRlclJhZGl1cywgc3R5bGU6IHN0eWxlLCBtYXJrZXJFbmQ6IG1hcmtlckVuZCwgbWFya2VyU3RhcnQ6IG1hcmtlclN0YXJ0LCBpbnRlcmFjdGlvbldpZHRoOiBpbnRlcmFjdGlvbldpZHRoIH0pKTtcbiAgICB9KTtcbn1cbi8qKlxuICogQ29tcG9uZW50IHRoYXQgY2FuIGJlIHVzZWQgaW5zaWRlIGEgY3VzdG9tIGVkZ2UgdG8gcmVuZGVyIGEgc3RyYWlnaHQgbGluZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzeFxuICogaW1wb3J0IHsgU3RyYWlnaHRFZGdlIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICogZnVuY3Rpb24gQ3VzdG9tRWRnZSh7IHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFkgfSkge1xuICogICByZXR1cm4gKFxuICogICAgIDxTdHJhaWdodEVkZ2VcbiAqICAgICAgIHNvdXJjZVg9e3NvdXJjZVh9XG4gKiAgICAgICBzb3VyY2VZPXtzb3VyY2VZfVxuICogICAgICAgdGFyZ2V0WD17dGFyZ2V0WH1cbiAqICAgICAgIHRhcmdldFk9e3RhcmdldFl9XG4gKiAgICAgLz5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICovXG5jb25zdCBTdHJhaWdodEVkZ2UgPSBjcmVhdGVTdHJhaWdodEVkZ2UoeyBpc0ludGVybmFsOiBmYWxzZSB9KTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFN0cmFpZ2h0RWRnZUludGVybmFsID0gY3JlYXRlU3RyYWlnaHRFZGdlKHsgaXNJbnRlcm5hbDogdHJ1ZSB9KTtcblN0cmFpZ2h0RWRnZS5kaXNwbGF5TmFtZSA9ICdTdHJhaWdodEVkZ2UnO1xuU3RyYWlnaHRFZGdlSW50ZXJuYWwuZGlzcGxheU5hbWUgPSAnU3RyYWlnaHRFZGdlSW50ZXJuYWwnO1xuXG5mdW5jdGlvbiBjcmVhdGVCZXppZXJFZGdlKHBhcmFtcykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9kaXNwbGF5LW5hbWVcbiAgICByZXR1cm4gbWVtbygoeyBpZCwgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20sIHRhcmdldFBvc2l0aW9uID0gUG9zaXRpb24uVG9wLCBsYWJlbCwgbGFiZWxTdHlsZSwgbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXMsIHN0eWxlLCBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0LCBwYXRoT3B0aW9ucywgaW50ZXJhY3Rpb25XaWR0aCwgfSkgPT4ge1xuICAgICAgICBjb25zdCBbcGF0aCwgbGFiZWxYLCBsYWJlbFldID0gZ2V0QmV6aWVyUGF0aCh7XG4gICAgICAgICAgICBzb3VyY2VYLFxuICAgICAgICAgICAgc291cmNlWSxcbiAgICAgICAgICAgIHNvdXJjZVBvc2l0aW9uLFxuICAgICAgICAgICAgdGFyZ2V0WCxcbiAgICAgICAgICAgIHRhcmdldFksXG4gICAgICAgICAgICB0YXJnZXRQb3NpdGlvbixcbiAgICAgICAgICAgIGN1cnZhdHVyZTogcGF0aE9wdGlvbnM/LmN1cnZhdHVyZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IF9pZCA9IHBhcmFtcy5pc0ludGVybmFsID8gdW5kZWZpbmVkIDogaWQ7XG4gICAgICAgIHJldHVybiAoanN4KEJhc2VFZGdlLCB7IGlkOiBfaWQsIHBhdGg6IHBhdGgsIGxhYmVsWDogbGFiZWxYLCBsYWJlbFk6IGxhYmVsWSwgbGFiZWw6IGxhYmVsLCBsYWJlbFN0eWxlOiBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZzogbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZTogbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZzogbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXM6IGxhYmVsQmdCb3JkZXJSYWRpdXMsIHN0eWxlOiBzdHlsZSwgbWFya2VyRW5kOiBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0OiBtYXJrZXJTdGFydCwgaW50ZXJhY3Rpb25XaWR0aDogaW50ZXJhY3Rpb25XaWR0aCB9KSk7XG4gICAgfSk7XG59XG4vKipcbiAqIENvbXBvbmVudCB0aGF0IGNhbiBiZSB1c2VkIGluc2lkZSBhIGN1c3RvbSBlZGdlIHRvIHJlbmRlciBhIGJlemllciBjdXJ2ZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzeFxuICogaW1wb3J0IHsgQmV6aWVyRWRnZSB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqIGZ1bmN0aW9uIEN1c3RvbUVkZ2UoeyBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZLCBzb3VyY2VQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb24gfSkge1xuICogICByZXR1cm4gKFxuICogICAgIDxCZXppZXJFZGdlXG4gKiAgICAgICBzb3VyY2VYPXtzb3VyY2VYfVxuICogICAgICAgc291cmNlWT17c291cmNlWX1cbiAqICAgICAgIHRhcmdldFg9e3RhcmdldFh9XG4gKiAgICAgICB0YXJnZXRZPXt0YXJnZXRZfVxuICogICAgICAgc291cmNlUG9zaXRpb249e3NvdXJjZVBvc2l0aW9ufVxuICogICAgICAgdGFyZ2V0UG9zaXRpb249e3RhcmdldFBvc2l0aW9ufVxuICogICAgIC8+XG4gKiAgICk7XG4gKiB9XG4gKiBgYGBcbiAqL1xuY29uc3QgQmV6aWVyRWRnZSA9IGNyZWF0ZUJlemllckVkZ2UoeyBpc0ludGVybmFsOiBmYWxzZSB9KTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IEJlemllckVkZ2VJbnRlcm5hbCA9IGNyZWF0ZUJlemllckVkZ2UoeyBpc0ludGVybmFsOiB0cnVlIH0pO1xuQmV6aWVyRWRnZS5kaXNwbGF5TmFtZSA9ICdCZXppZXJFZGdlJztcbkJlemllckVkZ2VJbnRlcm5hbC5kaXNwbGF5TmFtZSA9ICdCZXppZXJFZGdlSW50ZXJuYWwnO1xuXG5jb25zdCBidWlsdGluRWRnZVR5cGVzID0ge1xuICAgIGRlZmF1bHQ6IEJlemllckVkZ2VJbnRlcm5hbCxcbiAgICBzdHJhaWdodDogU3RyYWlnaHRFZGdlSW50ZXJuYWwsXG4gICAgc3RlcDogU3RlcEVkZ2VJbnRlcm5hbCxcbiAgICBzbW9vdGhzdGVwOiBTbW9vdGhTdGVwRWRnZUludGVybmFsLFxuICAgIHNpbXBsZWJlemllcjogU2ltcGxlQmV6aWVyRWRnZUludGVybmFsLFxufTtcbmNvbnN0IG51bGxQb3NpdGlvbiA9IHtcbiAgICBzb3VyY2VYOiBudWxsLFxuICAgIHNvdXJjZVk6IG51bGwsXG4gICAgdGFyZ2V0WDogbnVsbCxcbiAgICB0YXJnZXRZOiBudWxsLFxuICAgIHNvdXJjZVBvc2l0aW9uOiBudWxsLFxuICAgIHRhcmdldFBvc2l0aW9uOiBudWxsLFxufTtcblxuY29uc3Qgc2hpZnRYID0gKHgsIHNoaWZ0LCBwb3NpdGlvbikgPT4ge1xuICAgIGlmIChwb3NpdGlvbiA9PT0gUG9zaXRpb24uTGVmdClcbiAgICAgICAgcmV0dXJuIHggLSBzaGlmdDtcbiAgICBpZiAocG9zaXRpb24gPT09IFBvc2l0aW9uLlJpZ2h0KVxuICAgICAgICByZXR1cm4geCArIHNoaWZ0O1xuICAgIHJldHVybiB4O1xufTtcbmNvbnN0IHNoaWZ0WSA9ICh5LCBzaGlmdCwgcG9zaXRpb24pID0+IHtcbiAgICBpZiAocG9zaXRpb24gPT09IFBvc2l0aW9uLlRvcClcbiAgICAgICAgcmV0dXJuIHkgLSBzaGlmdDtcbiAgICBpZiAocG9zaXRpb24gPT09IFBvc2l0aW9uLkJvdHRvbSlcbiAgICAgICAgcmV0dXJuIHkgKyBzaGlmdDtcbiAgICByZXR1cm4geTtcbn07XG5jb25zdCBFZGdlVXBkYXRlckNsYXNzTmFtZSA9ICdyZWFjdC1mbG93X19lZGdldXBkYXRlcic7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBFZGdlQW5jaG9yKHsgcG9zaXRpb24sIGNlbnRlclgsIGNlbnRlclksIHJhZGl1cyA9IDEwLCBvbk1vdXNlRG93biwgb25Nb3VzZUVudGVyLCBvbk1vdXNlT3V0LCB0eXBlLCB9KSB7XG4gICAgcmV0dXJuIChqc3goXCJjaXJjbGVcIiwgeyBvbk1vdXNlRG93bjogb25Nb3VzZURvd24sIG9uTW91c2VFbnRlcjogb25Nb3VzZUVudGVyLCBvbk1vdXNlT3V0OiBvbk1vdXNlT3V0LCBjbGFzc05hbWU6IGNjKFtFZGdlVXBkYXRlckNsYXNzTmFtZSwgYCR7RWRnZVVwZGF0ZXJDbGFzc05hbWV9LSR7dHlwZX1gXSksIGN4OiBzaGlmdFgoY2VudGVyWCwgcmFkaXVzLCBwb3NpdGlvbiksIGN5OiBzaGlmdFkoY2VudGVyWSwgcmFkaXVzLCBwb3NpdGlvbiksIHI6IHJhZGl1cywgc3Ryb2tlOiBcInRyYW5zcGFyZW50XCIsIGZpbGw6IFwidHJhbnNwYXJlbnRcIiB9KSk7XG59XG5cbmZ1bmN0aW9uIEVkZ2VVcGRhdGVBbmNob3JzKHsgaXNSZWNvbm5lY3RhYmxlLCByZWNvbm5lY3RSYWRpdXMsIGVkZ2UsIHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIHNvdXJjZVBvc2l0aW9uLCB0YXJnZXRQb3NpdGlvbiwgb25SZWNvbm5lY3QsIG9uUmVjb25uZWN0U3RhcnQsIG9uUmVjb25uZWN0RW5kLCBzZXRSZWNvbm5lY3RpbmcsIHNldFVwZGF0ZUhvdmVyLCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IGhhbmRsZUVkZ2VVcGRhdGVyID0gKGV2ZW50LCBvcHBvc2l0ZUhhbmRsZSkgPT4ge1xuICAgICAgICAvLyBhdm9pZCB0cmlnZ2VyaW5nIGVkZ2UgdXBkYXRlciBpZiBtb3VzZSBidG4gaXMgbm90IGxlZnRcbiAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgYXV0b1Bhbk9uQ29ubmVjdCwgZG9tTm9kZSwgaXNWYWxpZENvbm5lY3Rpb24sIGNvbm5lY3Rpb25Nb2RlLCBjb25uZWN0aW9uUmFkaXVzLCBsaWIsIG9uQ29ubmVjdFN0YXJ0LCBvbkNvbm5lY3RFbmQsIGNhbmNlbENvbm5lY3Rpb24sIG5vZGVMb29rdXAsIHJmSWQ6IGZsb3dJZCwgcGFuQnksIHVwZGF0ZUNvbm5lY3Rpb24sIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBjb25zdCBpc1RhcmdldCA9IG9wcG9zaXRlSGFuZGxlLnR5cGUgPT09ICd0YXJnZXQnO1xuICAgICAgICBzZXRSZWNvbm5lY3RpbmcodHJ1ZSk7XG4gICAgICAgIG9uUmVjb25uZWN0U3RhcnQ/LihldmVudCwgZWRnZSwgb3Bwb3NpdGVIYW5kbGUudHlwZSk7XG4gICAgICAgIGNvbnN0IF9vblJlY29ubmVjdEVuZCA9IChldnQsIGNvbm5lY3Rpb25TdGF0ZSkgPT4ge1xuICAgICAgICAgICAgc2V0UmVjb25uZWN0aW5nKGZhbHNlKTtcbiAgICAgICAgICAgIG9uUmVjb25uZWN0RW5kPy4oZXZ0LCBlZGdlLCBvcHBvc2l0ZUhhbmRsZS50eXBlLCBjb25uZWN0aW9uU3RhdGUpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvbkNvbm5lY3RFZGdlID0gKGNvbm5lY3Rpb24pID0+IG9uUmVjb25uZWN0Py4oZWRnZSwgY29ubmVjdGlvbik7XG4gICAgICAgIFhZSGFuZGxlLm9uUG9pbnRlckRvd24oZXZlbnQubmF0aXZlRXZlbnQsIHtcbiAgICAgICAgICAgIGF1dG9QYW5PbkNvbm5lY3QsXG4gICAgICAgICAgICBjb25uZWN0aW9uTW9kZSxcbiAgICAgICAgICAgIGNvbm5lY3Rpb25SYWRpdXMsXG4gICAgICAgICAgICBkb21Ob2RlLFxuICAgICAgICAgICAgaGFuZGxlSWQ6IG9wcG9zaXRlSGFuZGxlLmlkLFxuICAgICAgICAgICAgbm9kZUlkOiBvcHBvc2l0ZUhhbmRsZS5ub2RlSWQsXG4gICAgICAgICAgICBub2RlTG9va3VwLFxuICAgICAgICAgICAgaXNUYXJnZXQsXG4gICAgICAgICAgICBlZGdlVXBkYXRlclR5cGU6IG9wcG9zaXRlSGFuZGxlLnR5cGUsXG4gICAgICAgICAgICBsaWIsXG4gICAgICAgICAgICBmbG93SWQsXG4gICAgICAgICAgICBjYW5jZWxDb25uZWN0aW9uLFxuICAgICAgICAgICAgcGFuQnksXG4gICAgICAgICAgICBpc1ZhbGlkQ29ubmVjdGlvbixcbiAgICAgICAgICAgIG9uQ29ubmVjdDogb25Db25uZWN0RWRnZSxcbiAgICAgICAgICAgIG9uQ29ubmVjdFN0YXJ0LFxuICAgICAgICAgICAgb25Db25uZWN0RW5kLFxuICAgICAgICAgICAgb25SZWNvbm5lY3RFbmQ6IF9vblJlY29ubmVjdEVuZCxcbiAgICAgICAgICAgIHVwZGF0ZUNvbm5lY3Rpb24sXG4gICAgICAgICAgICBnZXRUcmFuc2Zvcm06ICgpID0+IHN0b3JlLmdldFN0YXRlKCkudHJhbnNmb3JtLFxuICAgICAgICAgICAgZ2V0RnJvbUhhbmRsZTogKCkgPT4gc3RvcmUuZ2V0U3RhdGUoKS5jb25uZWN0aW9uLmZyb21IYW5kbGUsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3Qgb25SZWNvbm5lY3RTb3VyY2VNb3VzZURvd24gPSAoZXZlbnQpID0+IGhhbmRsZUVkZ2VVcGRhdGVyKGV2ZW50LCB7IG5vZGVJZDogZWRnZS50YXJnZXQsIGlkOiBlZGdlLnRhcmdldEhhbmRsZSA/PyBudWxsLCB0eXBlOiAndGFyZ2V0JyB9KTtcbiAgICBjb25zdCBvblJlY29ubmVjdFRhcmdldE1vdXNlRG93biA9IChldmVudCkgPT4gaGFuZGxlRWRnZVVwZGF0ZXIoZXZlbnQsIHsgbm9kZUlkOiBlZGdlLnNvdXJjZSwgaWQ6IGVkZ2Uuc291cmNlSGFuZGxlID8/IG51bGwsIHR5cGU6ICdzb3VyY2UnIH0pO1xuICAgIGNvbnN0IG9uUmVjb25uZWN0TW91c2VFbnRlciA9ICgpID0+IHNldFVwZGF0ZUhvdmVyKHRydWUpO1xuICAgIGNvbnN0IG9uUmVjb25uZWN0TW91c2VPdXQgPSAoKSA9PiBzZXRVcGRhdGVIb3ZlcihmYWxzZSk7XG4gICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbKGlzUmVjb25uZWN0YWJsZSA9PT0gdHJ1ZSB8fCBpc1JlY29ubmVjdGFibGUgPT09ICdzb3VyY2UnKSAmJiAoanN4KEVkZ2VBbmNob3IsIHsgcG9zaXRpb246IHNvdXJjZVBvc2l0aW9uLCBjZW50ZXJYOiBzb3VyY2VYLCBjZW50ZXJZOiBzb3VyY2VZLCByYWRpdXM6IHJlY29ubmVjdFJhZGl1cywgb25Nb3VzZURvd246IG9uUmVjb25uZWN0U291cmNlTW91c2VEb3duLCBvbk1vdXNlRW50ZXI6IG9uUmVjb25uZWN0TW91c2VFbnRlciwgb25Nb3VzZU91dDogb25SZWNvbm5lY3RNb3VzZU91dCwgdHlwZTogXCJzb3VyY2VcIiB9KSksIChpc1JlY29ubmVjdGFibGUgPT09IHRydWUgfHwgaXNSZWNvbm5lY3RhYmxlID09PSAndGFyZ2V0JykgJiYgKGpzeChFZGdlQW5jaG9yLCB7IHBvc2l0aW9uOiB0YXJnZXRQb3NpdGlvbiwgY2VudGVyWDogdGFyZ2V0WCwgY2VudGVyWTogdGFyZ2V0WSwgcmFkaXVzOiByZWNvbm5lY3RSYWRpdXMsIG9uTW91c2VEb3duOiBvblJlY29ubmVjdFRhcmdldE1vdXNlRG93biwgb25Nb3VzZUVudGVyOiBvblJlY29ubmVjdE1vdXNlRW50ZXIsIG9uTW91c2VPdXQ6IG9uUmVjb25uZWN0TW91c2VPdXQsIHR5cGU6IFwidGFyZ2V0XCIgfSkpXSB9KSk7XG59XG5cbmZ1bmN0aW9uIEVkZ2VXcmFwcGVyKHsgaWQsIGVkZ2VzRm9jdXNhYmxlLCBlZGdlc1JlY29ubmVjdGFibGUsIGVsZW1lbnRzU2VsZWN0YWJsZSwgb25DbGljaywgb25Eb3VibGVDbGljaywgb25Db250ZXh0TWVudSwgb25Nb3VzZUVudGVyLCBvbk1vdXNlTW92ZSwgb25Nb3VzZUxlYXZlLCByZWNvbm5lY3RSYWRpdXMsIG9uUmVjb25uZWN0LCBvblJlY29ubmVjdFN0YXJ0LCBvblJlY29ubmVjdEVuZCwgcmZJZCwgZWRnZVR5cGVzLCBub1BhbkNsYXNzTmFtZSwgb25FcnJvciwgZGlzYWJsZUtleWJvYXJkQTExeSwgfSkge1xuICAgIGxldCBlZGdlID0gdXNlU3RvcmUoKHMpID0+IHMuZWRnZUxvb2t1cC5nZXQoaWQpKTtcbiAgICBjb25zdCBkZWZhdWx0RWRnZU9wdGlvbnMgPSB1c2VTdG9yZSgocykgPT4gcy5kZWZhdWx0RWRnZU9wdGlvbnMpO1xuICAgIGVkZ2UgPSBkZWZhdWx0RWRnZU9wdGlvbnMgPyB7IC4uLmRlZmF1bHRFZGdlT3B0aW9ucywgLi4uZWRnZSB9IDogZWRnZTtcbiAgICBsZXQgZWRnZVR5cGUgPSBlZGdlLnR5cGUgfHwgJ2RlZmF1bHQnO1xuICAgIGxldCBFZGdlQ29tcG9uZW50ID0gZWRnZVR5cGVzPy5bZWRnZVR5cGVdIHx8IGJ1aWx0aW5FZGdlVHlwZXNbZWRnZVR5cGVdO1xuICAgIGlmIChFZGdlQ29tcG9uZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb25FcnJvcj8uKCcwMTEnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAxMSddKGVkZ2VUeXBlKSk7XG4gICAgICAgIGVkZ2VUeXBlID0gJ2RlZmF1bHQnO1xuICAgICAgICBFZGdlQ29tcG9uZW50ID0gYnVpbHRpbkVkZ2VUeXBlcy5kZWZhdWx0O1xuICAgIH1cbiAgICBjb25zdCBpc0ZvY3VzYWJsZSA9ICEhKGVkZ2UuZm9jdXNhYmxlIHx8IChlZGdlc0ZvY3VzYWJsZSAmJiB0eXBlb2YgZWRnZS5mb2N1c2FibGUgPT09ICd1bmRlZmluZWQnKSk7XG4gICAgY29uc3QgaXNSZWNvbm5lY3RhYmxlID0gdHlwZW9mIG9uUmVjb25uZWN0ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAoZWRnZS5yZWNvbm5lY3RhYmxlIHx8IChlZGdlc1JlY29ubmVjdGFibGUgJiYgdHlwZW9mIGVkZ2UucmVjb25uZWN0YWJsZSA9PT0gJ3VuZGVmaW5lZCcpKTtcbiAgICBjb25zdCBpc1NlbGVjdGFibGUgPSAhIShlZGdlLnNlbGVjdGFibGUgfHwgKGVsZW1lbnRzU2VsZWN0YWJsZSAmJiB0eXBlb2YgZWRnZS5zZWxlY3RhYmxlID09PSAndW5kZWZpbmVkJykpO1xuICAgIGNvbnN0IGVkZ2VSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgW3VwZGF0ZUhvdmVyLCBzZXRVcGRhdGVIb3Zlcl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW3JlY29ubmVjdGluZywgc2V0UmVjb25uZWN0aW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgeyB6SW5kZXgsIHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIHNvdXJjZVBvc2l0aW9uLCB0YXJnZXRQb3NpdGlvbiB9ID0gdXNlU3RvcmUodXNlQ2FsbGJhY2soKHN0b3JlKSA9PiB7XG4gICAgICAgIGNvbnN0IHNvdXJjZU5vZGUgPSBzdG9yZS5ub2RlTG9va3VwLmdldChlZGdlLnNvdXJjZSk7XG4gICAgICAgIGNvbnN0IHRhcmdldE5vZGUgPSBzdG9yZS5ub2RlTG9va3VwLmdldChlZGdlLnRhcmdldCk7XG4gICAgICAgIGlmICghc291cmNlTm9kZSB8fCAhdGFyZ2V0Tm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB6SW5kZXg6IGVkZ2UuekluZGV4LFxuICAgICAgICAgICAgICAgIC4uLm51bGxQb3NpdGlvbixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWRnZVBvc2l0aW9uID0gZ2V0RWRnZVBvc2l0aW9uKHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgc291cmNlTm9kZSxcbiAgICAgICAgICAgIHRhcmdldE5vZGUsXG4gICAgICAgICAgICBzb3VyY2VIYW5kbGU6IGVkZ2Uuc291cmNlSGFuZGxlIHx8IG51bGwsXG4gICAgICAgICAgICB0YXJnZXRIYW5kbGU6IGVkZ2UudGFyZ2V0SGFuZGxlIHx8IG51bGwsXG4gICAgICAgICAgICBjb25uZWN0aW9uTW9kZTogc3RvcmUuY29ubmVjdGlvbk1vZGUsXG4gICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgekluZGV4ID0gZ2V0RWxldmF0ZWRFZGdlWkluZGV4KHtcbiAgICAgICAgICAgIHNlbGVjdGVkOiBlZGdlLnNlbGVjdGVkLFxuICAgICAgICAgICAgekluZGV4OiBlZGdlLnpJbmRleCxcbiAgICAgICAgICAgIHNvdXJjZU5vZGUsXG4gICAgICAgICAgICB0YXJnZXROb2RlLFxuICAgICAgICAgICAgZWxldmF0ZU9uU2VsZWN0OiBzdG9yZS5lbGV2YXRlRWRnZXNPblNlbGVjdCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB6SW5kZXgsXG4gICAgICAgICAgICAuLi4oZWRnZVBvc2l0aW9uIHx8IG51bGxQb3NpdGlvbiksXG4gICAgICAgIH07XG4gICAgfSwgW2VkZ2Uuc291cmNlLCBlZGdlLnRhcmdldCwgZWRnZS5zb3VyY2VIYW5kbGUsIGVkZ2UudGFyZ2V0SGFuZGxlLCBlZGdlLnNlbGVjdGVkLCBlZGdlLnpJbmRleF0pLCBzaGFsbG93KTtcbiAgICBjb25zdCBtYXJrZXJTdGFydFVybCA9IHVzZU1lbW8oKCkgPT4gKGVkZ2UubWFya2VyU3RhcnQgPyBgdXJsKCcjJHtnZXRNYXJrZXJJZChlZGdlLm1hcmtlclN0YXJ0LCByZklkKX0nKWAgOiB1bmRlZmluZWQpLCBbZWRnZS5tYXJrZXJTdGFydCwgcmZJZF0pO1xuICAgIGNvbnN0IG1hcmtlckVuZFVybCA9IHVzZU1lbW8oKCkgPT4gKGVkZ2UubWFya2VyRW5kID8gYHVybCgnIyR7Z2V0TWFya2VySWQoZWRnZS5tYXJrZXJFbmQsIHJmSWQpfScpYCA6IHVuZGVmaW5lZCksIFtlZGdlLm1hcmtlckVuZCwgcmZJZF0pO1xuICAgIGlmIChlZGdlLmhpZGRlbiB8fCBzb3VyY2VYID09PSBudWxsIHx8IHNvdXJjZVkgPT09IG51bGwgfHwgdGFyZ2V0WCA9PT0gbnVsbCB8fCB0YXJnZXRZID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBvbkVkZ2VDbGljayA9IChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCB7IGFkZFNlbGVjdGVkRWRnZXMsIHVuc2VsZWN0Tm9kZXNBbmRFZGdlcywgbXVsdGlTZWxlY3Rpb25BY3RpdmUgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGlmIChpc1NlbGVjdGFibGUpIHtcbiAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgbm9kZXNTZWxlY3Rpb25BY3RpdmU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgaWYgKGVkZ2Uuc2VsZWN0ZWQgJiYgbXVsdGlTZWxlY3Rpb25BY3RpdmUpIHtcbiAgICAgICAgICAgICAgICB1bnNlbGVjdE5vZGVzQW5kRWRnZXMoeyBub2RlczogW10sIGVkZ2VzOiBbZWRnZV0gfSk7XG4gICAgICAgICAgICAgICAgZWRnZVJlZi5jdXJyZW50Py5ibHVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGRTZWxlY3RlZEVkZ2VzKFtpZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICAgICAgICBvbkNsaWNrKGV2ZW50LCBlZGdlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgb25FZGdlRG91YmxlQ2xpY2sgPSBvbkRvdWJsZUNsaWNrXG4gICAgICAgID8gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBvbkRvdWJsZUNsaWNrKGV2ZW50LCB7IC4uLmVkZ2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25FZGdlQ29udGV4dE1lbnUgPSBvbkNvbnRleHRNZW51XG4gICAgICAgID8gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBvbkNvbnRleHRNZW51KGV2ZW50LCB7IC4uLmVkZ2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25FZGdlTW91c2VFbnRlciA9IG9uTW91c2VFbnRlclxuICAgICAgICA/IChldmVudCkgPT4ge1xuICAgICAgICAgICAgb25Nb3VzZUVudGVyKGV2ZW50LCB7IC4uLmVkZ2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25FZGdlTW91c2VNb3ZlID0gb25Nb3VzZU1vdmVcbiAgICAgICAgPyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIG9uTW91c2VNb3ZlKGV2ZW50LCB7IC4uLmVkZ2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25FZGdlTW91c2VMZWF2ZSA9IG9uTW91c2VMZWF2ZVxuICAgICAgICA/IChldmVudCkgPT4ge1xuICAgICAgICAgICAgb25Nb3VzZUxlYXZlKGV2ZW50LCB7IC4uLmVkZ2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25LZXlEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmICghZGlzYWJsZUtleWJvYXJkQTExeSAmJiBlbGVtZW50U2VsZWN0aW9uS2V5cy5pbmNsdWRlcyhldmVudC5rZXkpICYmIGlzU2VsZWN0YWJsZSkge1xuICAgICAgICAgICAgY29uc3QgeyB1bnNlbGVjdE5vZGVzQW5kRWRnZXMsIGFkZFNlbGVjdGVkRWRnZXMgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICBjb25zdCB1bnNlbGVjdCA9IGV2ZW50LmtleSA9PT0gJ0VzY2FwZSc7XG4gICAgICAgICAgICBpZiAodW5zZWxlY3QpIHtcbiAgICAgICAgICAgICAgICBlZGdlUmVmLmN1cnJlbnQ/LmJsdXIoKTtcbiAgICAgICAgICAgICAgICB1bnNlbGVjdE5vZGVzQW5kRWRnZXMoeyBlZGdlczogW2VkZ2VdIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkU2VsZWN0ZWRFZGdlcyhbaWRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgeyBzdHlsZTogeyB6SW5kZXggfSwgY2hpbGRyZW46IGpzeHMoXCJnXCIsIHsgY2xhc3NOYW1lOiBjYyhbXG4gICAgICAgICAgICAgICAgJ3JlYWN0LWZsb3dfX2VkZ2UnLFxuICAgICAgICAgICAgICAgIGByZWFjdC1mbG93X19lZGdlLSR7ZWRnZVR5cGV9YCxcbiAgICAgICAgICAgICAgICBlZGdlLmNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICBub1BhbkNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkOiBlZGdlLnNlbGVjdGVkLFxuICAgICAgICAgICAgICAgICAgICBhbmltYXRlZDogZWRnZS5hbmltYXRlZCxcbiAgICAgICAgICAgICAgICAgICAgaW5hY3RpdmU6ICFpc1NlbGVjdGFibGUgJiYgIW9uQ2xpY2ssXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0aW5nOiB1cGRhdGVIb3ZlcixcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0YWJsZTogaXNTZWxlY3RhYmxlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdKSwgb25DbGljazogb25FZGdlQ2xpY2ssIG9uRG91YmxlQ2xpY2s6IG9uRWRnZURvdWJsZUNsaWNrLCBvbkNvbnRleHRNZW51OiBvbkVkZ2VDb250ZXh0TWVudSwgb25Nb3VzZUVudGVyOiBvbkVkZ2VNb3VzZUVudGVyLCBvbk1vdXNlTW92ZTogb25FZGdlTW91c2VNb3ZlLCBvbk1vdXNlTGVhdmU6IG9uRWRnZU1vdXNlTGVhdmUsIG9uS2V5RG93bjogaXNGb2N1c2FibGUgPyBvbktleURvd24gOiB1bmRlZmluZWQsIHRhYkluZGV4OiBpc0ZvY3VzYWJsZSA/IDAgOiB1bmRlZmluZWQsIHJvbGU6IGVkZ2UuYXJpYVJvbGUgPz8gKGlzRm9jdXNhYmxlID8gJ2dyb3VwJyA6ICdpbWcnKSwgXCJhcmlhLXJvbGVkZXNjcmlwdGlvblwiOiBcImVkZ2VcIiwgXCJkYXRhLWlkXCI6IGlkLCBcImRhdGEtdGVzdGlkXCI6IGByZl9fZWRnZS0ke2lkfWAsIFwiYXJpYS1sYWJlbFwiOiBlZGdlLmFyaWFMYWJlbCA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IGVkZ2UuYXJpYUxhYmVsIHx8IGBFZGdlIGZyb20gJHtlZGdlLnNvdXJjZX0gdG8gJHtlZGdlLnRhcmdldH1gLCBcImFyaWEtZGVzY3JpYmVkYnlcIjogaXNGb2N1c2FibGUgPyBgJHtBUklBX0VER0VfREVTQ19LRVl9LSR7cmZJZH1gIDogdW5kZWZpbmVkLCByZWY6IGVkZ2VSZWYsIC4uLmVkZ2UuZG9tQXR0cmlidXRlcywgY2hpbGRyZW46IFshcmVjb25uZWN0aW5nICYmIChqc3goRWRnZUNvbXBvbmVudCwgeyBpZDogaWQsIHNvdXJjZTogZWRnZS5zb3VyY2UsIHRhcmdldDogZWRnZS50YXJnZXQsIHR5cGU6IGVkZ2UudHlwZSwgc2VsZWN0ZWQ6IGVkZ2Uuc2VsZWN0ZWQsIGFuaW1hdGVkOiBlZGdlLmFuaW1hdGVkLCBzZWxlY3RhYmxlOiBpc1NlbGVjdGFibGUsIGRlbGV0YWJsZTogZWRnZS5kZWxldGFibGUgPz8gdHJ1ZSwgbGFiZWw6IGVkZ2UubGFiZWwsIGxhYmVsU3R5bGU6IGVkZ2UubGFiZWxTdHlsZSwgbGFiZWxTaG93Qmc6IGVkZ2UubGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZTogZWRnZS5sYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nOiBlZGdlLmxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzOiBlZGdlLmxhYmVsQmdCb3JkZXJSYWRpdXMsIHNvdXJjZVg6IHNvdXJjZVgsIHNvdXJjZVk6IHNvdXJjZVksIHRhcmdldFg6IHRhcmdldFgsIHRhcmdldFk6IHRhcmdldFksIHNvdXJjZVBvc2l0aW9uOiBzb3VyY2VQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb246IHRhcmdldFBvc2l0aW9uLCBkYXRhOiBlZGdlLmRhdGEsIHN0eWxlOiBlZGdlLnN0eWxlLCBzb3VyY2VIYW5kbGVJZDogZWRnZS5zb3VyY2VIYW5kbGUsIHRhcmdldEhhbmRsZUlkOiBlZGdlLnRhcmdldEhhbmRsZSwgbWFya2VyU3RhcnQ6IG1hcmtlclN0YXJ0VXJsLCBtYXJrZXJFbmQ6IG1hcmtlckVuZFVybCwgcGF0aE9wdGlvbnM6ICdwYXRoT3B0aW9ucycgaW4gZWRnZSA/IGVkZ2UucGF0aE9wdGlvbnMgOiB1bmRlZmluZWQsIGludGVyYWN0aW9uV2lkdGg6IGVkZ2UuaW50ZXJhY3Rpb25XaWR0aCB9KSksIGlzUmVjb25uZWN0YWJsZSAmJiAoanN4KEVkZ2VVcGRhdGVBbmNob3JzLCB7IGVkZ2U6IGVkZ2UsIGlzUmVjb25uZWN0YWJsZTogaXNSZWNvbm5lY3RhYmxlLCByZWNvbm5lY3RSYWRpdXM6IHJlY29ubmVjdFJhZGl1cywgb25SZWNvbm5lY3Q6IG9uUmVjb25uZWN0LCBvblJlY29ubmVjdFN0YXJ0OiBvblJlY29ubmVjdFN0YXJ0LCBvblJlY29ubmVjdEVuZDogb25SZWNvbm5lY3RFbmQsIHNvdXJjZVg6IHNvdXJjZVgsIHNvdXJjZVk6IHNvdXJjZVksIHRhcmdldFg6IHRhcmdldFgsIHRhcmdldFk6IHRhcmdldFksIHNvdXJjZVBvc2l0aW9uOiBzb3VyY2VQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb246IHRhcmdldFBvc2l0aW9uLCBzZXRVcGRhdGVIb3Zlcjogc2V0VXBkYXRlSG92ZXIsIHNldFJlY29ubmVjdGluZzogc2V0UmVjb25uZWN0aW5nIH0pKV0gfSkgfSkpO1xufVxuXG5jb25zdCBzZWxlY3RvciRhID0gKHMpID0+ICh7XG4gICAgZWRnZXNGb2N1c2FibGU6IHMuZWRnZXNGb2N1c2FibGUsXG4gICAgZWRnZXNSZWNvbm5lY3RhYmxlOiBzLmVkZ2VzUmVjb25uZWN0YWJsZSxcbiAgICBlbGVtZW50c1NlbGVjdGFibGU6IHMuZWxlbWVudHNTZWxlY3RhYmxlLFxuICAgIGNvbm5lY3Rpb25Nb2RlOiBzLmNvbm5lY3Rpb25Nb2RlLFxuICAgIG9uRXJyb3I6IHMub25FcnJvcixcbn0pO1xuZnVuY3Rpb24gRWRnZVJlbmRlcmVyQ29tcG9uZW50KHsgZGVmYXVsdE1hcmtlckNvbG9yLCBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzLCByZklkLCBlZGdlVHlwZXMsIG5vUGFuQ2xhc3NOYW1lLCBvblJlY29ubmVjdCwgb25FZGdlQ29udGV4dE1lbnUsIG9uRWRnZU1vdXNlRW50ZXIsIG9uRWRnZU1vdXNlTW92ZSwgb25FZGdlTW91c2VMZWF2ZSwgb25FZGdlQ2xpY2ssIHJlY29ubmVjdFJhZGl1cywgb25FZGdlRG91YmxlQ2xpY2ssIG9uUmVjb25uZWN0U3RhcnQsIG9uUmVjb25uZWN0RW5kLCBkaXNhYmxlS2V5Ym9hcmRBMTF5LCB9KSB7XG4gICAgY29uc3QgeyBlZGdlc0ZvY3VzYWJsZSwgZWRnZXNSZWNvbm5lY3RhYmxlLCBlbGVtZW50c1NlbGVjdGFibGUsIG9uRXJyb3IgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJGEsIHNoYWxsb3cpO1xuICAgIGNvbnN0IGVkZ2VJZHMgPSB1c2VWaXNpYmxlRWRnZUlkcyhvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzKTtcbiAgICByZXR1cm4gKGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fZWRnZXNcIiwgY2hpbGRyZW46IFtqc3goTWFya2VyRGVmaW5pdGlvbnMkMSwgeyBkZWZhdWx0Q29sb3I6IGRlZmF1bHRNYXJrZXJDb2xvciwgcmZJZDogcmZJZCB9KSwgZWRnZUlkcy5tYXAoKGlkKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChqc3goRWRnZVdyYXBwZXIsIHsgaWQ6IGlkLCBlZGdlc0ZvY3VzYWJsZTogZWRnZXNGb2N1c2FibGUsIGVkZ2VzUmVjb25uZWN0YWJsZTogZWRnZXNSZWNvbm5lY3RhYmxlLCBlbGVtZW50c1NlbGVjdGFibGU6IGVsZW1lbnRzU2VsZWN0YWJsZSwgbm9QYW5DbGFzc05hbWU6IG5vUGFuQ2xhc3NOYW1lLCBvblJlY29ubmVjdDogb25SZWNvbm5lY3QsIG9uQ29udGV4dE1lbnU6IG9uRWRnZUNvbnRleHRNZW51LCBvbk1vdXNlRW50ZXI6IG9uRWRnZU1vdXNlRW50ZXIsIG9uTW91c2VNb3ZlOiBvbkVkZ2VNb3VzZU1vdmUsIG9uTW91c2VMZWF2ZTogb25FZGdlTW91c2VMZWF2ZSwgb25DbGljazogb25FZGdlQ2xpY2ssIHJlY29ubmVjdFJhZGl1czogcmVjb25uZWN0UmFkaXVzLCBvbkRvdWJsZUNsaWNrOiBvbkVkZ2VEb3VibGVDbGljaywgb25SZWNvbm5lY3RTdGFydDogb25SZWNvbm5lY3RTdGFydCwgb25SZWNvbm5lY3RFbmQ6IG9uUmVjb25uZWN0RW5kLCByZklkOiByZklkLCBvbkVycm9yOiBvbkVycm9yLCBlZGdlVHlwZXM6IGVkZ2VUeXBlcywgZGlzYWJsZUtleWJvYXJkQTExeTogZGlzYWJsZUtleWJvYXJkQTExeSB9LCBpZCkpO1xuICAgICAgICAgICAgfSldIH0pKTtcbn1cbkVkZ2VSZW5kZXJlckNvbXBvbmVudC5kaXNwbGF5TmFtZSA9ICdFZGdlUmVuZGVyZXInO1xuY29uc3QgRWRnZVJlbmRlcmVyID0gbWVtbyhFZGdlUmVuZGVyZXJDb21wb25lbnQpO1xuXG5jb25zdCBzZWxlY3RvciQ5ID0gKHMpID0+IGB0cmFuc2xhdGUoJHtzLnRyYW5zZm9ybVswXX1weCwke3MudHJhbnNmb3JtWzFdfXB4KSBzY2FsZSgke3MudHJhbnNmb3JtWzJdfSlgO1xuZnVuY3Rpb24gVmlld3BvcnQoeyBjaGlsZHJlbiB9KSB7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gdXNlU3RvcmUoc2VsZWN0b3IkOSk7XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fdmlld3BvcnQgeHlmbG93X192aWV3cG9ydCByZWFjdC1mbG93X19jb250YWluZXJcIiwgc3R5bGU6IHsgdHJhbnNmb3JtIH0sIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59XG5cbi8qKlxuICogSG9vayBmb3IgY2FsbGluZyBvbkluaXQgaGFuZGxlci5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdXNlT25Jbml0SGFuZGxlcihvbkluaXQpIHtcbiAgICBjb25zdCByZkluc3RhbmNlID0gdXNlUmVhY3RGbG93KCk7XG4gICAgY29uc3QgaXNJbml0aWFsaXplZCA9IHVzZVJlZihmYWxzZSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFpc0luaXRpYWxpemVkLmN1cnJlbnQgJiYgcmZJbnN0YW5jZS52aWV3cG9ydEluaXRpYWxpemVkICYmIG9uSW5pdCkge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBvbkluaXQocmZJbnN0YW5jZSksIDEpO1xuICAgICAgICAgICAgaXNJbml0aWFsaXplZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkluaXQsIHJmSW5zdGFuY2Uudmlld3BvcnRJbml0aWFsaXplZF0pO1xufVxuXG5jb25zdCBzZWxlY3RvciQ4ID0gKHN0YXRlKSA9PiBzdGF0ZS5wYW5ab29tPy5zeW5jVmlld3BvcnQ7XG4vKipcbiAqIEhvb2sgZm9yIHN5bmNpbmcgdGhlIHZpZXdwb3J0IHdpdGggdGhlIHBhbnpvb20gaW5zdGFuY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0gdmlld3BvcnRcbiAqL1xuZnVuY3Rpb24gdXNlVmlld3BvcnRTeW5jKHZpZXdwb3J0KSB7XG4gICAgY29uc3Qgc3luY1ZpZXdwb3J0ID0gdXNlU3RvcmUoc2VsZWN0b3IkOCk7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICh2aWV3cG9ydCkge1xuICAgICAgICAgICAgc3luY1ZpZXdwb3J0Py4odmlld3BvcnQpO1xuICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyB0cmFuc2Zvcm06IFt2aWV3cG9ydC54LCB2aWV3cG9ydC55LCB2aWV3cG9ydC56b29tXSB9KTtcbiAgICAgICAgfVxuICAgIH0sIFt2aWV3cG9ydCwgc3luY1ZpZXdwb3J0XSk7XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHN0b3JlU2VsZWN0b3IkMShzKSB7XG4gICAgcmV0dXJuIHMuY29ubmVjdGlvbi5pblByb2dyZXNzXG4gICAgICAgID8geyAuLi5zLmNvbm5lY3Rpb24sIHRvOiBwb2ludFRvUmVuZGVyZXJQb2ludChzLmNvbm5lY3Rpb24udG8sIHMudHJhbnNmb3JtKSB9XG4gICAgICAgIDogeyAuLi5zLmNvbm5lY3Rpb24gfTtcbn1cbmZ1bmN0aW9uIGdldFNlbGVjdG9yKGNvbm5lY3Rpb25TZWxlY3Rvcikge1xuICAgIGlmIChjb25uZWN0aW9uU2VsZWN0b3IpIHtcbiAgICAgICAgY29uc3QgY29tYmluZWRTZWxlY3RvciA9IChzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gc3RvcmVTZWxlY3RvciQxKHMpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb25TZWxlY3Rvcihjb25uZWN0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVkU2VsZWN0b3I7XG4gICAgfVxuICAgIHJldHVybiBzdG9yZVNlbGVjdG9yJDE7XG59XG4vKipcbiAqIFRoZSBgdXNlQ29ubmVjdGlvbmAgaG9vayByZXR1cm5zIHRoZSBjdXJyZW50IGNvbm5lY3Rpb24gd2hlbiB0aGVyZSBpcyBhbiBhY3RpdmVcbiAqIGNvbm5lY3Rpb24gaW50ZXJhY3Rpb24uIElmIG5vIGNvbm5lY3Rpb24gaW50ZXJhY3Rpb24gaXMgYWN0aXZlLCBpdCByZXR1cm5zIG51bGxcbiAqIGZvciBldmVyeSBwcm9wZXJ0eS4gQSB0eXBpY2FsIHVzZSBjYXNlIGZvciB0aGlzIGhvb2sgaXMgdG8gY29sb3JpemUgaGFuZGxlc1xuICogYmFzZWQgb24gYSBjZXJ0YWluIGNvbmRpdGlvbiAoZS5nLiBpZiB0aGUgY29ubmVjdGlvbiBpcyB2YWxpZCBvciBub3QpLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBjb25uZWN0aW9uU2VsZWN0b3IgLSBBbiBvcHRpb25hbCBzZWxlY3RvciBmdW5jdGlvbiB1c2VkIHRvIGV4dHJhY3QgYSBzbGljZSBvZiB0aGVcbiAqIGBDb25uZWN0aW9uU3RhdGVgIGRhdGEuIFVzaW5nIGEgc2VsZWN0b3IgY2FuIHByZXZlbnQgY29tcG9uZW50IHJlLXJlbmRlcnMgd2hlcmUgZGF0YSB5b3UgZG9uJ3RcbiAqIG90aGVyd2lzZSBjYXJlIGFib3V0IG1pZ2h0IGNoYW5nZS4gSWYgYSBzZWxlY3RvciBpcyBub3QgcHJvdmlkZWQsIHRoZSBlbnRpcmUgYENvbm5lY3Rpb25TdGF0ZWBcbiAqIG9iamVjdCBpcyByZXR1cm5lZCB1bmNoYW5nZWQuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzeFxuICppbXBvcnQgeyB1c2VDb25uZWN0aW9uIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpmdW5jdGlvbiBBcHAoKSB7XG4gKiAgY29uc3QgY29ubmVjdGlvbiA9IHVzZUNvbm5lY3Rpb24oKTtcbiAqXG4gKiAgcmV0dXJuIChcbiAqICAgIDxkaXY+IHtjb25uZWN0aW9uID8gYFNvbWVvbmUgaXMgdHJ5aW5nIHRvIG1ha2UgYSBjb25uZWN0aW9uIGZyb20gJHtjb25uZWN0aW9uLmZyb21Ob2RlfSB0byB0aGlzIG9uZS5gIDogJ1RoZXJlIGFyZSBjdXJyZW50bHkgbm8gaW5jb21pbmcgY29ubmVjdGlvbnMhJ31cbiAqXG4gKiAgIDwvZGl2PlxuICogICApO1xuICogfVxuICogYGBgXG4gKlxuICogQHJldHVybnMgQ29ubmVjdGlvblN0YXRlXG4gKi9cbmZ1bmN0aW9uIHVzZUNvbm5lY3Rpb24oY29ubmVjdGlvblNlbGVjdG9yKSB7XG4gICAgY29uc3QgY29tYmluZWRTZWxlY3RvciA9IGdldFNlbGVjdG9yKGNvbm5lY3Rpb25TZWxlY3Rvcik7XG4gICAgcmV0dXJuIHVzZVN0b3JlKGNvbWJpbmVkU2VsZWN0b3IsIHNoYWxsb3cpO1xufVxuXG5jb25zdCBzZWxlY3RvciQ3ID0gKHMpID0+ICh7XG4gICAgbm9kZXNDb25uZWN0YWJsZTogcy5ub2Rlc0Nvbm5lY3RhYmxlLFxuICAgIGlzVmFsaWQ6IHMuY29ubmVjdGlvbi5pc1ZhbGlkLFxuICAgIGluUHJvZ3Jlc3M6IHMuY29ubmVjdGlvbi5pblByb2dyZXNzLFxuICAgIHdpZHRoOiBzLndpZHRoLFxuICAgIGhlaWdodDogcy5oZWlnaHQsXG59KTtcbmZ1bmN0aW9uIENvbm5lY3Rpb25MaW5lV3JhcHBlcih7IGNvbnRhaW5lclN0eWxlLCBzdHlsZSwgdHlwZSwgY29tcG9uZW50LCB9KSB7XG4gICAgY29uc3QgeyBub2Rlc0Nvbm5lY3RhYmxlLCB3aWR0aCwgaGVpZ2h0LCBpc1ZhbGlkLCBpblByb2dyZXNzIH0gPSB1c2VTdG9yZShzZWxlY3RvciQ3LCBzaGFsbG93KTtcbiAgICBjb25zdCByZW5kZXJDb25uZWN0aW9uID0gISEod2lkdGggJiYgbm9kZXNDb25uZWN0YWJsZSAmJiBpblByb2dyZXNzKTtcbiAgICBpZiAoIXJlbmRlckNvbm5lY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoanN4KFwic3ZnXCIsIHsgc3R5bGU6IGNvbnRhaW5lclN0eWxlLCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LCBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fY29ubmVjdGlvbmxpbmUgcmVhY3QtZmxvd19fY29udGFpbmVyXCIsIGNoaWxkcmVuOiBqc3goXCJnXCIsIHsgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX2Nvbm5lY3Rpb24nLCBnZXRDb25uZWN0aW9uU3RhdHVzKGlzVmFsaWQpXSksIGNoaWxkcmVuOiBqc3goQ29ubmVjdGlvbkxpbmUsIHsgc3R5bGU6IHN0eWxlLCB0eXBlOiB0eXBlLCBDdXN0b21Db21wb25lbnQ6IGNvbXBvbmVudCwgaXNWYWxpZDogaXNWYWxpZCB9KSB9KSB9KSk7XG59XG5jb25zdCBDb25uZWN0aW9uTGluZSA9ICh7IHN0eWxlLCB0eXBlID0gQ29ubmVjdGlvbkxpbmVUeXBlLkJlemllciwgQ3VzdG9tQ29tcG9uZW50LCBpc1ZhbGlkLCB9KSA9PiB7XG4gICAgY29uc3QgeyBpblByb2dyZXNzLCBmcm9tLCBmcm9tTm9kZSwgZnJvbUhhbmRsZSwgZnJvbVBvc2l0aW9uLCB0bywgdG9Ob2RlLCB0b0hhbmRsZSwgdG9Qb3NpdGlvbiB9ID0gdXNlQ29ubmVjdGlvbigpO1xuICAgIGlmICghaW5Qcm9ncmVzcykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChDdXN0b21Db21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIChqc3goQ3VzdG9tQ29tcG9uZW50LCB7IGNvbm5lY3Rpb25MaW5lVHlwZTogdHlwZSwgY29ubmVjdGlvbkxpbmVTdHlsZTogc3R5bGUsIGZyb21Ob2RlOiBmcm9tTm9kZSwgZnJvbUhhbmRsZTogZnJvbUhhbmRsZSwgZnJvbVg6IGZyb20ueCwgZnJvbVk6IGZyb20ueSwgdG9YOiB0by54LCB0b1k6IHRvLnksIGZyb21Qb3NpdGlvbjogZnJvbVBvc2l0aW9uLCB0b1Bvc2l0aW9uOiB0b1Bvc2l0aW9uLCBjb25uZWN0aW9uU3RhdHVzOiBnZXRDb25uZWN0aW9uU3RhdHVzKGlzVmFsaWQpLCB0b05vZGU6IHRvTm9kZSwgdG9IYW5kbGU6IHRvSGFuZGxlIH0pKTtcbiAgICB9XG4gICAgbGV0IHBhdGggPSAnJztcbiAgICBjb25zdCBwYXRoUGFyYW1zID0ge1xuICAgICAgICBzb3VyY2VYOiBmcm9tLngsXG4gICAgICAgIHNvdXJjZVk6IGZyb20ueSxcbiAgICAgICAgc291cmNlUG9zaXRpb246IGZyb21Qb3NpdGlvbixcbiAgICAgICAgdGFyZ2V0WDogdG8ueCxcbiAgICAgICAgdGFyZ2V0WTogdG8ueSxcbiAgICAgICAgdGFyZ2V0UG9zaXRpb246IHRvUG9zaXRpb24sXG4gICAgfTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBDb25uZWN0aW9uTGluZVR5cGUuQmV6aWVyOlxuICAgICAgICAgICAgW3BhdGhdID0gZ2V0QmV6aWVyUGF0aChwYXRoUGFyYW1zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENvbm5lY3Rpb25MaW5lVHlwZS5TaW1wbGVCZXppZXI6XG4gICAgICAgICAgICBbcGF0aF0gPSBnZXRTaW1wbGVCZXppZXJQYXRoKHBhdGhQYXJhbXMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ29ubmVjdGlvbkxpbmVUeXBlLlN0ZXA6XG4gICAgICAgICAgICBbcGF0aF0gPSBnZXRTbW9vdGhTdGVwUGF0aCh7XG4gICAgICAgICAgICAgICAgLi4ucGF0aFBhcmFtcyxcbiAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IDAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENvbm5lY3Rpb25MaW5lVHlwZS5TbW9vdGhTdGVwOlxuICAgICAgICAgICAgW3BhdGhdID0gZ2V0U21vb3RoU3RlcFBhdGgocGF0aFBhcmFtcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIFtwYXRoXSA9IGdldFN0cmFpZ2h0UGF0aChwYXRoUGFyYW1zKTtcbiAgICB9XG4gICAgcmV0dXJuIGpzeChcInBhdGhcIiwgeyBkOiBwYXRoLCBmaWxsOiBcIm5vbmVcIiwgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2Nvbm5lY3Rpb24tcGF0aFwiLCBzdHlsZTogc3R5bGUgfSk7XG59O1xuQ29ubmVjdGlvbkxpbmUuZGlzcGxheU5hbWUgPSAnQ29ubmVjdGlvbkxpbmUnO1xuXG5jb25zdCBlbXB0eVR5cGVzID0ge307XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gdXNlTm9kZU9yRWRnZVR5cGVzV2FybmluZyhub2RlT3JFZGdlVHlwZXMgPSBlbXB0eVR5cGVzKSB7XG4gICAgY29uc3QgdHlwZXNSZWYgPSB1c2VSZWYobm9kZU9yRWRnZVR5cGVzKTtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgICBjb25zdCB1c2VkS2V5cyA9IG5ldyBTZXQoWy4uLk9iamVjdC5rZXlzKHR5cGVzUmVmLmN1cnJlbnQpLCAuLi5PYmplY3Qua2V5cyhub2RlT3JFZGdlVHlwZXMpXSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB1c2VkS2V5cykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlc1JlZi5jdXJyZW50W2tleV0gIT09IG5vZGVPckVkZ2VUeXBlc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlLmdldFN0YXRlKCkub25FcnJvcj8uKCcwMDInLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAwMiddKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0eXBlc1JlZi5jdXJyZW50ID0gbm9kZU9yRWRnZVR5cGVzO1xuICAgICAgICB9XG4gICAgfSwgW25vZGVPckVkZ2VUeXBlc10pO1xufVxuXG5mdW5jdGlvbiB1c2VTdHlsZXNMb2FkZWRXYXJuaW5nKCkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCBjaGVja2VkID0gdXNlUmVmKGZhbHNlKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgIGlmICghY2hlY2tlZC5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFuZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5yZWFjdC1mbG93X19wYW5lJyk7XG4gICAgICAgICAgICAgICAgaWYgKHBhbmUgJiYgISh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShwYW5lKS56SW5kZXggPT09ICcxJykpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUuZ2V0U3RhdGUoKS5vbkVycm9yPy4oJzAxMycsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDEzJ10oJ3JlYWN0JykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGVja2VkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW10pO1xufVxuXG5mdW5jdGlvbiBHcmFwaFZpZXdDb21wb25lbnQoeyBub2RlVHlwZXMsIGVkZ2VUeXBlcywgb25Jbml0LCBvbk5vZGVDbGljaywgb25FZGdlQ2xpY2ssIG9uTm9kZURvdWJsZUNsaWNrLCBvbkVkZ2VEb3VibGVDbGljaywgb25Ob2RlTW91c2VFbnRlciwgb25Ob2RlTW91c2VNb3ZlLCBvbk5vZGVNb3VzZUxlYXZlLCBvbk5vZGVDb250ZXh0TWVudSwgb25TZWxlY3Rpb25Db250ZXh0TWVudSwgb25TZWxlY3Rpb25TdGFydCwgb25TZWxlY3Rpb25FbmQsIGNvbm5lY3Rpb25MaW5lVHlwZSwgY29ubmVjdGlvbkxpbmVTdHlsZSwgY29ubmVjdGlvbkxpbmVDb21wb25lbnQsIGNvbm5lY3Rpb25MaW5lQ29udGFpbmVyU3R5bGUsIHNlbGVjdGlvbktleUNvZGUsIHNlbGVjdGlvbk9uRHJhZywgc2VsZWN0aW9uTW9kZSwgbXVsdGlTZWxlY3Rpb25LZXlDb2RlLCBwYW5BY3RpdmF0aW9uS2V5Q29kZSwgem9vbUFjdGl2YXRpb25LZXlDb2RlLCBkZWxldGVLZXlDb2RlLCBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzLCBlbGVtZW50c1NlbGVjdGFibGUsIGRlZmF1bHRWaWV3cG9ydCwgdHJhbnNsYXRlRXh0ZW50LCBtaW5ab29tLCBtYXhab29tLCBwcmV2ZW50U2Nyb2xsaW5nLCBkZWZhdWx0TWFya2VyQ29sb3IsIHpvb21PblNjcm9sbCwgem9vbU9uUGluY2gsIHBhbk9uU2Nyb2xsLCBwYW5PblNjcm9sbFNwZWVkLCBwYW5PblNjcm9sbE1vZGUsIHpvb21PbkRvdWJsZUNsaWNrLCBwYW5PbkRyYWcsIG9uUGFuZUNsaWNrLCBvblBhbmVNb3VzZUVudGVyLCBvblBhbmVNb3VzZU1vdmUsIG9uUGFuZU1vdXNlTGVhdmUsIG9uUGFuZVNjcm9sbCwgb25QYW5lQ29udGV4dE1lbnUsIHBhbmVDbGlja0Rpc3RhbmNlLCBub2RlQ2xpY2tEaXN0YW5jZSwgb25FZGdlQ29udGV4dE1lbnUsIG9uRWRnZU1vdXNlRW50ZXIsIG9uRWRnZU1vdXNlTW92ZSwgb25FZGdlTW91c2VMZWF2ZSwgcmVjb25uZWN0UmFkaXVzLCBvblJlY29ubmVjdCwgb25SZWNvbm5lY3RTdGFydCwgb25SZWNvbm5lY3RFbmQsIG5vRHJhZ0NsYXNzTmFtZSwgbm9XaGVlbENsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWUsIGRpc2FibGVLZXlib2FyZEExMXksIG5vZGVFeHRlbnQsIHJmSWQsIHZpZXdwb3J0LCBvblZpZXdwb3J0Q2hhbmdlLCB9KSB7XG4gICAgdXNlTm9kZU9yRWRnZVR5cGVzV2FybmluZyhub2RlVHlwZXMpO1xuICAgIHVzZU5vZGVPckVkZ2VUeXBlc1dhcm5pbmcoZWRnZVR5cGVzKTtcbiAgICB1c2VTdHlsZXNMb2FkZWRXYXJuaW5nKCk7XG4gICAgdXNlT25Jbml0SGFuZGxlcihvbkluaXQpO1xuICAgIHVzZVZpZXdwb3J0U3luYyh2aWV3cG9ydCk7XG4gICAgcmV0dXJuIChqc3goRmxvd1JlbmRlcmVyLCB7IG9uUGFuZUNsaWNrOiBvblBhbmVDbGljaywgb25QYW5lTW91c2VFbnRlcjogb25QYW5lTW91c2VFbnRlciwgb25QYW5lTW91c2VNb3ZlOiBvblBhbmVNb3VzZU1vdmUsIG9uUGFuZU1vdXNlTGVhdmU6IG9uUGFuZU1vdXNlTGVhdmUsIG9uUGFuZUNvbnRleHRNZW51OiBvblBhbmVDb250ZXh0TWVudSwgb25QYW5lU2Nyb2xsOiBvblBhbmVTY3JvbGwsIHBhbmVDbGlja0Rpc3RhbmNlOiBwYW5lQ2xpY2tEaXN0YW5jZSwgZGVsZXRlS2V5Q29kZTogZGVsZXRlS2V5Q29kZSwgc2VsZWN0aW9uS2V5Q29kZTogc2VsZWN0aW9uS2V5Q29kZSwgc2VsZWN0aW9uT25EcmFnOiBzZWxlY3Rpb25PbkRyYWcsIHNlbGVjdGlvbk1vZGU6IHNlbGVjdGlvbk1vZGUsIG9uU2VsZWN0aW9uU3RhcnQ6IG9uU2VsZWN0aW9uU3RhcnQsIG9uU2VsZWN0aW9uRW5kOiBvblNlbGVjdGlvbkVuZCwgbXVsdGlTZWxlY3Rpb25LZXlDb2RlOiBtdWx0aVNlbGVjdGlvbktleUNvZGUsIHBhbkFjdGl2YXRpb25LZXlDb2RlOiBwYW5BY3RpdmF0aW9uS2V5Q29kZSwgem9vbUFjdGl2YXRpb25LZXlDb2RlOiB6b29tQWN0aXZhdGlvbktleUNvZGUsIGVsZW1lbnRzU2VsZWN0YWJsZTogZWxlbWVudHNTZWxlY3RhYmxlLCB6b29tT25TY3JvbGw6IHpvb21PblNjcm9sbCwgem9vbU9uUGluY2g6IHpvb21PblBpbmNoLCB6b29tT25Eb3VibGVDbGljazogem9vbU9uRG91YmxlQ2xpY2ssIHBhbk9uU2Nyb2xsOiBwYW5PblNjcm9sbCwgcGFuT25TY3JvbGxTcGVlZDogcGFuT25TY3JvbGxTcGVlZCwgcGFuT25TY3JvbGxNb2RlOiBwYW5PblNjcm9sbE1vZGUsIHBhbk9uRHJhZzogcGFuT25EcmFnLCBkZWZhdWx0Vmlld3BvcnQ6IGRlZmF1bHRWaWV3cG9ydCwgdHJhbnNsYXRlRXh0ZW50OiB0cmFuc2xhdGVFeHRlbnQsIG1pblpvb206IG1pblpvb20sIG1heFpvb206IG1heFpvb20sIG9uU2VsZWN0aW9uQ29udGV4dE1lbnU6IG9uU2VsZWN0aW9uQ29udGV4dE1lbnUsIHByZXZlbnRTY3JvbGxpbmc6IHByZXZlbnRTY3JvbGxpbmcsIG5vRHJhZ0NsYXNzTmFtZTogbm9EcmFnQ2xhc3NOYW1lLCBub1doZWVsQ2xhc3NOYW1lOiBub1doZWVsQ2xhc3NOYW1lLCBub1BhbkNsYXNzTmFtZTogbm9QYW5DbGFzc05hbWUsIGRpc2FibGVLZXlib2FyZEExMXk6IGRpc2FibGVLZXlib2FyZEExMXksIG9uVmlld3BvcnRDaGFuZ2U6IG9uVmlld3BvcnRDaGFuZ2UsIGlzQ29udHJvbGxlZFZpZXdwb3J0OiAhIXZpZXdwb3J0LCBjaGlsZHJlbjoganN4cyhWaWV3cG9ydCwgeyBjaGlsZHJlbjogW2pzeChFZGdlUmVuZGVyZXIsIHsgZWRnZVR5cGVzOiBlZGdlVHlwZXMsIG9uRWRnZUNsaWNrOiBvbkVkZ2VDbGljaywgb25FZGdlRG91YmxlQ2xpY2s6IG9uRWRnZURvdWJsZUNsaWNrLCBvblJlY29ubmVjdDogb25SZWNvbm5lY3QsIG9uUmVjb25uZWN0U3RhcnQ6IG9uUmVjb25uZWN0U3RhcnQsIG9uUmVjb25uZWN0RW5kOiBvblJlY29ubmVjdEVuZCwgb25seVJlbmRlclZpc2libGVFbGVtZW50czogb25seVJlbmRlclZpc2libGVFbGVtZW50cywgb25FZGdlQ29udGV4dE1lbnU6IG9uRWRnZUNvbnRleHRNZW51LCBvbkVkZ2VNb3VzZUVudGVyOiBvbkVkZ2VNb3VzZUVudGVyLCBvbkVkZ2VNb3VzZU1vdmU6IG9uRWRnZU1vdXNlTW92ZSwgb25FZGdlTW91c2VMZWF2ZTogb25FZGdlTW91c2VMZWF2ZSwgcmVjb25uZWN0UmFkaXVzOiByZWNvbm5lY3RSYWRpdXMsIGRlZmF1bHRNYXJrZXJDb2xvcjogZGVmYXVsdE1hcmtlckNvbG9yLCBub1BhbkNsYXNzTmFtZTogbm9QYW5DbGFzc05hbWUsIGRpc2FibGVLZXlib2FyZEExMXk6IGRpc2FibGVLZXlib2FyZEExMXksIHJmSWQ6IHJmSWQgfSksIGpzeChDb25uZWN0aW9uTGluZVdyYXBwZXIsIHsgc3R5bGU6IGNvbm5lY3Rpb25MaW5lU3R5bGUsIHR5cGU6IGNvbm5lY3Rpb25MaW5lVHlwZSwgY29tcG9uZW50OiBjb25uZWN0aW9uTGluZUNvbXBvbmVudCwgY29udGFpbmVyU3R5bGU6IGNvbm5lY3Rpb25MaW5lQ29udGFpbmVyU3R5bGUgfSksIGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19lZGdlbGFiZWwtcmVuZGVyZXJcIiB9KSwganN4KE5vZGVSZW5kZXJlciwgeyBub2RlVHlwZXM6IG5vZGVUeXBlcywgb25Ob2RlQ2xpY2s6IG9uTm9kZUNsaWNrLCBvbk5vZGVEb3VibGVDbGljazogb25Ob2RlRG91YmxlQ2xpY2ssIG9uTm9kZU1vdXNlRW50ZXI6IG9uTm9kZU1vdXNlRW50ZXIsIG9uTm9kZU1vdXNlTW92ZTogb25Ob2RlTW91c2VNb3ZlLCBvbk5vZGVNb3VzZUxlYXZlOiBvbk5vZGVNb3VzZUxlYXZlLCBvbk5vZGVDb250ZXh0TWVudTogb25Ob2RlQ29udGV4dE1lbnUsIG5vZGVDbGlja0Rpc3RhbmNlOiBub2RlQ2xpY2tEaXN0YW5jZSwgb25seVJlbmRlclZpc2libGVFbGVtZW50czogb25seVJlbmRlclZpc2libGVFbGVtZW50cywgbm9QYW5DbGFzc05hbWU6IG5vUGFuQ2xhc3NOYW1lLCBub0RyYWdDbGFzc05hbWU6IG5vRHJhZ0NsYXNzTmFtZSwgZGlzYWJsZUtleWJvYXJkQTExeTogZGlzYWJsZUtleWJvYXJkQTExeSwgbm9kZUV4dGVudDogbm9kZUV4dGVudCwgcmZJZDogcmZJZCB9KSwganN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX3ZpZXdwb3J0LXBvcnRhbFwiIH0pXSB9KSB9KSk7XG59XG5HcmFwaFZpZXdDb21wb25lbnQuZGlzcGxheU5hbWUgPSAnR3JhcGhWaWV3JztcbmNvbnN0IEdyYXBoVmlldyA9IG1lbW8oR3JhcGhWaWV3Q29tcG9uZW50KTtcblxuY29uc3QgZ2V0SW5pdGlhbFN0YXRlID0gKHsgbm9kZXMsIGVkZ2VzLCBkZWZhdWx0Tm9kZXMsIGRlZmF1bHRFZGdlcywgd2lkdGgsIGhlaWdodCwgZml0VmlldywgZml0Vmlld09wdGlvbnMsIG1pblpvb20gPSAwLjUsIG1heFpvb20gPSAyLCBub2RlT3JpZ2luLCBub2RlRXh0ZW50LCB9ID0ge30pID0+IHtcbiAgICBjb25zdCBub2RlTG9va3VwID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHBhcmVudExvb2t1cCA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBjb25uZWN0aW9uTG9va3VwID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGVkZ2VMb29rdXAgPSBuZXcgTWFwKCk7XG4gICAgY29uc3Qgc3RvcmVFZGdlcyA9IGRlZmF1bHRFZGdlcyA/PyBlZGdlcyA/PyBbXTtcbiAgICBjb25zdCBzdG9yZU5vZGVzID0gZGVmYXVsdE5vZGVzID8/IG5vZGVzID8/IFtdO1xuICAgIGNvbnN0IHN0b3JlTm9kZU9yaWdpbiA9IG5vZGVPcmlnaW4gPz8gWzAsIDBdO1xuICAgIGNvbnN0IHN0b3JlTm9kZUV4dGVudCA9IG5vZGVFeHRlbnQgPz8gaW5maW5pdGVFeHRlbnQ7XG4gICAgdXBkYXRlQ29ubmVjdGlvbkxvb2t1cChjb25uZWN0aW9uTG9va3VwLCBlZGdlTG9va3VwLCBzdG9yZUVkZ2VzKTtcbiAgICBjb25zdCBub2Rlc0luaXRpYWxpemVkID0gYWRvcHRVc2VyTm9kZXMoc3RvcmVOb2Rlcywgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCB7XG4gICAgICAgIG5vZGVPcmlnaW46IHN0b3JlTm9kZU9yaWdpbixcbiAgICAgICAgbm9kZUV4dGVudDogc3RvcmVOb2RlRXh0ZW50LFxuICAgICAgICBlbGV2YXRlTm9kZXNPblNlbGVjdDogZmFsc2UsXG4gICAgfSk7XG4gICAgbGV0IHRyYW5zZm9ybSA9IFswLCAwLCAxXTtcbiAgICBpZiAoZml0VmlldyAmJiB3aWR0aCAmJiBoZWlnaHQpIHtcbiAgICAgICAgY29uc3QgYm91bmRzID0gZ2V0SW50ZXJuYWxOb2Rlc0JvdW5kcyhub2RlTG9va3VwLCB7XG4gICAgICAgICAgICBmaWx0ZXI6IChub2RlKSA9PiAhISgobm9kZS53aWR0aCB8fCBub2RlLmluaXRpYWxXaWR0aCkgJiYgKG5vZGUuaGVpZ2h0IHx8IG5vZGUuaW5pdGlhbEhlaWdodCkpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgeyB4LCB5LCB6b29tIH0gPSBnZXRWaWV3cG9ydEZvckJvdW5kcyhib3VuZHMsIHdpZHRoLCBoZWlnaHQsIG1pblpvb20sIG1heFpvb20sIGZpdFZpZXdPcHRpb25zPy5wYWRkaW5nID8/IDAuMSk7XG4gICAgICAgIHRyYW5zZm9ybSA9IFt4LCB5LCB6b29tXTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmZJZDogJzEnLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICB0cmFuc2Zvcm0sXG4gICAgICAgIG5vZGVzOiBzdG9yZU5vZGVzLFxuICAgICAgICBub2Rlc0luaXRpYWxpemVkLFxuICAgICAgICBub2RlTG9va3VwLFxuICAgICAgICBwYXJlbnRMb29rdXAsXG4gICAgICAgIGVkZ2VzOiBzdG9yZUVkZ2VzLFxuICAgICAgICBlZGdlTG9va3VwLFxuICAgICAgICBjb25uZWN0aW9uTG9va3VwLFxuICAgICAgICBvbk5vZGVzQ2hhbmdlOiBudWxsLFxuICAgICAgICBvbkVkZ2VzQ2hhbmdlOiBudWxsLFxuICAgICAgICBoYXNEZWZhdWx0Tm9kZXM6IGRlZmF1bHROb2RlcyAhPT0gdW5kZWZpbmVkLFxuICAgICAgICBoYXNEZWZhdWx0RWRnZXM6IGRlZmF1bHRFZGdlcyAhPT0gdW5kZWZpbmVkLFxuICAgICAgICBwYW5ab29tOiBudWxsLFxuICAgICAgICBtaW5ab29tLFxuICAgICAgICBtYXhab29tLFxuICAgICAgICB0cmFuc2xhdGVFeHRlbnQ6IGluZmluaXRlRXh0ZW50LFxuICAgICAgICBub2RlRXh0ZW50OiBzdG9yZU5vZGVFeHRlbnQsXG4gICAgICAgIG5vZGVzU2VsZWN0aW9uQWN0aXZlOiBmYWxzZSxcbiAgICAgICAgdXNlclNlbGVjdGlvbkFjdGl2ZTogZmFsc2UsXG4gICAgICAgIHVzZXJTZWxlY3Rpb25SZWN0OiBudWxsLFxuICAgICAgICBjb25uZWN0aW9uTW9kZTogQ29ubmVjdGlvbk1vZGUuU3RyaWN0LFxuICAgICAgICBkb21Ob2RlOiBudWxsLFxuICAgICAgICBwYW5lRHJhZ2dpbmc6IGZhbHNlLFxuICAgICAgICBub1BhbkNsYXNzTmFtZTogJ25vcGFuJyxcbiAgICAgICAgbm9kZU9yaWdpbjogc3RvcmVOb2RlT3JpZ2luLFxuICAgICAgICBub2RlRHJhZ1RocmVzaG9sZDogMSxcbiAgICAgICAgc25hcEdyaWQ6IFsxNSwgMTVdLFxuICAgICAgICBzbmFwVG9HcmlkOiBmYWxzZSxcbiAgICAgICAgbm9kZXNEcmFnZ2FibGU6IHRydWUsXG4gICAgICAgIG5vZGVzQ29ubmVjdGFibGU6IHRydWUsXG4gICAgICAgIG5vZGVzRm9jdXNhYmxlOiB0cnVlLFxuICAgICAgICBlZGdlc0ZvY3VzYWJsZTogdHJ1ZSxcbiAgICAgICAgZWRnZXNSZWNvbm5lY3RhYmxlOiB0cnVlLFxuICAgICAgICBlbGVtZW50c1NlbGVjdGFibGU6IHRydWUsXG4gICAgICAgIGVsZXZhdGVOb2Rlc09uU2VsZWN0OiB0cnVlLFxuICAgICAgICBlbGV2YXRlRWRnZXNPblNlbGVjdDogZmFsc2UsXG4gICAgICAgIHNlbGVjdE5vZGVzT25EcmFnOiB0cnVlLFxuICAgICAgICBtdWx0aVNlbGVjdGlvbkFjdGl2ZTogZmFsc2UsXG4gICAgICAgIGZpdFZpZXdRdWV1ZWQ6IGZpdFZpZXcgPz8gZmFsc2UsXG4gICAgICAgIGZpdFZpZXdPcHRpb25zLFxuICAgICAgICBmaXRWaWV3UmVzb2x2ZXI6IG51bGwsXG4gICAgICAgIGNvbm5lY3Rpb246IHsgLi4uaW5pdGlhbENvbm5lY3Rpb24gfSxcbiAgICAgICAgY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGU6IG51bGwsXG4gICAgICAgIGNvbm5lY3RPbkNsaWNrOiB0cnVlLFxuICAgICAgICBhcmlhTGl2ZU1lc3NhZ2U6ICcnLFxuICAgICAgICBhdXRvUGFuT25Db25uZWN0OiB0cnVlLFxuICAgICAgICBhdXRvUGFuT25Ob2RlRHJhZzogdHJ1ZSxcbiAgICAgICAgYXV0b1Bhbk9uTm9kZUZvY3VzOiB0cnVlLFxuICAgICAgICBhdXRvUGFuU3BlZWQ6IDE1LFxuICAgICAgICBjb25uZWN0aW9uUmFkaXVzOiAyMCxcbiAgICAgICAgb25FcnJvcjogZGV2V2FybixcbiAgICAgICAgaXNWYWxpZENvbm5lY3Rpb246IHVuZGVmaW5lZCxcbiAgICAgICAgb25TZWxlY3Rpb25DaGFuZ2VIYW5kbGVyczogW10sXG4gICAgICAgIGxpYjogJ3JlYWN0JyxcbiAgICAgICAgZGVidWc6IGZhbHNlLFxuICAgICAgICBhcmlhTGFiZWxDb25maWc6IGRlZmF1bHRBcmlhTGFiZWxDb25maWcsXG4gICAgfTtcbn07XG5cbmNvbnN0IGNyZWF0ZVN0b3JlID0gKHsgbm9kZXMsIGVkZ2VzLCBkZWZhdWx0Tm9kZXMsIGRlZmF1bHRFZGdlcywgd2lkdGgsIGhlaWdodCwgZml0VmlldywgZml0Vmlld09wdGlvbnMsIG1pblpvb20sIG1heFpvb20sIG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQsIH0pID0+IGNyZWF0ZVdpdGhFcXVhbGl0eUZuKChzZXQsIGdldCkgPT4ge1xuICAgIGFzeW5jIGZ1bmN0aW9uIHJlc29sdmVGaXRWaWV3KCkge1xuICAgICAgICBjb25zdCB7IG5vZGVMb29rdXAsIHBhblpvb20sIGZpdFZpZXdPcHRpb25zLCBmaXRWaWV3UmVzb2x2ZXIsIHdpZHRoLCBoZWlnaHQsIG1pblpvb20sIG1heFpvb20gfSA9IGdldCgpO1xuICAgICAgICBpZiAoIXBhblpvb20pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBmaXRWaWV3cG9ydCh7XG4gICAgICAgICAgICBub2Rlczogbm9kZUxvb2t1cCxcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgcGFuWm9vbSxcbiAgICAgICAgICAgIG1pblpvb20sXG4gICAgICAgICAgICBtYXhab29tLFxuICAgICAgICB9LCBmaXRWaWV3T3B0aW9ucyk7XG4gICAgICAgIGZpdFZpZXdSZXNvbHZlcj8ucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHdhaXQgZm9yIHRoZSBmaXRWaWV3cG9ydCB0byByZXNvbHZlIGJlZm9yZSBkZWxldGluZyB0aGUgcmVzb2x2ZXIsXG4gICAgICAgICAqIHdlIHdhbnQgdG8gcmV1c2UgdGhlIG9sZCByZXNvbHZlciBpZiB0aGUgdXNlciBjYWxscyBmaXRWaWV3IGFnYWluIGluIHRoZSBtZWFuIHRpbWVcbiAgICAgICAgICovXG4gICAgICAgIHNldCh7IGZpdFZpZXdSZXNvbHZlcjogbnVsbCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZ2V0SW5pdGlhbFN0YXRlKHtcbiAgICAgICAgICAgIG5vZGVzLFxuICAgICAgICAgICAgZWRnZXMsXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgIGZpdFZpZXcsXG4gICAgICAgICAgICBmaXRWaWV3T3B0aW9ucyxcbiAgICAgICAgICAgIG1pblpvb20sXG4gICAgICAgICAgICBtYXhab29tLFxuICAgICAgICAgICAgbm9kZU9yaWdpbixcbiAgICAgICAgICAgIG5vZGVFeHRlbnQsXG4gICAgICAgICAgICBkZWZhdWx0Tm9kZXMsXG4gICAgICAgICAgICBkZWZhdWx0RWRnZXMsXG4gICAgICAgIH0pLFxuICAgICAgICBzZXROb2RlczogKG5vZGVzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgbm9kZU9yaWdpbiwgZWxldmF0ZU5vZGVzT25TZWxlY3QsIGZpdFZpZXdRdWV1ZWQgfSA9IGdldCgpO1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIHNldE5vZGVzKCkgaXMgY2FsbGVkIGV4Y2x1c2l2ZWx5IGluIHJlc3BvbnNlIHRvIHVzZXIgYWN0aW9uczpcbiAgICAgICAgICAgICAqIC0gZWl0aGVyIHdoZW4gdGhlIGA8UmVhY3RGbG93IG5vZGVzPmAgcHJvcCBpcyB1cGRhdGVkIGluIHRoZSBjb250cm9sbGVkIFJlYWN0RmxvdyBzZXR1cCxcbiAgICAgICAgICAgICAqIC0gb3Igd2hlbiB0aGUgdXNlciBjYWxscyBzb21ldGhpbmcgbGlrZSBgcmVhY3RGbG93SW5zdGFuY2Uuc2V0Tm9kZXMoKWAgaW4gYW4gdW5jb250cm9sbGVkIFJlYWN0RmxvdyBzZXR1cC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBXaGVuIHRoaXMgaGFwcGVucywgd2UgdGFrZSB0aGUgbm90ZSBvYmplY3RzIHBhc3NlZCBieSB0aGUgdXNlciBhbmQgZXh0ZW5kIHRoZW0gd2l0aCBmaWVsZHNcbiAgICAgICAgICAgICAqIHJlbGV2YW50IGZvciBpbnRlcm5hbCBSZWFjdCBGbG93IG9wZXJhdGlvbnMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IG5vZGVzSW5pdGlhbGl6ZWQgPSBhZG9wdFVzZXJOb2Rlcyhub2Rlcywgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCB7XG4gICAgICAgICAgICAgICAgbm9kZU9yaWdpbixcbiAgICAgICAgICAgICAgICBub2RlRXh0ZW50LFxuICAgICAgICAgICAgICAgIGVsZXZhdGVOb2Rlc09uU2VsZWN0LFxuICAgICAgICAgICAgICAgIGNoZWNrRXF1YWxpdHk6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChmaXRWaWV3UXVldWVkICYmIG5vZGVzSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlRml0VmlldygpO1xuICAgICAgICAgICAgICAgIHNldCh7IG5vZGVzLCBub2Rlc0luaXRpYWxpemVkLCBmaXRWaWV3UXVldWVkOiBmYWxzZSwgZml0Vmlld09wdGlvbnM6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldCh7IG5vZGVzLCBub2Rlc0luaXRpYWxpemVkIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZXRFZGdlczogKGVkZ2VzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGNvbm5lY3Rpb25Mb29rdXAsIGVkZ2VMb29rdXAgfSA9IGdldCgpO1xuICAgICAgICAgICAgdXBkYXRlQ29ubmVjdGlvbkxvb2t1cChjb25uZWN0aW9uTG9va3VwLCBlZGdlTG9va3VwLCBlZGdlcyk7XG4gICAgICAgICAgICBzZXQoeyBlZGdlcyB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0RGVmYXVsdE5vZGVzQW5kRWRnZXM6IChub2RlcywgZWRnZXMpID0+IHtcbiAgICAgICAgICAgIGlmIChub2Rlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2V0Tm9kZXMgfSA9IGdldCgpO1xuICAgICAgICAgICAgICAgIHNldE5vZGVzKG5vZGVzKTtcbiAgICAgICAgICAgICAgICBzZXQoeyBoYXNEZWZhdWx0Tm9kZXM6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZWRnZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHNldEVkZ2VzIH0gPSBnZXQoKTtcbiAgICAgICAgICAgICAgICBzZXRFZGdlcyhlZGdlcyk7XG4gICAgICAgICAgICAgICAgc2V0KHsgaGFzRGVmYXVsdEVkZ2VzOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKlxuICAgICAgICAgKiBFdmVyeSBub2RlIGdldHMgcmVnaXN0ZXJkIGF0IGEgUmVzaXplT2JzZXJ2ZXIuIFdoZW5ldmVyIGEgbm9kZVxuICAgICAgICAgKiBjaGFuZ2VzIGl0cyBkaW1lbnNpb25zLCB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB0byBtZWFzdXJlIHRoZVxuICAgICAgICAgKiBuZXcgZGltZW5zaW9ucyBhbmQgdXBkYXRlIHRoZSBub2Rlcy5cbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZU5vZGVJbnRlcm5hbHM6ICh1cGRhdGVzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHRyaWdnZXJOb2RlQ2hhbmdlcywgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCBkb21Ob2RlLCBub2RlT3JpZ2luLCBub2RlRXh0ZW50LCBkZWJ1ZywgZml0Vmlld1F1ZXVlZCB9ID0gZ2V0KCk7XG4gICAgICAgICAgICBjb25zdCB7IGNoYW5nZXMsIHVwZGF0ZWRJbnRlcm5hbHMgfSA9IHVwZGF0ZU5vZGVJbnRlcm5hbHModXBkYXRlcywgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCBkb21Ob2RlLCBub2RlT3JpZ2luLCBub2RlRXh0ZW50KTtcbiAgICAgICAgICAgIGlmICghdXBkYXRlZEludGVybmFscykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZUFic29sdXRlUG9zaXRpb25zKG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgeyBub2RlT3JpZ2luLCBub2RlRXh0ZW50IH0pO1xuICAgICAgICAgICAgaWYgKGZpdFZpZXdRdWV1ZWQpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlRml0VmlldygpO1xuICAgICAgICAgICAgICAgIHNldCh7IGZpdFZpZXdRdWV1ZWQ6IGZhbHNlLCBmaXRWaWV3T3B0aW9uczogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgYWx3YXlzIHdhbnQgdG8gdHJpZ2dlciB1c2VTdG9yZSBjYWxscyB3aGVuZXZlciB1cGRhdGVOb2RlSW50ZXJuYWxzIGlzIGNhbGxlZFxuICAgICAgICAgICAgICAgIHNldCh7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hhbmdlcz8ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUmVhY3QgRmxvdzogdHJpZ2dlciBub2RlIGNoYW5nZXMnLCBjaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJpZ2dlck5vZGVDaGFuZ2VzPy4oY2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZU5vZGVQb3NpdGlvbnM6IChub2RlRHJhZ0l0ZW1zLCBkcmFnZ2luZyA9IGZhbHNlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRFeHBhbmRDaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgeyBub2RlTG9va3VwLCB0cmlnZ2VyTm9kZUNoYW5nZXMgfSA9IGdldCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbaWQsIGRyYWdJdGVtXSBvZiBub2RlRHJhZ0l0ZW1zKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgYXJlIHVzaW5nIHRoZSBub2RlbG9va3VwIHRvIGJlIHN1cmUgdG8gdXNlIHRoZSBjdXJyZW50IGV4cGFuZFBhcmVudCBhbmQgcGFyZW50SWQgdmFsdWVcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gbm9kZUxvb2t1cC5nZXQoaWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4cGFuZFBhcmVudCA9ICEhKG5vZGU/LmV4cGFuZFBhcmVudCAmJiBub2RlPy5wYXJlbnRJZCAmJiBkcmFnSXRlbT8ucG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5nZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdwb3NpdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBleHBhbmRQYXJlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IE1hdGgubWF4KDAsIGRyYWdJdGVtLnBvc2l0aW9uLngpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IE1hdGgubWF4KDAsIGRyYWdJdGVtLnBvc2l0aW9uLnkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBkcmFnSXRlbS5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgZHJhZ2dpbmcsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoZXhwYW5kUGFyZW50ICYmIG5vZGUucGFyZW50SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50RXhwYW5kQ2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudElkOiBub2RlLnBhcmVudElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmRyYWdJdGVtLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBkcmFnSXRlbS5tZWFzdXJlZC53aWR0aCA/PyAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogZHJhZ0l0ZW0ubWVhc3VyZWQuaGVpZ2h0ID8/IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKGNoYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyZW50RXhwYW5kQ2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGFyZW50TG9va3VwLCBub2RlT3JpZ2luIH0gPSBnZXQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRFeHBhbmRDaGFuZ2VzID0gaGFuZGxlRXhwYW5kUGFyZW50KHBhcmVudEV4cGFuZENoaWxkcmVuLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIG5vZGVPcmlnaW4pO1xuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCguLi5wYXJlbnRFeHBhbmRDaGFuZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyaWdnZXJOb2RlQ2hhbmdlcyhjaGFuZ2VzKTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJpZ2dlck5vZGVDaGFuZ2VzOiAoY2hhbmdlcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBvbk5vZGVzQ2hhbmdlLCBzZXROb2Rlcywgbm9kZXMsIGhhc0RlZmF1bHROb2RlcywgZGVidWcgfSA9IGdldCgpO1xuICAgICAgICAgICAgaWYgKGNoYW5nZXM/Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChoYXNEZWZhdWx0Tm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZE5vZGVzID0gYXBwbHlOb2RlQ2hhbmdlcyhjaGFuZ2VzLCBub2Rlcyk7XG4gICAgICAgICAgICAgICAgICAgIHNldE5vZGVzKHVwZGF0ZWROb2Rlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUmVhY3QgRmxvdzogdHJpZ2dlciBub2RlIGNoYW5nZXMnLCBjaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb25Ob2Rlc0NoYW5nZT8uKGNoYW5nZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0cmlnZ2VyRWRnZUNoYW5nZXM6IChjaGFuZ2VzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG9uRWRnZXNDaGFuZ2UsIHNldEVkZ2VzLCBlZGdlcywgaGFzRGVmYXVsdEVkZ2VzLCBkZWJ1ZyB9ID0gZ2V0KCk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlcz8ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0RlZmF1bHRFZGdlcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkRWRnZXMgPSBhcHBseUVkZ2VDaGFuZ2VzKGNoYW5nZXMsIGVkZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0RWRnZXModXBkYXRlZEVkZ2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZWFjdCBGbG93OiB0cmlnZ2VyIGVkZ2UgY2hhbmdlcycsIGNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvbkVkZ2VzQ2hhbmdlPy4oY2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFkZFNlbGVjdGVkTm9kZXM6IChzZWxlY3RlZE5vZGVJZHMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgbXVsdGlTZWxlY3Rpb25BY3RpdmUsIGVkZ2VMb29rdXAsIG5vZGVMb29rdXAsIHRyaWdnZXJOb2RlQ2hhbmdlcywgdHJpZ2dlckVkZ2VDaGFuZ2VzIH0gPSBnZXQoKTtcbiAgICAgICAgICAgIGlmIChtdWx0aVNlbGVjdGlvbkFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVDaGFuZ2VzID0gc2VsZWN0ZWROb2RlSWRzLm1hcCgobm9kZUlkKSA9PiBjcmVhdGVTZWxlY3Rpb25DaGFuZ2Uobm9kZUlkLCB0cnVlKSk7XG4gICAgICAgICAgICAgICAgdHJpZ2dlck5vZGVDaGFuZ2VzKG5vZGVDaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXMoZ2V0U2VsZWN0aW9uQ2hhbmdlcyhub2RlTG9va3VwLCBuZXcgU2V0KFsuLi5zZWxlY3RlZE5vZGVJZHNdKSwgdHJ1ZSkpO1xuICAgICAgICAgICAgdHJpZ2dlckVkZ2VDaGFuZ2VzKGdldFNlbGVjdGlvbkNoYW5nZXMoZWRnZUxvb2t1cCkpO1xuICAgICAgICB9LFxuICAgICAgICBhZGRTZWxlY3RlZEVkZ2VzOiAoc2VsZWN0ZWRFZGdlSWRzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG11bHRpU2VsZWN0aW9uQWN0aXZlLCBlZGdlTG9va3VwLCBub2RlTG9va3VwLCB0cmlnZ2VyTm9kZUNoYW5nZXMsIHRyaWdnZXJFZGdlQ2hhbmdlcyB9ID0gZ2V0KCk7XG4gICAgICAgICAgICBpZiAobXVsdGlTZWxlY3Rpb25BY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFuZ2VkRWRnZXMgPSBzZWxlY3RlZEVkZ2VJZHMubWFwKChlZGdlSWQpID0+IGNyZWF0ZVNlbGVjdGlvbkNoYW5nZShlZGdlSWQsIHRydWUpKTtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRWRnZUNoYW5nZXMoY2hhbmdlZEVkZ2VzKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmlnZ2VyRWRnZUNoYW5nZXMoZ2V0U2VsZWN0aW9uQ2hhbmdlcyhlZGdlTG9va3VwLCBuZXcgU2V0KFsuLi5zZWxlY3RlZEVkZ2VJZHNdKSkpO1xuICAgICAgICAgICAgdHJpZ2dlck5vZGVDaGFuZ2VzKGdldFNlbGVjdGlvbkNoYW5nZXMobm9kZUxvb2t1cCwgbmV3IFNldCgpLCB0cnVlKSk7XG4gICAgICAgIH0sXG4gICAgICAgIHVuc2VsZWN0Tm9kZXNBbmRFZGdlczogKHsgbm9kZXMsIGVkZ2VzIH0gPSB7fSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBlZGdlczogc3RvcmVFZGdlcywgbm9kZXM6IHN0b3JlTm9kZXMsIG5vZGVMb29rdXAsIHRyaWdnZXJOb2RlQ2hhbmdlcywgdHJpZ2dlckVkZ2VDaGFuZ2VzIH0gPSBnZXQoKTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVzVG9VbnNlbGVjdCA9IG5vZGVzID8gbm9kZXMgOiBzdG9yZU5vZGVzO1xuICAgICAgICAgICAgY29uc3QgZWRnZXNUb1Vuc2VsZWN0ID0gZWRnZXMgPyBlZGdlcyA6IHN0b3JlRWRnZXM7XG4gICAgICAgICAgICBjb25zdCBub2RlQ2hhbmdlcyA9IG5vZGVzVG9VbnNlbGVjdC5tYXAoKG4pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnRlcm5hbE5vZGUgPSBub2RlTG9va3VwLmdldChuLmlkKTtcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJuYWxOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAqIHdlIG5lZWQgdG8gdW5zZWxlY3QgdGhlIGludGVybmFsIG5vZGUgdGhhdCB3YXMgc2VsZWN0ZWQgcHJldmlvdXNseSBiZWZvcmUgd2VcbiAgICAgICAgICAgICAgICAgICAgICogc2VuZCB0aGUgY2hhbmdlIHRvIHRoZSB1c2VyIHRvIHByZXZlbnQgaXQgdG8gYmUgc2VsZWN0ZWQgd2hpbGUgZHJhZ2dpbmcgdGhlIG5ldyBub2RlXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbE5vZGUuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVNlbGVjdGlvbkNoYW5nZShuLmlkLCBmYWxzZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGVkZ2VDaGFuZ2VzID0gZWRnZXNUb1Vuc2VsZWN0Lm1hcCgoZWRnZSkgPT4gY3JlYXRlU2VsZWN0aW9uQ2hhbmdlKGVkZ2UuaWQsIGZhbHNlKSk7XG4gICAgICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXMobm9kZUNoYW5nZXMpO1xuICAgICAgICAgICAgdHJpZ2dlckVkZ2VDaGFuZ2VzKGVkZ2VDaGFuZ2VzKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0TWluWm9vbTogKG1pblpvb20pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgcGFuWm9vbSwgbWF4Wm9vbSB9ID0gZ2V0KCk7XG4gICAgICAgICAgICBwYW5ab29tPy5zZXRTY2FsZUV4dGVudChbbWluWm9vbSwgbWF4Wm9vbV0pO1xuICAgICAgICAgICAgc2V0KHsgbWluWm9vbSB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0TWF4Wm9vbTogKG1heFpvb20pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgcGFuWm9vbSwgbWluWm9vbSB9ID0gZ2V0KCk7XG4gICAgICAgICAgICBwYW5ab29tPy5zZXRTY2FsZUV4dGVudChbbWluWm9vbSwgbWF4Wm9vbV0pO1xuICAgICAgICAgICAgc2V0KHsgbWF4Wm9vbSB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0VHJhbnNsYXRlRXh0ZW50OiAodHJhbnNsYXRlRXh0ZW50KSA9PiB7XG4gICAgICAgICAgICBnZXQoKS5wYW5ab29tPy5zZXRUcmFuc2xhdGVFeHRlbnQodHJhbnNsYXRlRXh0ZW50KTtcbiAgICAgICAgICAgIHNldCh7IHRyYW5zbGF0ZUV4dGVudCB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0UGFuZUNsaWNrRGlzdGFuY2U6IChjbGlja0Rpc3RhbmNlKSA9PiB7XG4gICAgICAgICAgICBnZXQoKS5wYW5ab29tPy5zZXRDbGlja0Rpc3RhbmNlKGNsaWNrRGlzdGFuY2UpO1xuICAgICAgICB9LFxuICAgICAgICByZXNldFNlbGVjdGVkRWxlbWVudHM6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZWRnZXMsIG5vZGVzLCB0cmlnZ2VyTm9kZUNoYW5nZXMsIHRyaWdnZXJFZGdlQ2hhbmdlcywgZWxlbWVudHNTZWxlY3RhYmxlIH0gPSBnZXQoKTtcbiAgICAgICAgICAgIGlmICghZWxlbWVudHNTZWxlY3RhYmxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgbm9kZUNoYW5nZXMgPSBub2Rlcy5yZWR1Y2UoKHJlcywgbm9kZSkgPT4gKG5vZGUuc2VsZWN0ZWQgPyBbLi4ucmVzLCBjcmVhdGVTZWxlY3Rpb25DaGFuZ2Uobm9kZS5pZCwgZmFsc2UpXSA6IHJlcyksIFtdKTtcbiAgICAgICAgICAgIGNvbnN0IGVkZ2VDaGFuZ2VzID0gZWRnZXMucmVkdWNlKChyZXMsIGVkZ2UpID0+IChlZGdlLnNlbGVjdGVkID8gWy4uLnJlcywgY3JlYXRlU2VsZWN0aW9uQ2hhbmdlKGVkZ2UuaWQsIGZhbHNlKV0gOiByZXMpLCBbXSk7XG4gICAgICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXMobm9kZUNoYW5nZXMpO1xuICAgICAgICAgICAgdHJpZ2dlckVkZ2VDaGFuZ2VzKGVkZ2VDaGFuZ2VzKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0Tm9kZUV4dGVudDogKG5leHROb2RlRXh0ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG5vZGVzLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIG5vZGVPcmlnaW4sIGVsZXZhdGVOb2Rlc09uU2VsZWN0LCBub2RlRXh0ZW50IH0gPSBnZXQoKTtcbiAgICAgICAgICAgIGlmIChuZXh0Tm9kZUV4dGVudFswXVswXSA9PT0gbm9kZUV4dGVudFswXVswXSAmJlxuICAgICAgICAgICAgICAgIG5leHROb2RlRXh0ZW50WzBdWzFdID09PSBub2RlRXh0ZW50WzBdWzFdICYmXG4gICAgICAgICAgICAgICAgbmV4dE5vZGVFeHRlbnRbMV1bMF0gPT09IG5vZGVFeHRlbnRbMV1bMF0gJiZcbiAgICAgICAgICAgICAgICBuZXh0Tm9kZUV4dGVudFsxXVsxXSA9PT0gbm9kZUV4dGVudFsxXVsxXSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkb3B0VXNlck5vZGVzKG5vZGVzLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIHtcbiAgICAgICAgICAgICAgICBub2RlT3JpZ2luLFxuICAgICAgICAgICAgICAgIG5vZGVFeHRlbnQ6IG5leHROb2RlRXh0ZW50LFxuICAgICAgICAgICAgICAgIGVsZXZhdGVOb2Rlc09uU2VsZWN0LFxuICAgICAgICAgICAgICAgIGNoZWNrRXF1YWxpdHk6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXQoeyBub2RlRXh0ZW50OiBuZXh0Tm9kZUV4dGVudCB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgcGFuQnk6IChkZWx0YSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyB0cmFuc2Zvcm0sIHdpZHRoLCBoZWlnaHQsIHBhblpvb20sIHRyYW5zbGF0ZUV4dGVudCB9ID0gZ2V0KCk7XG4gICAgICAgICAgICByZXR1cm4gcGFuQnkoeyBkZWx0YSwgcGFuWm9vbSwgdHJhbnNmb3JtLCB0cmFuc2xhdGVFeHRlbnQsIHdpZHRoLCBoZWlnaHQgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldENlbnRlcjogYXN5bmMgKHgsIHksIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgbWF4Wm9vbSwgcGFuWm9vbSB9ID0gZ2V0KCk7XG4gICAgICAgICAgICBpZiAoIXBhblpvb20pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5leHRab29tID0gdHlwZW9mIG9wdGlvbnM/Lnpvb20gIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy56b29tIDogbWF4Wm9vbTtcbiAgICAgICAgICAgIGF3YWl0IHBhblpvb20uc2V0Vmlld3BvcnQoe1xuICAgICAgICAgICAgICAgIHg6IHdpZHRoIC8gMiAtIHggKiBuZXh0Wm9vbSxcbiAgICAgICAgICAgICAgICB5OiBoZWlnaHQgLyAyIC0geSAqIG5leHRab29tLFxuICAgICAgICAgICAgICAgIHpvb206IG5leHRab29tLFxuICAgICAgICAgICAgfSwgeyBkdXJhdGlvbjogb3B0aW9ucz8uZHVyYXRpb24sIGVhc2U6IG9wdGlvbnM/LmVhc2UsIGludGVycG9sYXRlOiBvcHRpb25zPy5pbnRlcnBvbGF0ZSB9KTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNhbmNlbENvbm5lY3Rpb246ICgpID0+IHtcbiAgICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbjogeyAuLi5pbml0aWFsQ29ubmVjdGlvbiB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZUNvbm5lY3Rpb246IChjb25uZWN0aW9uKSA9PiB7XG4gICAgICAgICAgICBzZXQoeyBjb25uZWN0aW9uIH0pO1xuICAgICAgICB9LFxuICAgICAgICByZXNldDogKCkgPT4gc2V0KHsgLi4uZ2V0SW5pdGlhbFN0YXRlKCkgfSksXG4gICAgfTtcbn0sIE9iamVjdC5pcyk7XG5cbi8qKlxuICogVGhlIGA8UmVhY3RGbG93UHJvdmlkZXIgLz5gIGNvbXBvbmVudCBpcyBhIFtjb250ZXh0IHByb3ZpZGVyXShodHRwczovL3JlYWN0LmRldi9sZWFybi9wYXNzaW5nLWRhdGEtZGVlcGx5LXdpdGgtY29udGV4dCMpXG4gKiB0aGF0IG1ha2VzIGl0IHBvc3NpYmxlIHRvIGFjY2VzcyBhIGZsb3cncyBpbnRlcm5hbCBzdGF0ZSBvdXRzaWRlIG9mIHRoZVxuICogW2A8UmVhY3RGbG93IC8+YF0oL2FwaS1yZWZlcmVuY2UvcmVhY3QtZmxvdykgY29tcG9uZW50LiBNYW55IG9mIHRoZSBob29rcyB3ZVxuICogcHJvdmlkZSByZWx5IG9uIHRoaXMgY29tcG9uZW50IHRvIHdvcmsuXG4gKiBAcHVibGljXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICppbXBvcnQgeyBSZWFjdEZsb3csIFJlYWN0Rmxvd1Byb3ZpZGVyLCB1c2VOb2RlcyB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnXG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGbG93KCkge1xuICogIHJldHVybiAoXG4gKiAgICA8UmVhY3RGbG93UHJvdmlkZXI+XG4gKiAgICAgIDxSZWFjdEZsb3cgbm9kZXM9ey4uLn0gZWRnZXM9ey4uLn0gLz5cbiAqICAgICAgPFNpZGViYXIgLz5cbiAqICAgIDwvUmVhY3RGbG93UHJvdmlkZXI+XG4gKiAgKTtcbiAqfVxuICpcbiAqZnVuY3Rpb24gU2lkZWJhcigpIHtcbiAqICAvLyBUaGlzIGhvb2sgd2lsbCBvbmx5IHdvcmsgaWYgdGhlIGNvbXBvbmVudCBpdCdzIHVzZWQgaW4gaXMgYSBjaGlsZCBvZiBhXG4gKiAgLy8gPFJlYWN0Rmxvd1Byb3ZpZGVyIC8+LlxuICogIGNvbnN0IG5vZGVzID0gdXNlTm9kZXMoKVxuICpcbiAqICByZXR1cm4gPGFzaWRlPmRvIHNvbWV0aGluZyB3aXRoIG5vZGVzPC9hc2lkZT47XG4gKn1cbiAqYGBgXG4gKlxuICogQHJlbWFya3MgSWYgeW91J3JlIHVzaW5nIGEgcm91dGVyIGFuZCB3YW50IHlvdXIgZmxvdydzIHN0YXRlIHRvIHBlcnNpc3QgYWNyb3NzIHJvdXRlcyxcbiAqIGl0J3Mgdml0YWwgdGhhdCB5b3UgcGxhY2UgdGhlIGA8UmVhY3RGbG93UHJvdmlkZXIgLz5gIGNvbXBvbmVudCBfb3V0c2lkZV8gb2ZcbiAqIHlvdXIgcm91dGVyLiBJZiB5b3UgaGF2ZSBtdWx0aXBsZSBmbG93cyBvbiB0aGUgc2FtZSBwYWdlIHlvdSB3aWxsIG5lZWQgdG8gdXNlIGEgc2VwYXJhdGVcbiAqIGA8UmVhY3RGbG93UHJvdmlkZXIgLz5gIGZvciBlYWNoIGZsb3cuXG4gKi9cbmZ1bmN0aW9uIFJlYWN0Rmxvd1Byb3ZpZGVyKHsgaW5pdGlhbE5vZGVzOiBub2RlcywgaW5pdGlhbEVkZ2VzOiBlZGdlcywgZGVmYXVsdE5vZGVzLCBkZWZhdWx0RWRnZXMsIGluaXRpYWxXaWR0aDogd2lkdGgsIGluaXRpYWxIZWlnaHQ6IGhlaWdodCwgaW5pdGlhbE1pblpvb206IG1pblpvb20sIGluaXRpYWxNYXhab29tOiBtYXhab29tLCBpbml0aWFsRml0Vmlld09wdGlvbnM6IGZpdFZpZXdPcHRpb25zLCBmaXRWaWV3LCBub2RlT3JpZ2luLCBub2RlRXh0ZW50LCBjaGlsZHJlbiwgfSkge1xuICAgIGNvbnN0IFtzdG9yZV0gPSB1c2VTdGF0ZSgoKSA9PiBjcmVhdGVTdG9yZSh7XG4gICAgICAgIG5vZGVzLFxuICAgICAgICBlZGdlcyxcbiAgICAgICAgZGVmYXVsdE5vZGVzLFxuICAgICAgICBkZWZhdWx0RWRnZXMsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIGZpdFZpZXcsXG4gICAgICAgIG1pblpvb20sXG4gICAgICAgIG1heFpvb20sXG4gICAgICAgIGZpdFZpZXdPcHRpb25zLFxuICAgICAgICBub2RlT3JpZ2luLFxuICAgICAgICBub2RlRXh0ZW50LFxuICAgIH0pKTtcbiAgICByZXR1cm4gKGpzeChQcm92aWRlciQxLCB7IHZhbHVlOiBzdG9yZSwgY2hpbGRyZW46IGpzeChCYXRjaFByb3ZpZGVyLCB7IGNoaWxkcmVuOiBjaGlsZHJlbiB9KSB9KSk7XG59XG5cbmZ1bmN0aW9uIFdyYXBwZXIoeyBjaGlsZHJlbiwgbm9kZXMsIGVkZ2VzLCBkZWZhdWx0Tm9kZXMsIGRlZmF1bHRFZGdlcywgd2lkdGgsIGhlaWdodCwgZml0VmlldywgZml0Vmlld09wdGlvbnMsIG1pblpvb20sIG1heFpvb20sIG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQsIH0pIHtcbiAgICBjb25zdCBpc1dyYXBwZWQgPSB1c2VDb250ZXh0KFN0b3JlQ29udGV4dCk7XG4gICAgaWYgKGlzV3JhcHBlZCkge1xuICAgICAgICAvKlxuICAgICAgICAgKiB3ZSBuZWVkIHRvIHdyYXAgaXQgd2l0aCBhIGZyYWdtZW50IGJlY2F1c2UgaXQncyBub3QgYWxsb3dlZCBmb3IgY2hpbGRyZW4gdG8gYmUgYSBSZWFjdE5vZGVcbiAgICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL0RlZmluaXRlbHlUeXBlZC9EZWZpbml0ZWx5VHlwZWQvaXNzdWVzLzE4MDUxXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4ganN4KEZyYWdtZW50LCB7IGNoaWxkcmVuOiBjaGlsZHJlbiB9KTtcbiAgICB9XG4gICAgcmV0dXJuIChqc3goUmVhY3RGbG93UHJvdmlkZXIsIHsgaW5pdGlhbE5vZGVzOiBub2RlcywgaW5pdGlhbEVkZ2VzOiBlZGdlcywgZGVmYXVsdE5vZGVzOiBkZWZhdWx0Tm9kZXMsIGRlZmF1bHRFZGdlczogZGVmYXVsdEVkZ2VzLCBpbml0aWFsV2lkdGg6IHdpZHRoLCBpbml0aWFsSGVpZ2h0OiBoZWlnaHQsIGZpdFZpZXc6IGZpdFZpZXcsIGluaXRpYWxGaXRWaWV3T3B0aW9uczogZml0Vmlld09wdGlvbnMsIGluaXRpYWxNaW5ab29tOiBtaW5ab29tLCBpbml0aWFsTWF4Wm9vbTogbWF4Wm9vbSwgbm9kZU9yaWdpbjogbm9kZU9yaWdpbiwgbm9kZUV4dGVudDogbm9kZUV4dGVudCwgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbn1cblxuY29uc3Qgd3JhcHBlclN0eWxlID0ge1xuICAgIHdpZHRoOiAnMTAwJScsXG4gICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgIHpJbmRleDogMCxcbn07XG5mdW5jdGlvbiBSZWFjdEZsb3coeyBub2RlcywgZWRnZXMsIGRlZmF1bHROb2RlcywgZGVmYXVsdEVkZ2VzLCBjbGFzc05hbWUsIG5vZGVUeXBlcywgZWRnZVR5cGVzLCBvbk5vZGVDbGljaywgb25FZGdlQ2xpY2ssIG9uSW5pdCwgb25Nb3ZlLCBvbk1vdmVTdGFydCwgb25Nb3ZlRW5kLCBvbkNvbm5lY3QsIG9uQ29ubmVjdFN0YXJ0LCBvbkNvbm5lY3RFbmQsIG9uQ2xpY2tDb25uZWN0U3RhcnQsIG9uQ2xpY2tDb25uZWN0RW5kLCBvbk5vZGVNb3VzZUVudGVyLCBvbk5vZGVNb3VzZU1vdmUsIG9uTm9kZU1vdXNlTGVhdmUsIG9uTm9kZUNvbnRleHRNZW51LCBvbk5vZGVEb3VibGVDbGljaywgb25Ob2RlRHJhZ1N0YXJ0LCBvbk5vZGVEcmFnLCBvbk5vZGVEcmFnU3RvcCwgb25Ob2Rlc0RlbGV0ZSwgb25FZGdlc0RlbGV0ZSwgb25EZWxldGUsIG9uU2VsZWN0aW9uQ2hhbmdlLCBvblNlbGVjdGlvbkRyYWdTdGFydCwgb25TZWxlY3Rpb25EcmFnLCBvblNlbGVjdGlvbkRyYWdTdG9wLCBvblNlbGVjdGlvbkNvbnRleHRNZW51LCBvblNlbGVjdGlvblN0YXJ0LCBvblNlbGVjdGlvbkVuZCwgb25CZWZvcmVEZWxldGUsIGNvbm5lY3Rpb25Nb2RlLCBjb25uZWN0aW9uTGluZVR5cGUgPSBDb25uZWN0aW9uTGluZVR5cGUuQmV6aWVyLCBjb25uZWN0aW9uTGluZVN0eWxlLCBjb25uZWN0aW9uTGluZUNvbXBvbmVudCwgY29ubmVjdGlvbkxpbmVDb250YWluZXJTdHlsZSwgZGVsZXRlS2V5Q29kZSA9ICdCYWNrc3BhY2UnLCBzZWxlY3Rpb25LZXlDb2RlID0gJ1NoaWZ0Jywgc2VsZWN0aW9uT25EcmFnID0gZmFsc2UsIHNlbGVjdGlvbk1vZGUgPSBTZWxlY3Rpb25Nb2RlLkZ1bGwsIHBhbkFjdGl2YXRpb25LZXlDb2RlID0gJ1NwYWNlJywgbXVsdGlTZWxlY3Rpb25LZXlDb2RlID0gaXNNYWNPcygpID8gJ01ldGEnIDogJ0NvbnRyb2wnLCB6b29tQWN0aXZhdGlvbktleUNvZGUgPSBpc01hY09zKCkgPyAnTWV0YScgOiAnQ29udHJvbCcsIHNuYXBUb0dyaWQsIHNuYXBHcmlkLCBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzID0gZmFsc2UsIHNlbGVjdE5vZGVzT25EcmFnLCBub2Rlc0RyYWdnYWJsZSwgYXV0b1Bhbk9uTm9kZUZvY3VzLCBub2Rlc0Nvbm5lY3RhYmxlLCBub2Rlc0ZvY3VzYWJsZSwgbm9kZU9yaWdpbiA9IGRlZmF1bHROb2RlT3JpZ2luLCBlZGdlc0ZvY3VzYWJsZSwgZWRnZXNSZWNvbm5lY3RhYmxlLCBlbGVtZW50c1NlbGVjdGFibGUgPSB0cnVlLCBkZWZhdWx0Vmlld3BvcnQ6IGRlZmF1bHRWaWV3cG9ydCQxID0gZGVmYXVsdFZpZXdwb3J0LCBtaW5ab29tID0gMC41LCBtYXhab29tID0gMiwgdHJhbnNsYXRlRXh0ZW50ID0gaW5maW5pdGVFeHRlbnQsIHByZXZlbnRTY3JvbGxpbmcgPSB0cnVlLCBub2RlRXh0ZW50LCBkZWZhdWx0TWFya2VyQ29sb3IgPSAnI2IxYjFiNycsIHpvb21PblNjcm9sbCA9IHRydWUsIHpvb21PblBpbmNoID0gdHJ1ZSwgcGFuT25TY3JvbGwgPSBmYWxzZSwgcGFuT25TY3JvbGxTcGVlZCA9IDAuNSwgcGFuT25TY3JvbGxNb2RlID0gUGFuT25TY3JvbGxNb2RlLkZyZWUsIHpvb21PbkRvdWJsZUNsaWNrID0gdHJ1ZSwgcGFuT25EcmFnID0gdHJ1ZSwgb25QYW5lQ2xpY2ssIG9uUGFuZU1vdXNlRW50ZXIsIG9uUGFuZU1vdXNlTW92ZSwgb25QYW5lTW91c2VMZWF2ZSwgb25QYW5lU2Nyb2xsLCBvblBhbmVDb250ZXh0TWVudSwgcGFuZUNsaWNrRGlzdGFuY2UgPSAwLCBub2RlQ2xpY2tEaXN0YW5jZSA9IDAsIGNoaWxkcmVuLCBvblJlY29ubmVjdCwgb25SZWNvbm5lY3RTdGFydCwgb25SZWNvbm5lY3RFbmQsIG9uRWRnZUNvbnRleHRNZW51LCBvbkVkZ2VEb3VibGVDbGljaywgb25FZGdlTW91c2VFbnRlciwgb25FZGdlTW91c2VNb3ZlLCBvbkVkZ2VNb3VzZUxlYXZlLCByZWNvbm5lY3RSYWRpdXMgPSAxMCwgb25Ob2Rlc0NoYW5nZSwgb25FZGdlc0NoYW5nZSwgbm9EcmFnQ2xhc3NOYW1lID0gJ25vZHJhZycsIG5vV2hlZWxDbGFzc05hbWUgPSAnbm93aGVlbCcsIG5vUGFuQ2xhc3NOYW1lID0gJ25vcGFuJywgZml0VmlldywgZml0Vmlld09wdGlvbnMsIGNvbm5lY3RPbkNsaWNrLCBhdHRyaWJ1dGlvblBvc2l0aW9uLCBwcm9PcHRpb25zLCBkZWZhdWx0RWRnZU9wdGlvbnMsIGVsZXZhdGVOb2Rlc09uU2VsZWN0LCBlbGV2YXRlRWRnZXNPblNlbGVjdCwgZGlzYWJsZUtleWJvYXJkQTExeSA9IGZhbHNlLCBhdXRvUGFuT25Db25uZWN0LCBhdXRvUGFuT25Ob2RlRHJhZywgYXV0b1BhblNwZWVkLCBjb25uZWN0aW9uUmFkaXVzLCBpc1ZhbGlkQ29ubmVjdGlvbiwgb25FcnJvciwgc3R5bGUsIGlkLCBub2RlRHJhZ1RocmVzaG9sZCwgdmlld3BvcnQsIG9uVmlld3BvcnRDaGFuZ2UsIHdpZHRoLCBoZWlnaHQsIGNvbG9yTW9kZSA9ICdsaWdodCcsIGRlYnVnLCBvblNjcm9sbCwgYXJpYUxhYmVsQ29uZmlnLCAuLi5yZXN0IH0sIHJlZikge1xuICAgIGNvbnN0IHJmSWQgPSBpZCB8fCAnMSc7XG4gICAgY29uc3QgY29sb3JNb2RlQ2xhc3NOYW1lID0gdXNlQ29sb3JNb2RlQ2xhc3MoY29sb3JNb2RlKTtcbiAgICAvLyBVbmRvIHNjcm9sbCBldmVudHMsIHByZXZlbnRpbmcgdmlld3BvcnQgZnJvbSBzaGlmdGluZyB3aGVuIG5vZGVzIG91dHNpZGUgb2YgaXQgYXJlIGZvY3VzZWRcbiAgICBjb25zdCB3cmFwcGVyT25TY3JvbGwgPSB1c2VDYWxsYmFjaygoZSkgPT4ge1xuICAgICAgICBlLmN1cnJlbnRUYXJnZXQuc2Nyb2xsVG8oeyB0b3A6IDAsIGxlZnQ6IDAsIGJlaGF2aW9yOiAnaW5zdGFudCcgfSk7XG4gICAgICAgIG9uU2Nyb2xsPy4oZSk7XG4gICAgfSwgW29uU2Nyb2xsXSk7XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBcImRhdGEtdGVzdGlkXCI6IFwicmZfX3dyYXBwZXJcIiwgLi4ucmVzdCwgb25TY3JvbGw6IHdyYXBwZXJPblNjcm9sbCwgc3R5bGU6IHsgLi4uc3R5bGUsIC4uLndyYXBwZXJTdHlsZSB9LCByZWY6IHJlZiwgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3cnLCBjbGFzc05hbWUsIGNvbG9yTW9kZUNsYXNzTmFtZV0pLCBpZDogaWQsIHJvbGU6IFwiYXBwbGljYXRpb25cIiwgY2hpbGRyZW46IGpzeHMoV3JhcHBlciwgeyBub2Rlczogbm9kZXMsIGVkZ2VzOiBlZGdlcywgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCwgZml0VmlldzogZml0VmlldywgZml0Vmlld09wdGlvbnM6IGZpdFZpZXdPcHRpb25zLCBtaW5ab29tOiBtaW5ab29tLCBtYXhab29tOiBtYXhab29tLCBub2RlT3JpZ2luOiBub2RlT3JpZ2luLCBub2RlRXh0ZW50OiBub2RlRXh0ZW50LCBjaGlsZHJlbjogW2pzeChHcmFwaFZpZXcsIHsgb25Jbml0OiBvbkluaXQsIG9uTm9kZUNsaWNrOiBvbk5vZGVDbGljaywgb25FZGdlQ2xpY2s6IG9uRWRnZUNsaWNrLCBvbk5vZGVNb3VzZUVudGVyOiBvbk5vZGVNb3VzZUVudGVyLCBvbk5vZGVNb3VzZU1vdmU6IG9uTm9kZU1vdXNlTW92ZSwgb25Ob2RlTW91c2VMZWF2ZTogb25Ob2RlTW91c2VMZWF2ZSwgb25Ob2RlQ29udGV4dE1lbnU6IG9uTm9kZUNvbnRleHRNZW51LCBvbk5vZGVEb3VibGVDbGljazogb25Ob2RlRG91YmxlQ2xpY2ssIG5vZGVUeXBlczogbm9kZVR5cGVzLCBlZGdlVHlwZXM6IGVkZ2VUeXBlcywgY29ubmVjdGlvbkxpbmVUeXBlOiBjb25uZWN0aW9uTGluZVR5cGUsIGNvbm5lY3Rpb25MaW5lU3R5bGU6IGNvbm5lY3Rpb25MaW5lU3R5bGUsIGNvbm5lY3Rpb25MaW5lQ29tcG9uZW50OiBjb25uZWN0aW9uTGluZUNvbXBvbmVudCwgY29ubmVjdGlvbkxpbmVDb250YWluZXJTdHlsZTogY29ubmVjdGlvbkxpbmVDb250YWluZXJTdHlsZSwgc2VsZWN0aW9uS2V5Q29kZTogc2VsZWN0aW9uS2V5Q29kZSwgc2VsZWN0aW9uT25EcmFnOiBzZWxlY3Rpb25PbkRyYWcsIHNlbGVjdGlvbk1vZGU6IHNlbGVjdGlvbk1vZGUsIGRlbGV0ZUtleUNvZGU6IGRlbGV0ZUtleUNvZGUsIG11bHRpU2VsZWN0aW9uS2V5Q29kZTogbXVsdGlTZWxlY3Rpb25LZXlDb2RlLCBwYW5BY3RpdmF0aW9uS2V5Q29kZTogcGFuQWN0aXZhdGlvbktleUNvZGUsIHpvb21BY3RpdmF0aW9uS2V5Q29kZTogem9vbUFjdGl2YXRpb25LZXlDb2RlLCBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzOiBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzLCBkZWZhdWx0Vmlld3BvcnQ6IGRlZmF1bHRWaWV3cG9ydCQxLCB0cmFuc2xhdGVFeHRlbnQ6IHRyYW5zbGF0ZUV4dGVudCwgbWluWm9vbTogbWluWm9vbSwgbWF4Wm9vbTogbWF4Wm9vbSwgcHJldmVudFNjcm9sbGluZzogcHJldmVudFNjcm9sbGluZywgem9vbU9uU2Nyb2xsOiB6b29tT25TY3JvbGwsIHpvb21PblBpbmNoOiB6b29tT25QaW5jaCwgem9vbU9uRG91YmxlQ2xpY2s6IHpvb21PbkRvdWJsZUNsaWNrLCBwYW5PblNjcm9sbDogcGFuT25TY3JvbGwsIHBhbk9uU2Nyb2xsU3BlZWQ6IHBhbk9uU2Nyb2xsU3BlZWQsIHBhbk9uU2Nyb2xsTW9kZTogcGFuT25TY3JvbGxNb2RlLCBwYW5PbkRyYWc6IHBhbk9uRHJhZywgb25QYW5lQ2xpY2s6IG9uUGFuZUNsaWNrLCBvblBhbmVNb3VzZUVudGVyOiBvblBhbmVNb3VzZUVudGVyLCBvblBhbmVNb3VzZU1vdmU6IG9uUGFuZU1vdXNlTW92ZSwgb25QYW5lTW91c2VMZWF2ZTogb25QYW5lTW91c2VMZWF2ZSwgb25QYW5lU2Nyb2xsOiBvblBhbmVTY3JvbGwsIG9uUGFuZUNvbnRleHRNZW51OiBvblBhbmVDb250ZXh0TWVudSwgcGFuZUNsaWNrRGlzdGFuY2U6IHBhbmVDbGlja0Rpc3RhbmNlLCBub2RlQ2xpY2tEaXN0YW5jZTogbm9kZUNsaWNrRGlzdGFuY2UsIG9uU2VsZWN0aW9uQ29udGV4dE1lbnU6IG9uU2VsZWN0aW9uQ29udGV4dE1lbnUsIG9uU2VsZWN0aW9uU3RhcnQ6IG9uU2VsZWN0aW9uU3RhcnQsIG9uU2VsZWN0aW9uRW5kOiBvblNlbGVjdGlvbkVuZCwgb25SZWNvbm5lY3Q6IG9uUmVjb25uZWN0LCBvblJlY29ubmVjdFN0YXJ0OiBvblJlY29ubmVjdFN0YXJ0LCBvblJlY29ubmVjdEVuZDogb25SZWNvbm5lY3RFbmQsIG9uRWRnZUNvbnRleHRNZW51OiBvbkVkZ2VDb250ZXh0TWVudSwgb25FZGdlRG91YmxlQ2xpY2s6IG9uRWRnZURvdWJsZUNsaWNrLCBvbkVkZ2VNb3VzZUVudGVyOiBvbkVkZ2VNb3VzZUVudGVyLCBvbkVkZ2VNb3VzZU1vdmU6IG9uRWRnZU1vdXNlTW92ZSwgb25FZGdlTW91c2VMZWF2ZTogb25FZGdlTW91c2VMZWF2ZSwgcmVjb25uZWN0UmFkaXVzOiByZWNvbm5lY3RSYWRpdXMsIGRlZmF1bHRNYXJrZXJDb2xvcjogZGVmYXVsdE1hcmtlckNvbG9yLCBub0RyYWdDbGFzc05hbWU6IG5vRHJhZ0NsYXNzTmFtZSwgbm9XaGVlbENsYXNzTmFtZTogbm9XaGVlbENsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWU6IG5vUGFuQ2xhc3NOYW1lLCByZklkOiByZklkLCBkaXNhYmxlS2V5Ym9hcmRBMTF5OiBkaXNhYmxlS2V5Ym9hcmRBMTF5LCBub2RlRXh0ZW50OiBub2RlRXh0ZW50LCB2aWV3cG9ydDogdmlld3BvcnQsIG9uVmlld3BvcnRDaGFuZ2U6IG9uVmlld3BvcnRDaGFuZ2UgfSksIGpzeChTdG9yZVVwZGF0ZXIsIHsgbm9kZXM6IG5vZGVzLCBlZGdlczogZWRnZXMsIGRlZmF1bHROb2RlczogZGVmYXVsdE5vZGVzLCBkZWZhdWx0RWRnZXM6IGRlZmF1bHRFZGdlcywgb25Db25uZWN0OiBvbkNvbm5lY3QsIG9uQ29ubmVjdFN0YXJ0OiBvbkNvbm5lY3RTdGFydCwgb25Db25uZWN0RW5kOiBvbkNvbm5lY3RFbmQsIG9uQ2xpY2tDb25uZWN0U3RhcnQ6IG9uQ2xpY2tDb25uZWN0U3RhcnQsIG9uQ2xpY2tDb25uZWN0RW5kOiBvbkNsaWNrQ29ubmVjdEVuZCwgbm9kZXNEcmFnZ2FibGU6IG5vZGVzRHJhZ2dhYmxlLCBhdXRvUGFuT25Ob2RlRm9jdXM6IGF1dG9QYW5Pbk5vZGVGb2N1cywgbm9kZXNDb25uZWN0YWJsZTogbm9kZXNDb25uZWN0YWJsZSwgbm9kZXNGb2N1c2FibGU6IG5vZGVzRm9jdXNhYmxlLCBlZGdlc0ZvY3VzYWJsZTogZWRnZXNGb2N1c2FibGUsIGVkZ2VzUmVjb25uZWN0YWJsZTogZWRnZXNSZWNvbm5lY3RhYmxlLCBlbGVtZW50c1NlbGVjdGFibGU6IGVsZW1lbnRzU2VsZWN0YWJsZSwgZWxldmF0ZU5vZGVzT25TZWxlY3Q6IGVsZXZhdGVOb2Rlc09uU2VsZWN0LCBlbGV2YXRlRWRnZXNPblNlbGVjdDogZWxldmF0ZUVkZ2VzT25TZWxlY3QsIG1pblpvb206IG1pblpvb20sIG1heFpvb206IG1heFpvb20sIG5vZGVFeHRlbnQ6IG5vZGVFeHRlbnQsIG9uTm9kZXNDaGFuZ2U6IG9uTm9kZXNDaGFuZ2UsIG9uRWRnZXNDaGFuZ2U6IG9uRWRnZXNDaGFuZ2UsIHNuYXBUb0dyaWQ6IHNuYXBUb0dyaWQsIHNuYXBHcmlkOiBzbmFwR3JpZCwgY29ubmVjdGlvbk1vZGU6IGNvbm5lY3Rpb25Nb2RlLCB0cmFuc2xhdGVFeHRlbnQ6IHRyYW5zbGF0ZUV4dGVudCwgY29ubmVjdE9uQ2xpY2s6IGNvbm5lY3RPbkNsaWNrLCBkZWZhdWx0RWRnZU9wdGlvbnM6IGRlZmF1bHRFZGdlT3B0aW9ucywgZml0VmlldzogZml0VmlldywgZml0Vmlld09wdGlvbnM6IGZpdFZpZXdPcHRpb25zLCBvbk5vZGVzRGVsZXRlOiBvbk5vZGVzRGVsZXRlLCBvbkVkZ2VzRGVsZXRlOiBvbkVkZ2VzRGVsZXRlLCBvbkRlbGV0ZTogb25EZWxldGUsIG9uTm9kZURyYWdTdGFydDogb25Ob2RlRHJhZ1N0YXJ0LCBvbk5vZGVEcmFnOiBvbk5vZGVEcmFnLCBvbk5vZGVEcmFnU3RvcDogb25Ob2RlRHJhZ1N0b3AsIG9uU2VsZWN0aW9uRHJhZzogb25TZWxlY3Rpb25EcmFnLCBvblNlbGVjdGlvbkRyYWdTdGFydDogb25TZWxlY3Rpb25EcmFnU3RhcnQsIG9uU2VsZWN0aW9uRHJhZ1N0b3A6IG9uU2VsZWN0aW9uRHJhZ1N0b3AsIG9uTW92ZTogb25Nb3ZlLCBvbk1vdmVTdGFydDogb25Nb3ZlU3RhcnQsIG9uTW92ZUVuZDogb25Nb3ZlRW5kLCBub1BhbkNsYXNzTmFtZTogbm9QYW5DbGFzc05hbWUsIG5vZGVPcmlnaW46IG5vZGVPcmlnaW4sIHJmSWQ6IHJmSWQsIGF1dG9QYW5PbkNvbm5lY3Q6IGF1dG9QYW5PbkNvbm5lY3QsIGF1dG9QYW5Pbk5vZGVEcmFnOiBhdXRvUGFuT25Ob2RlRHJhZywgYXV0b1BhblNwZWVkOiBhdXRvUGFuU3BlZWQsIG9uRXJyb3I6IG9uRXJyb3IsIGNvbm5lY3Rpb25SYWRpdXM6IGNvbm5lY3Rpb25SYWRpdXMsIGlzVmFsaWRDb25uZWN0aW9uOiBpc1ZhbGlkQ29ubmVjdGlvbiwgc2VsZWN0Tm9kZXNPbkRyYWc6IHNlbGVjdE5vZGVzT25EcmFnLCBub2RlRHJhZ1RocmVzaG9sZDogbm9kZURyYWdUaHJlc2hvbGQsIG9uQmVmb3JlRGVsZXRlOiBvbkJlZm9yZURlbGV0ZSwgcGFuZUNsaWNrRGlzdGFuY2U6IHBhbmVDbGlja0Rpc3RhbmNlLCBkZWJ1ZzogZGVidWcsIGFyaWFMYWJlbENvbmZpZzogYXJpYUxhYmVsQ29uZmlnIH0pLCBqc3goU2VsZWN0aW9uTGlzdGVuZXIsIHsgb25TZWxlY3Rpb25DaGFuZ2U6IG9uU2VsZWN0aW9uQ2hhbmdlIH0pLCBjaGlsZHJlbiwganN4KEF0dHJpYnV0aW9uLCB7IHByb09wdGlvbnM6IHByb09wdGlvbnMsIHBvc2l0aW9uOiBhdHRyaWJ1dGlvblBvc2l0aW9uIH0pLCBqc3goQTExeURlc2NyaXB0aW9ucywgeyByZklkOiByZklkLCBkaXNhYmxlS2V5Ym9hcmRBMTF5OiBkaXNhYmxlS2V5Ym9hcmRBMTF5IH0pXSB9KSB9KSk7XG59XG4vKipcbiAqIFRoZSBgPFJlYWN0RmxvdyAvPmAgY29tcG9uZW50IGlzIHRoZSBoZWFydCBvZiB5b3VyIFJlYWN0IEZsb3cgYXBwbGljYXRpb24uXG4gKiBJdCByZW5kZXJzIHlvdXIgbm9kZXMgYW5kIGVkZ2VzIGFuZCBoYW5kbGVzIHVzZXIgaW50ZXJhY3Rpb25cbiAqXG4gKiBAcHVibGljXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICppbXBvcnQgeyBSZWFjdEZsb3cgfSBmcm9tICdAeHlmbG93L3JlYWN0J1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRmxvdygpIHtcbiAqICByZXR1cm4gKDxSZWFjdEZsb3dcbiAqICAgIG5vZGVzPXsuLi59XG4gKiAgICBlZGdlcz17Li4ufVxuICogICAgb25Ob2Rlc0NoYW5nZT17Li4ufVxuICogICAgLi4uXG4gKiAgLz4pO1xuICp9XG4gKmBgYFxuICovXG52YXIgaW5kZXggPSBmaXhlZEZvcndhcmRSZWYoUmVhY3RGbG93KTtcblxuY29uc3Qgc2VsZWN0b3IkNiA9IChzKSA9PiBzLmRvbU5vZGU/LnF1ZXJ5U2VsZWN0b3IoJy5yZWFjdC1mbG93X19lZGdlbGFiZWwtcmVuZGVyZXInKTtcbi8qKlxuICogRWRnZXMgYXJlIFNWRy1iYXNlZC4gSWYgeW91IHdhbnQgdG8gcmVuZGVyIG1vcmUgY29tcGxleCBsYWJlbHMgeW91IGNhbiB1c2UgdGhlXG4gKiBgPEVkZ2VMYWJlbFJlbmRlcmVyIC8+YCBjb21wb25lbnQgdG8gYWNjZXNzIGEgZGl2IGJhc2VkIHJlbmRlcmVyLiBUaGlzIGNvbXBvbmVudFxuICogaXMgYSBwb3J0YWwgdGhhdCByZW5kZXJzIHRoZSBsYWJlbCBpbiBhIGA8ZGl2IC8+YCB0aGF0IGlzIHBvc2l0aW9uZWQgb24gdG9wIG9mXG4gKiB0aGUgZWRnZXMuIFlvdSBjYW4gc2VlIGFuIGV4YW1wbGUgdXNhZ2Ugb2YgdGhlIGNvbXBvbmVudCBpbiB0aGVcbiAqIFtlZGdlIGxhYmVsIHJlbmRlcmVyIGV4YW1wbGVdKC9leGFtcGxlcy9lZGdlcy9lZGdlLWxhYmVsLXJlbmRlcmVyKS5cbiAqIEBwdWJsaWNcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganN4XG4gKiBpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuICogaW1wb3J0IHsgZ2V0QmV6aWVyUGF0aCwgRWRnZUxhYmVsUmVuZGVyZXIsIEJhc2VFZGdlIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICogZXhwb3J0IGZ1bmN0aW9uIEN1c3RvbUVkZ2UoeyBpZCwgZGF0YSwgLi4ucHJvcHMgfSkge1xuICogICBjb25zdCBbZWRnZVBhdGgsIGxhYmVsWCwgbGFiZWxZXSA9IGdldEJlemllclBhdGgocHJvcHMpO1xuICpcbiAqICAgcmV0dXJuIChcbiAqICAgICA8PlxuICogICAgICAgPEJhc2VFZGdlIGlkPXtpZH0gcGF0aD17ZWRnZVBhdGh9IC8+XG4gKiAgICAgICA8RWRnZUxhYmVsUmVuZGVyZXI+XG4gKiAgICAgICAgIDxkaXZcbiAqICAgICAgICAgICBzdHlsZT17e1xuICogICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gKiAgICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoLTUwJSwgLTUwJSkgdHJhbnNsYXRlKCR7bGFiZWxYfXB4LCR7bGFiZWxZfXB4KWAsXG4gKiAgICAgICAgICAgICBiYWNrZ3JvdW5kOiAnI2ZmY2MwMCcsXG4gKiAgICAgICAgICAgICBwYWRkaW5nOiAxMCxcbiAqICAgICAgICAgfX1cbiAqICAgICAgICAgICBjbGFzc05hbWU9XCJub2RyYWcgbm9wYW5cIlxuICogICAgICAgICA+XG4gKiAgICAgICAgICB7ZGF0YS5sYWJlbH1cbiAqICAgICAgICAgPC9kaXY+XG4gKiAgICAgICA8L0VkZ2VMYWJlbFJlbmRlcmVyPlxuICogICAgIDwvPlxuICogICApO1xuICogfTtcbiAqIGBgYFxuICpcbiAqIEByZW1hcmtzIFRoZSBgPEVkZ2VMYWJlbFJlbmRlcmVyIC8+YCBoYXMgbm8gcG9pbnRlciBldmVudHMgYnkgZGVmYXVsdC4gSWYgeW91IHdhbnQgdG9cbiAqIGFkZCBtb3VzZSBpbnRlcmFjdGlvbnMgeW91IG5lZWQgdG8gc2V0IHRoZSBzdHlsZSBgcG9pbnRlckV2ZW50czogYWxsYCBhbmQgYWRkXG4gKiB0aGUgYG5vcGFuYCBjbGFzcyBvbiB0aGUgbGFiZWwgb3IgdGhlIGVsZW1lbnQgeW91IHdhbnQgdG8gaW50ZXJhY3Qgd2l0aC5cbiAqL1xuZnVuY3Rpb24gRWRnZUxhYmVsUmVuZGVyZXIoeyBjaGlsZHJlbiB9KSB7XG4gICAgY29uc3QgZWRnZUxhYmVsUmVuZGVyZXIgPSB1c2VTdG9yZShzZWxlY3RvciQ2KTtcbiAgICBpZiAoIWVkZ2VMYWJlbFJlbmRlcmVyKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBlZGdlTGFiZWxSZW5kZXJlcik7XG59XG5cbmNvbnN0IHNlbGVjdG9yJDUgPSAocykgPT4gcy5kb21Ob2RlPy5xdWVyeVNlbGVjdG9yKCcucmVhY3QtZmxvd19fdmlld3BvcnQtcG9ydGFsJyk7XG4vKipcbiAqIFRoZSBgPFZpZXdwb3J0UG9ydGFsIC8+YCBjb21wb25lbnQgY2FuIGJlIHVzZWQgdG8gYWRkIGNvbXBvbmVudHMgdG8gdGhlIHNhbWUgdmlld3BvcnRcbiAqIG9mIHRoZSBmbG93IHdoZXJlIG5vZGVzIGFuZCBlZGdlcyBhcmUgcmVuZGVyZWQuIFRoaXMgaXMgdXNlZnVsIHdoZW4geW91IHdhbnQgdG8gcmVuZGVyXG4gKiB5b3VyIG93biBjb21wb25lbnRzIHRoYXQgYXJlIGFkaGVyZSB0byB0aGUgc2FtZSBjb29yZGluYXRlIHN5c3RlbSBhcyB0aGUgbm9kZXMgJiBlZGdlc1xuICogYW5kIGFyZSBhbHNvIGFmZmVjdGVkIGJ5IHpvb21pbmcgYW5kIHBhbm5pbmdcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganN4XG4gKmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG4gKmltcG9ydCB7IFZpZXdwb3J0UG9ydGFsIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKSB7XG4gKiAgcmV0dXJuIChcbiAqICAgIDxWaWV3cG9ydFBvcnRhbD5cbiAqICAgICAgPGRpdlxuICogICAgICAgIHN0eWxlPXt7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgxMDBweCwgMTAwcHgpJywgcG9zaXRpb246ICdhYnNvbHV0ZScgfX1cbiAqICAgICAgPlxuICogICAgICAgIFRoaXMgZGl2IGlzIHBvc2l0aW9uZWQgYXQgWzEwMCwgMTAwXSBvbiB0aGUgZmxvdy5cbiAqICAgICAgPC9kaXY+XG4gKiAgICA8L1ZpZXdwb3J0UG9ydGFsPlxuICogICk7XG4gKn1cbiAqYGBgXG4gKi9cbmZ1bmN0aW9uIFZpZXdwb3J0UG9ydGFsKHsgY2hpbGRyZW4gfSkge1xuICAgIGNvbnN0IHZpZXdQb3J0YWxEaXYgPSB1c2VTdG9yZShzZWxlY3RvciQ1KTtcbiAgICBpZiAoIXZpZXdQb3J0YWxEaXYpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIHZpZXdQb3J0YWxEaXYpO1xufVxuXG4vKipcbiAqIFdoZW4geW91IHByb2dyYW1tYXRpY2FsbHkgYWRkIG9yIHJlbW92ZSBoYW5kbGVzIHRvIGEgbm9kZSBvciB1cGRhdGUgYSBub2RlJ3NcbiAqIGhhbmRsZSBwb3NpdGlvbiwgeW91IG5lZWQgdG8gbGV0IFJlYWN0IEZsb3cga25vdyBhYm91dCBpdCB1c2luZyB0aGlzIGhvb2suIFRoaXNcbiAqIHdpbGwgdXBkYXRlIHRoZSBpbnRlcm5hbCBkaW1lbnNpb25zIG9mIHRoZSBub2RlIGFuZCBwcm9wZXJseSByZXBvc2l0aW9uIGhhbmRsZXNcbiAqIG9uIHRoZSBjYW52YXMgaWYgbmVjZXNzYXJ5LlxuICpcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zIFVzZSB0aGlzIGZ1bmN0aW9uIHRvIHRlbGwgUmVhY3QgRmxvdyB0byB1cGRhdGUgdGhlIGludGVybmFsIHN0YXRlIG9mIG9uZSBvciBtb3JlIG5vZGVzXG4gKiB0aGF0IHlvdSBoYXZlIGNoYW5nZWQgcHJvZ3JhbW1hdGljYWxseS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganN4XG4gKmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbiAqaW1wb3J0IHsgSGFuZGxlLCB1c2VVcGRhdGVOb2RlSW50ZXJuYWxzIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBSYW5kb21IYW5kbGVOb2RlKHsgaWQgfSkge1xuICogIGNvbnN0IHVwZGF0ZU5vZGVJbnRlcm5hbHMgPSB1c2VVcGRhdGVOb2RlSW50ZXJuYWxzKCk7XG4gKiAgY29uc3QgW2hhbmRsZUNvdW50LCBzZXRIYW5kbGVDb3VudF0gPSB1c2VTdGF0ZSgwKTtcbiAqICBjb25zdCByYW5kb21pemVIYW5kbGVDb3VudCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAqICAgc2V0SGFuZGxlQ291bnQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTApKTtcbiAqICAgIHVwZGF0ZU5vZGVJbnRlcm5hbHMoaWQpO1xuICogIH0sIFtpZCwgdXBkYXRlTm9kZUludGVybmFsc10pO1xuICpcbiAqICByZXR1cm4gKFxuICogICAgPD5cbiAqICAgICAge0FycmF5LmZyb20oeyBsZW5ndGg6IGhhbmRsZUNvdW50IH0pLm1hcCgoXywgaW5kZXgpID0+IChcbiAqICAgICAgICA8SGFuZGxlXG4gKiAgICAgICAgICBrZXk9e2luZGV4fVxuICogICAgICAgICAgdHlwZT1cInRhcmdldFwiXG4gKiAgICAgICAgICBwb3NpdGlvbj1cImxlZnRcIlxuICogICAgICAgICAgaWQ9e2BoYW5kbGUtJHtpbmRleH1gfVxuICogICAgICAgIC8+XG4gKiAgICAgICkpfVxuICpcbiAqICAgICAgPGRpdj5cbiAqICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9e3JhbmRvbWl6ZUhhbmRsZUNvdW50fT5SYW5kb21pemUgaGFuZGxlIGNvdW50PC9idXR0b24+XG4gKiAgICAgICAgPHA+VGhlcmUgYXJlIHtoYW5kbGVDb3VudH0gaGFuZGxlcyBvbiB0aGlzIG5vZGUuPC9wPlxuICogICAgICA8L2Rpdj5cbiAqICAgIDwvPlxuICogICk7XG4gKn1cbiAqYGBgXG4gKiBAcmVtYXJrcyBUaGlzIGhvb2sgY2FuIG9ubHkgYmUgdXNlZCBpbiBhIGNvbXBvbmVudCB0aGF0IGlzIGEgY2hpbGQgb2YgYVxuICp7QGxpbmsgUmVhY3RGbG93UHJvdmlkZXJ9IG9yIGEge0BsaW5rIFJlYWN0Rmxvd30gY29tcG9uZW50LlxuICovXG5mdW5jdGlvbiB1c2VVcGRhdGVOb2RlSW50ZXJuYWxzKCkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICByZXR1cm4gdXNlQ2FsbGJhY2soKGlkKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZG9tTm9kZSwgdXBkYXRlTm9kZUludGVybmFscyB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgY29uc3QgdXBkYXRlSWRzID0gQXJyYXkuaXNBcnJheShpZCkgPyBpZCA6IFtpZF07XG4gICAgICAgIGNvbnN0IHVwZGF0ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHVwZGF0ZUlkcy5mb3JFYWNoKCh1cGRhdGVJZCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgbm9kZUVsZW1lbnQgPSBkb21Ob2RlPy5xdWVyeVNlbGVjdG9yKGAucmVhY3QtZmxvd19fbm9kZVtkYXRhLWlkPVwiJHt1cGRhdGVJZH1cIl1gKTtcbiAgICAgICAgICAgIGlmIChub2RlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZXMuc2V0KHVwZGF0ZUlkLCB7IGlkOiB1cGRhdGVJZCwgbm9kZUVsZW1lbnQsIGZvcmNlOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHVwZGF0ZU5vZGVJbnRlcm5hbHModXBkYXRlcywgeyB0cmlnZ2VyRml0VmlldzogZmFsc2UgfSkpO1xuICAgIH0sIFtdKTtcbn1cblxuY29uc3Qgbm9kZXNTZWxlY3RvciA9IChzdGF0ZSkgPT4gc3RhdGUubm9kZXM7XG4vKipcbiAqIFRoaXMgaG9vayByZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBjdXJyZW50IG5vZGVzLiBDb21wb25lbnRzIHRoYXQgdXNlIHRoaXMgaG9va1xuICogd2lsbCByZS1yZW5kZXIgKip3aGVuZXZlciBhbnkgbm9kZSBjaGFuZ2VzKiosIGluY2x1ZGluZyB3aGVuIGEgbm9kZSBpcyBzZWxlY3RlZFxuICogb3IgbW92ZWQuXG4gKlxuICogQHB1YmxpY1xuICogQHJldHVybnMgQW4gYXJyYXkgb2YgYWxsIG5vZGVzIGN1cnJlbnRseSBpbiB0aGUgZmxvdy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganN4XG4gKmltcG9ydCB7IHVzZU5vZGVzIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAqICBjb25zdCBub2RlcyA9IHVzZU5vZGVzKCk7XG4gKlxuICogIHJldHVybiA8ZGl2PlRoZXJlIGFyZSBjdXJyZW50bHkge25vZGVzLmxlbmd0aH0gbm9kZXMhPC9kaXY+O1xuICp9XG4gKmBgYFxuICovXG5mdW5jdGlvbiB1c2VOb2RlcygpIHtcbiAgICBjb25zdCBub2RlcyA9IHVzZVN0b3JlKG5vZGVzU2VsZWN0b3IsIHNoYWxsb3cpO1xuICAgIHJldHVybiBub2Rlcztcbn1cblxuY29uc3QgZWRnZXNTZWxlY3RvciA9IChzdGF0ZSkgPT4gc3RhdGUuZWRnZXM7XG4vKipcbiAqIFRoaXMgaG9vayByZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBjdXJyZW50IGVkZ2VzLiBDb21wb25lbnRzIHRoYXQgdXNlIHRoaXMgaG9va1xuICogd2lsbCByZS1yZW5kZXIgKip3aGVuZXZlciBhbnkgZWRnZSBjaGFuZ2VzKiouXG4gKlxuICogQHB1YmxpY1xuICogQHJldHVybnMgQW4gYXJyYXkgb2YgYWxsIGVkZ2VzIGN1cnJlbnRseSBpbiB0aGUgZmxvdy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKmltcG9ydCB7IHVzZUVkZ2VzIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKSB7XG4gKiAgY29uc3QgZWRnZXMgPSB1c2VFZGdlcygpO1xuICpcbiAqICByZXR1cm4gPGRpdj5UaGVyZSBhcmUgY3VycmVudGx5IHtlZGdlcy5sZW5ndGh9IGVkZ2VzITwvZGl2PjtcbiAqfVxuICpgYGBcbiAqL1xuZnVuY3Rpb24gdXNlRWRnZXMoKSB7XG4gICAgY29uc3QgZWRnZXMgPSB1c2VTdG9yZShlZGdlc1NlbGVjdG9yLCBzaGFsbG93KTtcbiAgICByZXR1cm4gZWRnZXM7XG59XG5cbmNvbnN0IHZpZXdwb3J0U2VsZWN0b3IgPSAoc3RhdGUpID0+ICh7XG4gICAgeDogc3RhdGUudHJhbnNmb3JtWzBdLFxuICAgIHk6IHN0YXRlLnRyYW5zZm9ybVsxXSxcbiAgICB6b29tOiBzdGF0ZS50cmFuc2Zvcm1bMl0sXG59KTtcbi8qKlxuICogVGhlIGB1c2VWaWV3cG9ydGAgaG9vayBpcyBhIGNvbnZlbmllbnQgd2F5IHRvIHJlYWQgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlXG4gKiB7QGxpbmsgVmlld3BvcnR9IGluIGEgY29tcG9uZW50LiBDb21wb25lbnRzIHRoYXQgdXNlIHRoaXMgaG9va1xuICogd2lsbCByZS1yZW5kZXIgKip3aGVuZXZlciB0aGUgdmlld3BvcnQgY2hhbmdlcyoqLlxuICpcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zIFRoZSBjdXJyZW50IHZpZXdwb3J0LlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICpgYGBqc3hcbiAqaW1wb3J0IHsgdXNlVmlld3BvcnQgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFZpZXdwb3J0RGlzcGxheSgpIHtcbiAqICBjb25zdCB7IHgsIHksIHpvb20gfSA9IHVzZVZpZXdwb3J0KCk7XG4gKlxuICogIHJldHVybiAoXG4gKiAgICA8ZGl2PlxuICogICAgICA8cD5cbiAqICAgICAgICBUaGUgdmlld3BvcnQgaXMgY3VycmVudGx5IGF0ICh7eH0sIHt5fSkgYW5kIHpvb21lZCB0byB7em9vbX0uXG4gKiAgICAgIDwvcD5cbiAqICAgIDwvZGl2PlxuICogICk7XG4gKn1cbiAqYGBgXG4gKlxuICogQHJlbWFya3MgVGhpcyBob29rIGNhbiBvbmx5IGJlIHVzZWQgaW4gYSBjb21wb25lbnQgdGhhdCBpcyBhIGNoaWxkIG9mIGFcbiAqe0BsaW5rIFJlYWN0Rmxvd1Byb3ZpZGVyfSBvciBhIHtAbGluayBSZWFjdEZsb3d9IGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gdXNlVmlld3BvcnQoKSB7XG4gICAgY29uc3Qgdmlld3BvcnQgPSB1c2VTdG9yZSh2aWV3cG9ydFNlbGVjdG9yLCBzaGFsbG93KTtcbiAgICByZXR1cm4gdmlld3BvcnQ7XG59XG5cbi8qKlxuICogVGhpcyBob29rIG1ha2VzIGl0IGVhc3kgdG8gcHJvdG90eXBlIGEgY29udHJvbGxlZCBmbG93IHdoZXJlIHlvdSBtYW5hZ2UgdGhlXG4gKiBzdGF0ZSBvZiBub2RlcyBhbmQgZWRnZXMgb3V0c2lkZSB0aGUgYFJlYWN0Rmxvd0luc3RhbmNlYC4gWW91IGNhbiB0aGluayBvZiBpdFxuICogbGlrZSBSZWFjdCdzIGB1c2VTdGF0ZWAgaG9vayB3aXRoIGFuIGFkZGl0aW9uYWwgaGVscGVyIGNhbGxiYWNrLlxuICpcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zXG4gKiAtIGBub2Rlc2A6IFRoZSBjdXJyZW50IGFycmF5IG9mIG5vZGVzLiBZb3UgbWlnaHQgcGFzcyB0aGlzIGRpcmVjdGx5IHRvIHRoZSBgbm9kZXNgIHByb3Agb2YgeW91clxuICogYDxSZWFjdEZsb3cgLz5gIGNvbXBvbmVudCwgb3IgeW91IG1heSB3YW50IHRvIG1hbmlwdWxhdGUgaXQgZmlyc3QgdG8gcGVyZm9ybSBzb21lIGxheW91dGluZyxcbiAqIGZvciBleGFtcGxlLlxuICogLSBgc2V0Tm9kZXNgOiBBIGZ1bmN0aW9uIHRoYXQgeW91IGNhbiB1c2UgdG8gdXBkYXRlIHRoZSBub2Rlcy4gWW91IGNhbiBwYXNzIGl0IGEgbmV3IGFycmF5IG9mXG4gKiBub2RlcyBvciBhIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgdGhlIGN1cnJlbnQgYXJyYXkgb2Ygbm9kZXMgYW5kIHJldHVybnMgYSBuZXcgYXJyYXkgb2Ygbm9kZXMuXG4gKiBUaGlzIGlzIHRoZSBzYW1lIGFzIHRoZSBzZWNvbmQgZWxlbWVudCBvZiB0aGUgdHVwbGUgcmV0dXJuZWQgYnkgUmVhY3QncyBgdXNlU3RhdGVgIGhvb2suXG4gKiAtIGBvbk5vZGVzQ2hhbmdlYDogQSBoYW5keSBjYWxsYmFjayB0aGF0IGNhbiB0YWtlIGFuIGFycmF5IG9mIGBOb2RlQ2hhbmdlc2AgYW5kIHVwZGF0ZSB0aGUgbm9kZXNcbiAqIHN0YXRlIGFjY29yZGluZ2x5LiBZb3UnbGwgdHlwaWNhbGx5IHBhc3MgdGhpcyBkaXJlY3RseSB0byB0aGUgYG9uTm9kZXNDaGFuZ2VgIHByb3Agb2YgeW91clxuICogYDxSZWFjdEZsb3cgLz5gIGNvbXBvbmVudC5cbiAqIEBleGFtcGxlXG4gKlxuICpgYGB0c3hcbiAqaW1wb3J0IHsgUmVhY3RGbG93LCB1c2VOb2Rlc1N0YXRlLCB1c2VFZGdlc1N0YXRlIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpjb25zdCBpbml0aWFsTm9kZXMgPSBbXTtcbiAqY29uc3QgaW5pdGlhbEVkZ2VzID0gW107XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKSB7XG4gKiAgY29uc3QgW25vZGVzLCBzZXROb2Rlcywgb25Ob2Rlc0NoYW5nZV0gPSB1c2VOb2Rlc1N0YXRlKGluaXRpYWxOb2Rlcyk7XG4gKiAgY29uc3QgW2VkZ2VzLCBzZXRFZGdlcywgb25FZGdlc0NoYW5nZV0gPSB1c2VFZGdlc1N0YXRlKGluaXRpYWxFZGdlcyk7XG4gKlxuICogIHJldHVybiAoXG4gKiAgICA8UmVhY3RGbG93XG4gKiAgICAgIG5vZGVzPXtub2Rlc31cbiAqICAgICAgZWRnZXM9e2VkZ2VzfVxuICogICAgICBvbk5vZGVzQ2hhbmdlPXtvbk5vZGVzQ2hhbmdlfVxuICogICAgICBvbkVkZ2VzQ2hhbmdlPXtvbkVkZ2VzQ2hhbmdlfVxuICogICAgLz5cbiAqICApO1xuICp9XG4gKmBgYFxuICpcbiAqIEByZW1hcmtzIFRoaXMgaG9vayB3YXMgY3JlYXRlZCB0byBtYWtlIHByb3RvdHlwaW5nIGVhc2llciBhbmQgb3VyIGRvY3VtZW50YXRpb25cbiAqIGV4YW1wbGVzIGNsZWFyZXIuIEFsdGhvdWdoIGl0IGlzIE9LIHRvIHVzZSB0aGlzIGhvb2sgaW4gcHJvZHVjdGlvbiwgaW5cbiAqIHByYWN0aWNlIHlvdSBtYXkgd2FudCB0byB1c2UgYSBtb3JlIHNvcGhpc3RpY2F0ZWQgc3RhdGUgbWFuYWdlbWVudCBzb2x1dGlvblxuICogbGlrZSBadXN0YW5kIHtAbGluayBodHRwczovL3JlYWN0Zmxvdy5kZXYvZG9jcy9ndWlkZXMvc3RhdGUtbWFuYWdlbWVudC99IGluc3RlYWQuXG4gKlxuICovXG5mdW5jdGlvbiB1c2VOb2Rlc1N0YXRlKGluaXRpYWxOb2Rlcykge1xuICAgIGNvbnN0IFtub2Rlcywgc2V0Tm9kZXNdID0gdXNlU3RhdGUoaW5pdGlhbE5vZGVzKTtcbiAgICBjb25zdCBvbk5vZGVzQ2hhbmdlID0gdXNlQ2FsbGJhY2soKGNoYW5nZXMpID0+IHNldE5vZGVzKChuZHMpID0+IGFwcGx5Tm9kZUNoYW5nZXMoY2hhbmdlcywgbmRzKSksIFtdKTtcbiAgICByZXR1cm4gW25vZGVzLCBzZXROb2Rlcywgb25Ob2Rlc0NoYW5nZV07XG59XG4vKipcbiAqIFRoaXMgaG9vayBtYWtlcyBpdCBlYXN5IHRvIHByb3RvdHlwZSBhIGNvbnRyb2xsZWQgZmxvdyB3aGVyZSB5b3UgbWFuYWdlIHRoZVxuICogc3RhdGUgb2Ygbm9kZXMgYW5kIGVkZ2VzIG91dHNpZGUgdGhlIGBSZWFjdEZsb3dJbnN0YW5jZWAuIFlvdSBjYW4gdGhpbmsgb2YgaXRcbiAqIGxpa2UgUmVhY3QncyBgdXNlU3RhdGVgIGhvb2sgd2l0aCBhbiBhZGRpdGlvbmFsIGhlbHBlciBjYWxsYmFjay5cbiAqXG4gKiBAcHVibGljXG4gKiBAcmV0dXJuc1xuICogLSBgZWRnZXNgOiBUaGUgY3VycmVudCBhcnJheSBvZiBlZGdlcy4gWW91IG1pZ2h0IHBhc3MgdGhpcyBkaXJlY3RseSB0byB0aGUgYGVkZ2VzYCBwcm9wIG9mIHlvdXJcbiAqIGA8UmVhY3RGbG93IC8+YCBjb21wb25lbnQsIG9yIHlvdSBtYXkgd2FudCB0byBtYW5pcHVsYXRlIGl0IGZpcnN0IHRvIHBlcmZvcm0gc29tZSBsYXlvdXRpbmcsXG4gKiBmb3IgZXhhbXBsZS5cbiAqXG4gKiAtIGBzZXRFZGdlc2A6IEEgZnVuY3Rpb24gdGhhdCB5b3UgY2FuIHVzZSB0byB1cGRhdGUgdGhlIGVkZ2VzLiBZb3UgY2FuIHBhc3MgaXQgYSBuZXcgYXJyYXkgb2ZcbiAqIGVkZ2VzIG9yIGEgY2FsbGJhY2sgdGhhdCByZWNlaXZlcyB0aGUgY3VycmVudCBhcnJheSBvZiBlZGdlcyBhbmQgcmV0dXJucyBhIG5ldyBhcnJheSBvZiBlZGdlcy5cbiAqIFRoaXMgaXMgdGhlIHNhbWUgYXMgdGhlIHNlY29uZCBlbGVtZW50IG9mIHRoZSB0dXBsZSByZXR1cm5lZCBieSBSZWFjdCdzIGB1c2VTdGF0ZWAgaG9vay5cbiAqXG4gKiAtIGBvbkVkZ2VzQ2hhbmdlYDogQSBoYW5keSBjYWxsYmFjayB0aGF0IGNhbiB0YWtlIGFuIGFycmF5IG9mIGBFZGdlQ2hhbmdlc2AgYW5kIHVwZGF0ZSB0aGUgZWRnZXNcbiAqIHN0YXRlIGFjY29yZGluZ2x5LiBZb3UnbGwgdHlwaWNhbGx5IHBhc3MgdGhpcyBkaXJlY3RseSB0byB0aGUgYG9uRWRnZXNDaGFuZ2VgIHByb3Agb2YgeW91clxuICogYDxSZWFjdEZsb3cgLz5gIGNvbXBvbmVudC5cbiAqIEBleGFtcGxlXG4gKlxuICpgYGB0c3hcbiAqaW1wb3J0IHsgUmVhY3RGbG93LCB1c2VOb2Rlc1N0YXRlLCB1c2VFZGdlc1N0YXRlIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpjb25zdCBpbml0aWFsTm9kZXMgPSBbXTtcbiAqY29uc3QgaW5pdGlhbEVkZ2VzID0gW107XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKSB7XG4gKiAgY29uc3QgW25vZGVzLCBzZXROb2Rlcywgb25Ob2Rlc0NoYW5nZV0gPSB1c2VOb2Rlc1N0YXRlKGluaXRpYWxOb2Rlcyk7XG4gKiAgY29uc3QgW2VkZ2VzLCBzZXRFZGdlcywgb25FZGdlc0NoYW5nZV0gPSB1c2VFZGdlc1N0YXRlKGluaXRpYWxFZGdlcyk7XG4gKlxuICogIHJldHVybiAoXG4gKiAgICA8UmVhY3RGbG93XG4gKiAgICAgIG5vZGVzPXtub2Rlc31cbiAqICAgICAgZWRnZXM9e2VkZ2VzfVxuICogICAgICBvbk5vZGVzQ2hhbmdlPXtvbk5vZGVzQ2hhbmdlfVxuICogICAgICBvbkVkZ2VzQ2hhbmdlPXtvbkVkZ2VzQ2hhbmdlfVxuICogICAgLz5cbiAqICApO1xuICp9XG4gKmBgYFxuICpcbiAqIEByZW1hcmtzIFRoaXMgaG9vayB3YXMgY3JlYXRlZCB0byBtYWtlIHByb3RvdHlwaW5nIGVhc2llciBhbmQgb3VyIGRvY3VtZW50YXRpb25cbiAqIGV4YW1wbGVzIGNsZWFyZXIuIEFsdGhvdWdoIGl0IGlzIE9LIHRvIHVzZSB0aGlzIGhvb2sgaW4gcHJvZHVjdGlvbiwgaW5cbiAqIHByYWN0aWNlIHlvdSBtYXkgd2FudCB0byB1c2UgYSBtb3JlIHNvcGhpc3RpY2F0ZWQgc3RhdGUgbWFuYWdlbWVudCBzb2x1dGlvblxuICogbGlrZSBadXN0YW5kIHtAbGluayBodHRwczovL3JlYWN0Zmxvdy5kZXYvZG9jcy9ndWlkZXMvc3RhdGUtbWFuYWdlbWVudC99IGluc3RlYWQuXG4gKlxuICovXG5mdW5jdGlvbiB1c2VFZGdlc1N0YXRlKGluaXRpYWxFZGdlcykge1xuICAgIGNvbnN0IFtlZGdlcywgc2V0RWRnZXNdID0gdXNlU3RhdGUoaW5pdGlhbEVkZ2VzKTtcbiAgICBjb25zdCBvbkVkZ2VzQ2hhbmdlID0gdXNlQ2FsbGJhY2soKGNoYW5nZXMpID0+IHNldEVkZ2VzKChlZHMpID0+IGFwcGx5RWRnZUNoYW5nZXMoY2hhbmdlcywgZWRzKSksIFtdKTtcbiAgICByZXR1cm4gW2VkZ2VzLCBzZXRFZGdlcywgb25FZGdlc0NoYW5nZV07XG59XG5cbi8qKlxuICogVGhlIGB1c2VPblZpZXdwb3J0Q2hhbmdlYCBob29rIGxldHMgeW91IGxpc3RlbiBmb3IgY2hhbmdlcyB0byB0aGUgdmlld3BvcnQgc3VjaFxuICogYXMgcGFubmluZyBhbmQgem9vbWluZy4gWW91IGNhbiBwcm92aWRlIGEgY2FsbGJhY2sgZm9yIGVhY2ggcGhhc2Ugb2YgYSB2aWV3cG9ydFxuICogY2hhbmdlOiBgb25TdGFydGAsIGBvbkNoYW5nZWAsIGFuZCBgb25FbmRgLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKiBgYGBqc3hcbiAqaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG4gKmltcG9ydCB7IHVzZU9uVmlld3BvcnRDaGFuZ2UgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmZ1bmN0aW9uIFZpZXdwb3J0Q2hhbmdlTG9nZ2VyKCkge1xuICogIHVzZU9uVmlld3BvcnRDaGFuZ2Uoe1xuICogICAgb25TdGFydDogKHZpZXdwb3J0OiBWaWV3cG9ydCkgPT4gY29uc29sZS5sb2coJ3N0YXJ0Jywgdmlld3BvcnQpLFxuICogICAgb25DaGFuZ2U6ICh2aWV3cG9ydDogVmlld3BvcnQpID0+IGNvbnNvbGUubG9nKCdjaGFuZ2UnLCB2aWV3cG9ydCksXG4gKiAgICBvbkVuZDogKHZpZXdwb3J0OiBWaWV3cG9ydCkgPT4gY29uc29sZS5sb2coJ2VuZCcsIHZpZXdwb3J0KSxcbiAqICB9KTtcbiAqXG4gKiAgcmV0dXJuIG51bGw7XG4gKn1cbiAqYGBgXG4gKi9cbmZ1bmN0aW9uIHVzZU9uVmlld3BvcnRDaGFuZ2UoeyBvblN0YXJ0LCBvbkNoYW5nZSwgb25FbmQgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IG9uVmlld3BvcnRDaGFuZ2VTdGFydDogb25TdGFydCB9KTtcbiAgICB9LCBbb25TdGFydF0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHsgb25WaWV3cG9ydENoYW5nZTogb25DaGFuZ2UgfSk7XG4gICAgfSwgW29uQ2hhbmdlXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBvblZpZXdwb3J0Q2hhbmdlRW5kOiBvbkVuZCB9KTtcbiAgICB9LCBbb25FbmRdKTtcbn1cblxuLyoqXG4gKiBUaGlzIGhvb2sgbGV0cyB5b3UgbGlzdGVuIGZvciBjaGFuZ2VzIHRvIGJvdGggbm9kZSBhbmQgZWRnZSBzZWxlY3Rpb24uIEFzIHRoZVxuICpuYW1lIGltcGxpZXMsIHRoZSBjYWxsYmFjayB5b3UgcHJvdmlkZSB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciB0aGUgc2VsZWN0aW9uIG9mXG4gKl9laXRoZXJfIG5vZGVzIG9yIGVkZ2VzIGNoYW5nZXMuXG4gKlxuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqIGBgYGpzeFxuICppbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbiAqaW1wb3J0IHsgUmVhY3RGbG93LCB1c2VPblNlbGVjdGlvbkNoYW5nZSB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZnVuY3Rpb24gU2VsZWN0aW9uRGlzcGxheSgpIHtcbiAqICBjb25zdCBbc2VsZWN0ZWROb2Rlcywgc2V0U2VsZWN0ZWROb2Rlc10gPSB1c2VTdGF0ZShbXSk7XG4gKiAgY29uc3QgW3NlbGVjdGVkRWRnZXMsIHNldFNlbGVjdGVkRWRnZXNdID0gdXNlU3RhdGUoW10pO1xuICpcbiAqICAvLyB0aGUgcGFzc2VkIGhhbmRsZXIgaGFzIHRvIGJlIG1lbW9pemVkLCBvdGhlcndpc2UgdGhlIGhvb2sgd2lsbCBub3Qgd29yayBjb3JyZWN0bHlcbiAqICBjb25zdCBvbkNoYW5nZSA9IHVzZUNhbGxiYWNrKCh7IG5vZGVzLCBlZGdlcyB9KSA9PiB7XG4gKiAgICBzZXRTZWxlY3RlZE5vZGVzKG5vZGVzLm1hcCgobm9kZSkgPT4gbm9kZS5pZCkpO1xuICogICAgc2V0U2VsZWN0ZWRFZGdlcyhlZGdlcy5tYXAoKGVkZ2UpID0+IGVkZ2UuaWQpKTtcbiAqICB9LCBbXSk7XG4gKlxuICogIHVzZU9uU2VsZWN0aW9uQ2hhbmdlKHtcbiAqICAgIG9uQ2hhbmdlLFxuICogIH0pO1xuICpcbiAqICByZXR1cm4gKFxuICogICAgPGRpdj5cbiAqICAgICAgPHA+U2VsZWN0ZWQgbm9kZXM6IHtzZWxlY3RlZE5vZGVzLmpvaW4oJywgJyl9PC9wPlxuICogICAgICA8cD5TZWxlY3RlZCBlZGdlczoge3NlbGVjdGVkRWRnZXMuam9pbignLCAnKX08L3A+XG4gKiAgICA8L2Rpdj5cbiAqICApO1xuICp9XG4gKmBgYFxuICpcbiAqIEByZW1hcmtzIFlvdSBuZWVkIHRvIG1lbW9pemUgdGhlIHBhc3NlZCBgb25DaGFuZ2VgIGhhbmRsZXIsIG90aGVyd2lzZSB0aGUgaG9vayB3aWxsIG5vdCB3b3JrIGNvcnJlY3RseS5cbiAqL1xuZnVuY3Rpb24gdXNlT25TZWxlY3Rpb25DaGFuZ2UoeyBvbkNoYW5nZSwgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBuZXh0T25TZWxlY3Rpb25DaGFuZ2VIYW5kbGVycyA9IFsuLi5zdG9yZS5nZXRTdGF0ZSgpLm9uU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnMsIG9uQ2hhbmdlXTtcbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBvblNlbGVjdGlvbkNoYW5nZUhhbmRsZXJzOiBuZXh0T25TZWxlY3Rpb25DaGFuZ2VIYW5kbGVycyB9KTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRIYW5kbGVycyA9IHN0b3JlLmdldFN0YXRlKCkub25TZWxlY3Rpb25DaGFuZ2VIYW5kbGVycy5maWx0ZXIoKGZuKSA9PiBmbiAhPT0gb25DaGFuZ2UpO1xuICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBvblNlbGVjdGlvbkNoYW5nZUhhbmRsZXJzOiBuZXh0SGFuZGxlcnMgfSk7XG4gICAgICAgIH07XG4gICAgfSwgW29uQ2hhbmdlXSk7XG59XG5cbmNvbnN0IHNlbGVjdG9yJDQgPSAob3B0aW9ucykgPT4gKHMpID0+IHtcbiAgICBpZiAoIW9wdGlvbnMuaW5jbHVkZUhpZGRlbk5vZGVzKSB7XG4gICAgICAgIHJldHVybiBzLm5vZGVzSW5pdGlhbGl6ZWQ7XG4gICAgfVxuICAgIGlmIChzLm5vZGVMb29rdXAuc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoY29uc3QgWywgeyBpbnRlcm5hbHMgfV0gb2Ygcy5ub2RlTG9va3VwKSB7XG4gICAgICAgIGlmIChpbnRlcm5hbHMuaGFuZGxlQm91bmRzID09PSB1bmRlZmluZWQgfHwgIW5vZGVIYXNEaW1lbnNpb25zKGludGVybmFscy51c2VyTm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbiAqIFRoaXMgaG9vayB0ZWxscyB5b3Ugd2hldGhlciBhbGwgdGhlIG5vZGVzIGluIGEgZmxvdyBoYXZlIGJlZW4gbWVhc3VyZWQgYW5kIGdpdmVuXG4gKmEgd2lkdGggYW5kIGhlaWdodC4gV2hlbiB5b3UgYWRkIGEgbm9kZSB0byB0aGUgZmxvdywgdGhpcyBob29rIHdpbGwgcmV0dXJuXG4gKmBmYWxzZWAgYW5kIHRoZW4gYHRydWVgIGFnYWluIG9uY2UgdGhlIG5vZGUgaGFzIGJlZW4gbWVhc3VyZWQuXG4gKlxuICogQHB1YmxpY1xuICogQHJldHVybnMgV2hldGhlciBvciBub3QgdGhlIG5vZGVzIGhhdmUgYmVlbiBpbml0aWFsaXplZCBieSB0aGUgYDxSZWFjdEZsb3cgLz5gIGNvbXBvbmVudCBhbmRcbiAqIGdpdmVuIGEgd2lkdGggYW5kIGhlaWdodC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganN4XG4gKmltcG9ydCB7IHVzZVJlYWN0RmxvdywgdXNlTm9kZXNJbml0aWFsaXplZCB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICppbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuICpcbiAqY29uc3Qgb3B0aW9ucyA9IHtcbiAqICBpbmNsdWRlSGlkZGVuTm9kZXM6IGZhbHNlLFxuICp9O1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXNlTGF5b3V0KCkge1xuICogIGNvbnN0IHsgZ2V0Tm9kZXMgfSA9IHVzZVJlYWN0RmxvdygpO1xuICogIGNvbnN0IG5vZGVzSW5pdGlhbGl6ZWQgPSB1c2VOb2Rlc0luaXRpYWxpemVkKG9wdGlvbnMpO1xuICogIGNvbnN0IFtsYXlvdXRlZE5vZGVzLCBzZXRMYXlvdXRlZE5vZGVzXSA9IHVzZVN0YXRlKGdldE5vZGVzKCkpO1xuICpcbiAqICB1c2VFZmZlY3QoKCkgPT4ge1xuICogICAgaWYgKG5vZGVzSW5pdGlhbGl6ZWQpIHtcbiAqICAgICAgc2V0TGF5b3V0ZWROb2Rlcyh5b3VyTGF5b3V0aW5nRnVuY3Rpb24oZ2V0Tm9kZXMoKSkpO1xuICogICAgfVxuICogIH0sIFtub2Rlc0luaXRpYWxpemVkXSk7XG4gKlxuICogIHJldHVybiBsYXlvdXRlZE5vZGVzO1xuICp9XG4gKmBgYFxuICovXG5mdW5jdGlvbiB1c2VOb2Rlc0luaXRpYWxpemVkKG9wdGlvbnMgPSB7XG4gICAgaW5jbHVkZUhpZGRlbk5vZGVzOiBmYWxzZSxcbn0pIHtcbiAgICBjb25zdCBpbml0aWFsaXplZCA9IHVzZVN0b3JlKHNlbGVjdG9yJDQob3B0aW9ucykpO1xuICAgIHJldHVybiBpbml0aWFsaXplZDtcbn1cblxuLyoqXG4gKiBIb29rIHRvIGNoZWNrIGlmIGEgPEhhbmRsZSAvPiBpcyBjb25uZWN0ZWQgdG8gYW5vdGhlciA8SGFuZGxlIC8+IGFuZCBnZXQgdGhlIGNvbm5lY3Rpb25zLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBkZXByZWNhdGVkIFVzZSBgdXNlTm9kZUNvbm5lY3Rpb25zYCBpbnN0ZWFkLlxuICogQHJldHVybnMgQW4gYXJyYXkgd2l0aCBoYW5kbGUgY29ubmVjdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIHVzZUhhbmRsZUNvbm5lY3Rpb25zKHsgdHlwZSwgaWQsIG5vZGVJZCwgb25Db25uZWN0LCBvbkRpc2Nvbm5lY3QsIH0pIHtcbiAgICBjb25zb2xlLndhcm4oJ1tERVBSRUNBVEVEXSBgdXNlSGFuZGxlQ29ubmVjdGlvbnNgIGlzIGRlcHJlY2F0ZWQuIEluc3RlYWQgdXNlIGB1c2VOb2RlQ29ubmVjdGlvbnNgIGh0dHBzOi8vcmVhY3RmbG93LmRldi9hcGktcmVmZXJlbmNlL2hvb2tzL3VzZU5vZGVDb25uZWN0aW9ucycpO1xuICAgIGNvbnN0IF9ub2RlSWQgPSB1c2VOb2RlSWQoKTtcbiAgICBjb25zdCBjdXJyZW50Tm9kZUlkID0gbm9kZUlkID8/IF9ub2RlSWQ7XG4gICAgY29uc3QgcHJldkNvbm5lY3Rpb25zID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGNvbm5lY3Rpb25zID0gdXNlU3RvcmUoKHN0YXRlKSA9PiBzdGF0ZS5jb25uZWN0aW9uTG9va3VwLmdldChgJHtjdXJyZW50Tm9kZUlkfS0ke3R5cGV9JHtpZCA/IGAtJHtpZH1gIDogJyd9YCksIGFyZUNvbm5lY3Rpb25NYXBzRXF1YWwpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIC8vIEB0b2RvIGRpY3VzcyBpZiBvbkNvbm5lY3Qvb25EaXNjb25uZWN0IHNob3VsZCBiZSBjYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IG1vdW50cy91bm1vdW50c1xuICAgICAgICBpZiAocHJldkNvbm5lY3Rpb25zLmN1cnJlbnQgJiYgcHJldkNvbm5lY3Rpb25zLmN1cnJlbnQgIT09IGNvbm5lY3Rpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBfY29ubmVjdGlvbnMgPSBjb25uZWN0aW9ucyA/PyBuZXcgTWFwKCk7XG4gICAgICAgICAgICBoYW5kbGVDb25uZWN0aW9uQ2hhbmdlKHByZXZDb25uZWN0aW9ucy5jdXJyZW50LCBfY29ubmVjdGlvbnMsIG9uRGlzY29ubmVjdCk7XG4gICAgICAgICAgICBoYW5kbGVDb25uZWN0aW9uQ2hhbmdlKF9jb25uZWN0aW9ucywgcHJldkNvbm5lY3Rpb25zLmN1cnJlbnQsIG9uQ29ubmVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgcHJldkNvbm5lY3Rpb25zLmN1cnJlbnQgPSBjb25uZWN0aW9ucyA/PyBuZXcgTWFwKCk7XG4gICAgfSwgW2Nvbm5lY3Rpb25zLCBvbkNvbm5lY3QsIG9uRGlzY29ubmVjdF0pO1xuICAgIHJldHVybiB1c2VNZW1vKCgpID0+IEFycmF5LmZyb20oY29ubmVjdGlvbnM/LnZhbHVlcygpID8/IFtdKSwgW2Nvbm5lY3Rpb25zXSk7XG59XG5cbmNvbnN0IGVycm9yMDE0ID0gZXJyb3JNZXNzYWdlc1snZXJyb3IwMTQnXSgpO1xuLyoqXG4gKiBUaGlzIGhvb2sgcmV0dXJucyBhbiBhcnJheSBvZiBjb25uZWN0aW9ucyBvbiBhIHNwZWNpZmljIG5vZGUsIGhhbmRsZSB0eXBlICgnc291cmNlJywgJ3RhcmdldCcpIG9yIGhhbmRsZSBJRC5cbiAqXG4gKiBAcHVibGljXG4gKiBAcmV0dXJucyBBbiBhcnJheSB3aXRoIGNvbm5lY3Rpb25zLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc3hcbiAqaW1wb3J0IHsgdXNlTm9kZUNvbm5lY3Rpb25zIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKSB7XG4gKiAgY29uc3QgY29ubmVjdGlvbnMgPSB1c2VOb2RlQ29ubmVjdGlvbnMoe1xuICogICAgaGFuZGxlVHlwZTogJ3RhcmdldCcsXG4gKiAgICBoYW5kbGVJZDogJ215LWhhbmRsZScsXG4gKiAgfSk7XG4gKlxuICogIHJldHVybiAoXG4gKiAgICA8ZGl2PlRoZXJlIGFyZSBjdXJyZW50bHkge2Nvbm5lY3Rpb25zLmxlbmd0aH0gaW5jb21pbmcgY29ubmVjdGlvbnMhPC9kaXY+XG4gKiAgKTtcbiAqfVxuICpgYGBcbiAqL1xuZnVuY3Rpb24gdXNlTm9kZUNvbm5lY3Rpb25zKHsgaWQsIGhhbmRsZVR5cGUsIGhhbmRsZUlkLCBvbkNvbm5lY3QsIG9uRGlzY29ubmVjdCwgfSA9IHt9KSB7XG4gICAgY29uc3Qgbm9kZUlkID0gdXNlTm9kZUlkKCk7XG4gICAgY29uc3QgY3VycmVudE5vZGVJZCA9IGlkID8/IG5vZGVJZDtcbiAgICBpZiAoIWN1cnJlbnROb2RlSWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yMDE0KTtcbiAgICB9XG4gICAgY29uc3QgcHJldkNvbm5lY3Rpb25zID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGNvbm5lY3Rpb25zID0gdXNlU3RvcmUoKHN0YXRlKSA9PiBzdGF0ZS5jb25uZWN0aW9uTG9va3VwLmdldChgJHtjdXJyZW50Tm9kZUlkfSR7aGFuZGxlVHlwZSA/IChoYW5kbGVJZCA/IGAtJHtoYW5kbGVUeXBlfS0ke2hhbmRsZUlkfWAgOiBgLSR7aGFuZGxlVHlwZX1gKSA6ICcnfWApLCBhcmVDb25uZWN0aW9uTWFwc0VxdWFsKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAvLyBAdG9kbyBkaXNjdXNzIGlmIG9uQ29ubmVjdC9vbkRpc2Nvbm5lY3Qgc2hvdWxkIGJlIGNhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgbW91bnRzL3VubW91bnRzXG4gICAgICAgIGlmIChwcmV2Q29ubmVjdGlvbnMuY3VycmVudCAmJiBwcmV2Q29ubmVjdGlvbnMuY3VycmVudCAhPT0gY29ubmVjdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IF9jb25uZWN0aW9ucyA9IGNvbm5lY3Rpb25zID8/IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGhhbmRsZUNvbm5lY3Rpb25DaGFuZ2UocHJldkNvbm5lY3Rpb25zLmN1cnJlbnQsIF9jb25uZWN0aW9ucywgb25EaXNjb25uZWN0KTtcbiAgICAgICAgICAgIGhhbmRsZUNvbm5lY3Rpb25DaGFuZ2UoX2Nvbm5lY3Rpb25zLCBwcmV2Q29ubmVjdGlvbnMuY3VycmVudCwgb25Db25uZWN0KTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2Q29ubmVjdGlvbnMuY3VycmVudCA9IGNvbm5lY3Rpb25zID8/IG5ldyBNYXAoKTtcbiAgICB9LCBbY29ubmVjdGlvbnMsIG9uQ29ubmVjdCwgb25EaXNjb25uZWN0XSk7XG4gICAgcmV0dXJuIHVzZU1lbW8oKCkgPT4gQXJyYXkuZnJvbShjb25uZWN0aW9ucz8udmFsdWVzKCkgPz8gW10pLCBbY29ubmVjdGlvbnNdKTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIHVzZU5vZGVzRGF0YShub2RlSWRzKSB7XG4gICAgY29uc3Qgbm9kZXNEYXRhID0gdXNlU3RvcmUodXNlQ2FsbGJhY2soKHMpID0+IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IFtdO1xuICAgICAgICBjb25zdCBpc0FycmF5T2ZJZHMgPSBBcnJheS5pc0FycmF5KG5vZGVJZHMpO1xuICAgICAgICBjb25zdCBfbm9kZUlkcyA9IGlzQXJyYXlPZklkcyA/IG5vZGVJZHMgOiBbbm9kZUlkc107XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZUlkIG9mIF9ub2RlSWRzKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gcy5ub2RlTG9va3VwLmdldChub2RlSWQpO1xuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZDogbm9kZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogbm9kZS50eXBlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBub2RlLmRhdGEsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzQXJyYXlPZklkcyA/IGRhdGEgOiBkYXRhWzBdID8/IG51bGw7XG4gICAgfSwgW25vZGVJZHNdKSwgc2hhbGxvd05vZGVEYXRhKTtcbiAgICByZXR1cm4gbm9kZXNEYXRhO1xufVxuXG4vKipcbiAqIFRoaXMgaG9vayByZXR1cm5zIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiBhIHNwZWNpZmljIG5vZGUuXG4gKiBDb21wb25lbnRzIHRoYXQgdXNlIHRoaXMgaG9vayB3aWxsIHJlLXJlbmRlciAqKndoZW5ldmVyIHRoZSBub2RlIGNoYW5nZXMqKixcbiAqIGluY2x1ZGluZyB3aGVuIGEgbm9kZSBpcyBzZWxlY3RlZCBvciBtb3ZlZC5cbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gaWQgLSBUaGUgSUQgb2YgYSBub2RlIHlvdSB3YW50IHRvIG9ic2VydmUuXG4gKiBAcmV0dXJucyBUaGUgYEludGVybmFsTm9kZWAgb2JqZWN0IGZvciB0aGUgbm9kZSB3aXRoIHRoZSBnaXZlbiBJRC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKmltcG9ydCB7IHVzZUludGVybmFsTm9kZSB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCkge1xuICogIGNvbnN0IGludGVybmFsTm9kZSA9IHVzZUludGVybmFsTm9kZSgnbm9kZS0xJyk7XG4gKiAgY29uc3QgYWJzb2x1dGVQb3NpdGlvbiA9IGludGVybmFsTm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZTtcbiAqXG4gKiAgcmV0dXJuIChcbiAqICAgIDxkaXY+XG4gKiAgICAgIFRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgbm9kZSBpcyBhdDpcbiAqICAgICAgPHA+eDoge2Fic29sdXRlUG9zaXRpb24ueH08L3A+XG4gKiAgICAgIDxwPnk6IHthYnNvbHV0ZVBvc2l0aW9uLnl9PC9wPlxuICogICAgPC9kaXY+XG4gKiAgKTtcbiAqfVxuICpgYGBcbiAqL1xuZnVuY3Rpb24gdXNlSW50ZXJuYWxOb2RlKGlkKSB7XG4gICAgY29uc3Qgbm9kZSA9IHVzZVN0b3JlKHVzZUNhbGxiYWNrKChzKSA9PiBzLm5vZGVMb29rdXAuZ2V0KGlkKSwgW2lkXSksIHNoYWxsb3cpO1xuICAgIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBMaW5lUGF0dGVybih7IGRpbWVuc2lvbnMsIGxpbmVXaWR0aCwgdmFyaWFudCwgY2xhc3NOYW1lIH0pIHtcbiAgICByZXR1cm4gKGpzeChcInBhdGhcIiwgeyBzdHJva2VXaWR0aDogbGluZVdpZHRoLCBkOiBgTSR7ZGltZW5zaW9uc1swXSAvIDJ9IDAgViR7ZGltZW5zaW9uc1sxXX0gTTAgJHtkaW1lbnNpb25zWzFdIC8gMn0gSCR7ZGltZW5zaW9uc1swXX1gLCBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fYmFja2dyb3VuZC1wYXR0ZXJuJywgdmFyaWFudCwgY2xhc3NOYW1lXSkgfSkpO1xufVxuZnVuY3Rpb24gRG90UGF0dGVybih7IHJhZGl1cywgY2xhc3NOYW1lIH0pIHtcbiAgICByZXR1cm4gKGpzeChcImNpcmNsZVwiLCB7IGN4OiByYWRpdXMsIGN5OiByYWRpdXMsIHI6IHJhZGl1cywgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX2JhY2tncm91bmQtcGF0dGVybicsICdkb3RzJywgY2xhc3NOYW1lXSkgfSkpO1xufVxuXG4vKipcbiAqIFRoZSB0aHJlZSB2YXJpYW50cyBhcmUgZXhwb3J0ZWQgYXMgYW4gZW51bSBmb3IgY29udmVuaWVuY2UuIFlvdSBjYW4gZWl0aGVyIGltcG9ydFxuICogdGhlIGVudW0gYW5kIHVzZSBpdCBsaWtlIGBCYWNrZ3JvdW5kVmFyaWFudC5MaW5lc2Agb3IgeW91IGNhbiB1c2UgdGhlIHJhdyBzdHJpbmdcbiAqIHZhbHVlIGRpcmVjdGx5LlxuICogQHB1YmxpY1xuICovXG52YXIgQmFja2dyb3VuZFZhcmlhbnQ7XG4oZnVuY3Rpb24gKEJhY2tncm91bmRWYXJpYW50KSB7XG4gICAgQmFja2dyb3VuZFZhcmlhbnRbXCJMaW5lc1wiXSA9IFwibGluZXNcIjtcbiAgICBCYWNrZ3JvdW5kVmFyaWFudFtcIkRvdHNcIl0gPSBcImRvdHNcIjtcbiAgICBCYWNrZ3JvdW5kVmFyaWFudFtcIkNyb3NzXCJdID0gXCJjcm9zc1wiO1xufSkoQmFja2dyb3VuZFZhcmlhbnQgfHwgKEJhY2tncm91bmRWYXJpYW50ID0ge30pKTtcblxuY29uc3QgZGVmYXVsdFNpemUgPSB7XG4gICAgW0JhY2tncm91bmRWYXJpYW50LkRvdHNdOiAxLFxuICAgIFtCYWNrZ3JvdW5kVmFyaWFudC5MaW5lc106IDEsXG4gICAgW0JhY2tncm91bmRWYXJpYW50LkNyb3NzXTogNixcbn07XG5jb25zdCBzZWxlY3RvciQzID0gKHMpID0+ICh7IHRyYW5zZm9ybTogcy50cmFuc2Zvcm0sIHBhdHRlcm5JZDogYHBhdHRlcm4tJHtzLnJmSWR9YCB9KTtcbmZ1bmN0aW9uIEJhY2tncm91bmRDb21wb25lbnQoeyBpZCwgdmFyaWFudCA9IEJhY2tncm91bmRWYXJpYW50LkRvdHMsIFxuLy8gb25seSB1c2VkIGZvciBkb3RzIGFuZCBjcm9zc1xuZ2FwID0gMjAsIFxuLy8gb25seSB1c2VkIGZvciBsaW5lcyBhbmQgY3Jvc3NcbnNpemUsIGxpbmVXaWR0aCA9IDEsIG9mZnNldCA9IDAsIGNvbG9yLCBiZ0NvbG9yLCBzdHlsZSwgY2xhc3NOYW1lLCBwYXR0ZXJuQ2xhc3NOYW1lLCB9KSB7XG4gICAgY29uc3QgcmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IHsgdHJhbnNmb3JtLCBwYXR0ZXJuSWQgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJDMsIHNoYWxsb3cpO1xuICAgIGNvbnN0IHBhdHRlcm5TaXplID0gc2l6ZSB8fCBkZWZhdWx0U2l6ZVt2YXJpYW50XTtcbiAgICBjb25zdCBpc0RvdHMgPSB2YXJpYW50ID09PSBCYWNrZ3JvdW5kVmFyaWFudC5Eb3RzO1xuICAgIGNvbnN0IGlzQ3Jvc3MgPSB2YXJpYW50ID09PSBCYWNrZ3JvdW5kVmFyaWFudC5Dcm9zcztcbiAgICBjb25zdCBnYXBYWSA9IEFycmF5LmlzQXJyYXkoZ2FwKSA/IGdhcCA6IFtnYXAsIGdhcF07XG4gICAgY29uc3Qgc2NhbGVkR2FwID0gW2dhcFhZWzBdICogdHJhbnNmb3JtWzJdIHx8IDEsIGdhcFhZWzFdICogdHJhbnNmb3JtWzJdIHx8IDFdO1xuICAgIGNvbnN0IHNjYWxlZFNpemUgPSBwYXR0ZXJuU2l6ZSAqIHRyYW5zZm9ybVsyXTtcbiAgICBjb25zdCBvZmZzZXRYWSA9IEFycmF5LmlzQXJyYXkob2Zmc2V0KSA/IG9mZnNldCA6IFtvZmZzZXQsIG9mZnNldF07XG4gICAgY29uc3QgcGF0dGVybkRpbWVuc2lvbnMgPSBpc0Nyb3NzID8gW3NjYWxlZFNpemUsIHNjYWxlZFNpemVdIDogc2NhbGVkR2FwO1xuICAgIGNvbnN0IHNjYWxlZE9mZnNldCA9IFtcbiAgICAgICAgb2Zmc2V0WFlbMF0gKiB0cmFuc2Zvcm1bMl0gfHwgMSArIHBhdHRlcm5EaW1lbnNpb25zWzBdIC8gMixcbiAgICAgICAgb2Zmc2V0WFlbMV0gKiB0cmFuc2Zvcm1bMl0gfHwgMSArIHBhdHRlcm5EaW1lbnNpb25zWzFdIC8gMixcbiAgICBdO1xuICAgIGNvbnN0IF9wYXR0ZXJuSWQgPSBgJHtwYXR0ZXJuSWR9JHtpZCA/IGlkIDogJyd9YDtcbiAgICByZXR1cm4gKGpzeHMoXCJzdmdcIiwgeyBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fYmFja2dyb3VuZCcsIGNsYXNzTmFtZV0pLCBzdHlsZToge1xuICAgICAgICAgICAgLi4uc3R5bGUsXG4gICAgICAgICAgICAuLi5jb250YWluZXJTdHlsZSxcbiAgICAgICAgICAgICctLXh5LWJhY2tncm91bmQtY29sb3ItcHJvcHMnOiBiZ0NvbG9yLFxuICAgICAgICAgICAgJy0teHktYmFja2dyb3VuZC1wYXR0ZXJuLWNvbG9yLXByb3BzJzogY29sb3IsXG4gICAgICAgIH0sIHJlZjogcmVmLCBcImRhdGEtdGVzdGlkXCI6IFwicmZfX2JhY2tncm91bmRcIiwgY2hpbGRyZW46IFtqc3goXCJwYXR0ZXJuXCIsIHsgaWQ6IF9wYXR0ZXJuSWQsIHg6IHRyYW5zZm9ybVswXSAlIHNjYWxlZEdhcFswXSwgeTogdHJhbnNmb3JtWzFdICUgc2NhbGVkR2FwWzFdLCB3aWR0aDogc2NhbGVkR2FwWzBdLCBoZWlnaHQ6IHNjYWxlZEdhcFsxXSwgcGF0dGVyblVuaXRzOiBcInVzZXJTcGFjZU9uVXNlXCIsIHBhdHRlcm5UcmFuc2Zvcm06IGB0cmFuc2xhdGUoLSR7c2NhbGVkT2Zmc2V0WzBdfSwtJHtzY2FsZWRPZmZzZXRbMV19KWAsIGNoaWxkcmVuOiBpc0RvdHMgPyAoanN4KERvdFBhdHRlcm4sIHsgcmFkaXVzOiBzY2FsZWRTaXplIC8gMiwgY2xhc3NOYW1lOiBwYXR0ZXJuQ2xhc3NOYW1lIH0pKSA6IChqc3goTGluZVBhdHRlcm4sIHsgZGltZW5zaW9uczogcGF0dGVybkRpbWVuc2lvbnMsIGxpbmVXaWR0aDogbGluZVdpZHRoLCB2YXJpYW50OiB2YXJpYW50LCBjbGFzc05hbWU6IHBhdHRlcm5DbGFzc05hbWUgfSkpIH0pLCBqc3goXCJyZWN0XCIsIHsgeDogXCIwXCIsIHk6IFwiMFwiLCB3aWR0aDogXCIxMDAlXCIsIGhlaWdodDogXCIxMDAlXCIsIGZpbGw6IGB1cmwoIyR7X3BhdHRlcm5JZH0pYCB9KV0gfSkpO1xufVxuQmFja2dyb3VuZENvbXBvbmVudC5kaXNwbGF5TmFtZSA9ICdCYWNrZ3JvdW5kJztcbi8qKlxuICogVGhlIGA8QmFja2dyb3VuZCAvPmAgY29tcG9uZW50IG1ha2VzIGl0IGNvbnZlbmllbnQgdG8gcmVuZGVyIGRpZmZlcmVudCB0eXBlcyBvZiBiYWNrZ3JvdW5kcyBjb21tb24gaW4gbm9kZS1iYXNlZCBVSXMuIEl0IGNvbWVzIHdpdGggdGhyZWUgdmFyaWFudHM6IGxpbmVzLCBkb3RzIGFuZCBjcm9zcy5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIEEgc2ltcGxlIGV4YW1wbGUgb2YgaG93IHRvIHVzZSB0aGUgQmFja2dyb3VuZCBjb21wb25lbnQuXG4gKlxuICogYGBgdHN4XG4gKiBpbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbiAqIGltcG9ydCB7IFJlYWN0RmxvdywgQmFja2dyb3VuZCwgQmFja2dyb3VuZFZhcmlhbnQgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKiBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGbG93KCkge1xuICogICByZXR1cm4gKFxuICogICAgIDxSZWFjdEZsb3cgZGVmYXVsdE5vZGVzPXtbLi4uXX0gZGVmYXVsdEVkZ2VzPXtbLi4uXX0+XG4gKiAgICAgICA8QmFja2dyb3VuZCBjb2xvcj1cIiNjY2NcIiB2YXJpYW50PXtCYWNrZ3JvdW5kVmFyaWFudC5Eb3RzfSAvPlxuICogICAgIDwvUmVhY3RGbG93PlxuICogICApO1xuICogfVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBJbiB0aGlzIGV4YW1wbGUgeW91IGNhbiBzZWUgaG93IHRvIGNvbWJpbmUgbXVsdGlwbGUgYmFja2dyb3VuZHNcbiAqXG4gKiBgYGB0c3hcbiAqIGltcG9ydCB7IFJlYWN0RmxvdywgQmFja2dyb3VuZCwgQmFja2dyb3VuZFZhcmlhbnQgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqIGltcG9ydCAnQHh5Zmxvdy9yZWFjdC9kaXN0L3N0eWxlLmNzcyc7XG4gKlxuICogZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRmxvdygpIHtcbiAqICAgcmV0dXJuIChcbiAqICAgICA8UmVhY3RGbG93IGRlZmF1bHROb2Rlcz17Wy4uLl19IGRlZmF1bHRFZGdlcz17Wy4uLl19PlxuICogICAgICAgPEJhY2tncm91bmRcbiAqICAgICAgICAgaWQ9XCIxXCJcbiAqICAgICAgICAgZ2FwPXsxMH1cbiAqICAgICAgICAgY29sb3I9XCIjZjFmMWYxXCJcbiAqICAgICAgICAgdmFyaWFudD17QmFja2dyb3VuZFZhcmlhbnQuTGluZXN9XG4gKiAgICAgICAvPlxuICogICAgICAgPEJhY2tncm91bmRcbiAqICAgICAgICAgaWQ9XCIyXCJcbiAqICAgICAgICAgZ2FwPXsxMDB9XG4gKiAgICAgICAgIGNvbG9yPVwiI2NjY1wiXG4gKiAgICAgICAgIHZhcmlhbnQ9e0JhY2tncm91bmRWYXJpYW50LkxpbmVzfVxuICogICAgICAgLz5cbiAqICAgICA8L1JlYWN0Rmxvdz5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEByZW1hcmtzXG4gKlxuICogV2hlbiBjb21iaW5pbmcgbXVsdGlwbGUgPEJhY2tncm91bmQgLz4gY29tcG9uZW50cyBpdOKAmXMgaW1wb3J0YW50IHRvIGdpdmUgZWFjaCBvZiB0aGVtIGEgdW5pcXVlIGlkIHByb3AhXG4gKlxuICovXG5jb25zdCBCYWNrZ3JvdW5kID0gbWVtbyhCYWNrZ3JvdW5kQ29tcG9uZW50KTtcblxuZnVuY3Rpb24gUGx1c0ljb24oKSB7XG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2aWV3Qm94OiBcIjAgMCAzMiAzMlwiLCBjaGlsZHJlbjoganN4KFwicGF0aFwiLCB7IGQ6IFwiTTMyIDE4LjEzM0gxOC4xMzNWMzJoLTQuMjY2VjE4LjEzM0gwdi00LjI2NmgxMy44NjdWMGg0LjI2NnYxMy44NjdIMzJ6XCIgfSkgfSkpO1xufVxuXG5mdW5jdGlvbiBNaW51c0ljb24oKSB7XG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2aWV3Qm94OiBcIjAgMCAzMiA1XCIsIGNoaWxkcmVuOiBqc3goXCJwYXRoXCIsIHsgZDogXCJNMCAwaDMydjQuMkgwelwiIH0pIH0pKTtcbn1cblxuZnVuY3Rpb24gRml0Vmlld0ljb24oKSB7XG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2aWV3Qm94OiBcIjAgMCAzMiAzMFwiLCBjaGlsZHJlbjoganN4KFwicGF0aFwiLCB7IGQ6IFwiTTMuNjkyIDQuNjNjMC0uNTMuNC0uOTM4LjkzOS0uOTM4aDUuMjE1VjBINC43MDhDMi4xMyAwIDAgMi4wNTQgMCA0LjYzdjUuMjE2aDMuNjkyVjQuNjMxek0yNy4zNTQgMGgtNS4ydjMuNjkyaDUuMTdjLjUzIDAgLjk4NC40Ljk4NC45Mzl2NS4yMTVIMzJWNC42MzFBNC42MjQgNC42MjQgMCAwMDI3LjM1NCAwem0uOTU0IDI0LjgzYzAgLjUzMi0uNC45NC0uOTM5Ljk0aC01LjIxNXYzLjc2OGg1LjIxNWMyLjU3NyAwIDQuNjMxLTIuMTMgNC42MzEtNC43MDd2LTUuMTM5aC0zLjY5MnY1LjEzOXptLTIzLjY3Ny45NGMtLjUzMSAwLS45MzktLjQtLjkzOS0uOTR2LTUuMTM4SDB2NS4xMzljMCAyLjU3NyAyLjEzIDQuNzA3IDQuNzA4IDQuNzA3aDUuMTM4VjI1Ljc3SDQuNjMxelwiIH0pIH0pKTtcbn1cblxuZnVuY3Rpb24gTG9ja0ljb24oKSB7XG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2aWV3Qm94OiBcIjAgMCAyNSAzMlwiLCBjaGlsZHJlbjoganN4KFwicGF0aFwiLCB7IGQ6IFwiTTIxLjMzMyAxMC42NjdIMTkuODFWNy42MTlDMTkuODEgMy40MjkgMTYuMzggMCAxMi4xOSAwIDggMCA0LjU3MSAzLjQyOSA0LjU3MSA3LjYxOXYzLjA0OEgzLjA0OEEzLjA1NiAzLjA1NiAwIDAwMCAxMy43MTR2MTUuMjM4QTMuMDU2IDMuMDU2IDAgMDAzLjA0OCAzMmgxOC4yODVhMy4wNTYgMy4wNTYgMCAwMDMuMDQ4LTMuMDQ4VjEzLjcxNGEzLjA1NiAzLjA1NiAwIDAwLTMuMDQ4LTMuMDQ3ek0xMi4xOSAyNC41MzNhMy4wNTYgMy4wNTYgMCAwMS0zLjA0Ny0zLjA0NyAzLjA1NiAzLjA1NiAwIDAxMy4wNDctMy4wNDggMy4wNTYgMy4wNTYgMCAwMTMuMDQ4IDMuMDQ4IDMuMDU2IDMuMDU2IDAgMDEtMy4wNDggMy4wNDd6bTQuNzI0LTEzLjg2Nkg3LjQ2N1Y3LjYxOWMwLTIuNTkgMi4xMzMtNC43MjQgNC43MjMtNC43MjQgMi41OTEgMCA0LjcyNCAyLjEzMyA0LjcyNCA0LjcyNHYzLjA0OHpcIiB9KSB9KSk7XG59XG5cbmZ1bmN0aW9uIFVubG9ja0ljb24oKSB7XG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2aWV3Qm94OiBcIjAgMCAyNSAzMlwiLCBjaGlsZHJlbjoganN4KFwicGF0aFwiLCB7IGQ6IFwiTTIxLjMzMyAxMC42NjdIMTkuODFWNy42MTlDMTkuODEgMy40MjkgMTYuMzggMCAxMi4xOSAwYy00LjExNCAxLjgyOC0xLjM3IDIuMTMzLjMwNSAyLjQzOCAxLjY3Ni4zMDUgNC40MiAyLjU5IDQuNDIgNS4xODF2My4wNDhIMy4wNDdBMy4wNTYgMy4wNTYgMCAwMDAgMTMuNzE0djE1LjIzOEEzLjA1NiAzLjA1NiAwIDAwMy4wNDggMzJoMTguMjg1YTMuMDU2IDMuMDU2IDAgMDAzLjA0OC0zLjA0OFYxMy43MTRhMy4wNTYgMy4wNTYgMCAwMC0zLjA0OC0zLjA0N3pNMTIuMTkgMjQuNTMzYTMuMDU2IDMuMDU2IDAgMDEtMy4wNDctMy4wNDcgMy4wNTYgMy4wNTYgMCAwMTMuMDQ3LTMuMDQ4IDMuMDU2IDMuMDU2IDAgMDEzLjA0OCAzLjA0OCAzLjA1NiAzLjA1NiAwIDAxLTMuMDQ4IDMuMDQ3elwiIH0pIH0pKTtcbn1cblxuLyoqXG4gKiBZb3UgY2FuIGFkZCBidXR0b25zIHRvIHRoZSBjb250cm9sIHBhbmVsIGJ5IHVzaW5nIHRoZSBgPENvbnRyb2xCdXR0b24gLz5gIGNvbXBvbmVudFxuICogYW5kIHBhc3MgaXQgYXMgYSBjaGlsZCB0byB0aGUgW2A8Q29udHJvbHMgLz5gXSgvYXBpLXJlZmVyZW5jZS9jb21wb25lbnRzL2NvbnRyb2xzKSBjb21wb25lbnQuXG4gKlxuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqYGBganN4XG4gKmltcG9ydCB7IE1hZ2ljV2FuZCB9IGZyb20gJ0ByYWRpeC11aS9yZWFjdC1pY29ucydcbiAqaW1wb3J0IHsgUmVhY3RGbG93LCBDb250cm9scywgQ29udHJvbEJ1dHRvbiB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnXG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGbG93KCkge1xuICogIHJldHVybiAoXG4gKiAgICA8UmVhY3RGbG93IG5vZGVzPXtbLi4uXX0gZWRnZXM9e1suLi5dfT5cbiAqICAgICAgPENvbnRyb2xzPlxuICogICAgICAgIDxDb250cm9sQnV0dG9uIG9uQ2xpY2s9eygpID0+IGFsZXJ0KCdTb21ldGhpbmcgbWFnaWNhbCBqdXN0IGhhcHBlbmVkLiDinKgnKX0+XG4gKiAgICAgICAgICA8TWFnaWNXYW5kIC8+XG4gKiAgICAgICAgPC9Db250cm9sQnV0dG9uPlxuICogICAgICA8L0NvbnRyb2xzPlxuICogICAgPC9SZWFjdEZsb3c+XG4gKiAgKVxuICp9XG4gKmBgYFxuICovXG5mdW5jdGlvbiBDb250cm9sQnV0dG9uKHsgY2hpbGRyZW4sIGNsYXNzTmFtZSwgLi4ucmVzdCB9KSB7XG4gICAgcmV0dXJuIChqc3goXCJidXR0b25cIiwgeyB0eXBlOiBcImJ1dHRvblwiLCBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fY29udHJvbHMtYnV0dG9uJywgY2xhc3NOYW1lXSksIC4uLnJlc3QsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59XG5cbmNvbnN0IHNlbGVjdG9yJDIgPSAocykgPT4gKHtcbiAgICBpc0ludGVyYWN0aXZlOiBzLm5vZGVzRHJhZ2dhYmxlIHx8IHMubm9kZXNDb25uZWN0YWJsZSB8fCBzLmVsZW1lbnRzU2VsZWN0YWJsZSxcbiAgICBtaW5ab29tUmVhY2hlZDogcy50cmFuc2Zvcm1bMl0gPD0gcy5taW5ab29tLFxuICAgIG1heFpvb21SZWFjaGVkOiBzLnRyYW5zZm9ybVsyXSA+PSBzLm1heFpvb20sXG4gICAgYXJpYUxhYmVsQ29uZmlnOiBzLmFyaWFMYWJlbENvbmZpZyxcbn0pO1xuZnVuY3Rpb24gQ29udHJvbHNDb21wb25lbnQoeyBzdHlsZSwgc2hvd1pvb20gPSB0cnVlLCBzaG93Rml0VmlldyA9IHRydWUsIHNob3dJbnRlcmFjdGl2ZSA9IHRydWUsIGZpdFZpZXdPcHRpb25zLCBvblpvb21Jbiwgb25ab29tT3V0LCBvbkZpdFZpZXcsIG9uSW50ZXJhY3RpdmVDaGFuZ2UsIGNsYXNzTmFtZSwgY2hpbGRyZW4sIHBvc2l0aW9uID0gJ2JvdHRvbS1sZWZ0Jywgb3JpZW50YXRpb24gPSAndmVydGljYWwnLCAnYXJpYS1sYWJlbCc6IGFyaWFMYWJlbCwgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCB7IGlzSW50ZXJhY3RpdmUsIG1pblpvb21SZWFjaGVkLCBtYXhab29tUmVhY2hlZCwgYXJpYUxhYmVsQ29uZmlnIH0gPSB1c2VTdG9yZShzZWxlY3RvciQyLCBzaGFsbG93KTtcbiAgICBjb25zdCB7IHpvb21Jbiwgem9vbU91dCwgZml0VmlldyB9ID0gdXNlUmVhY3RGbG93KCk7XG4gICAgY29uc3Qgb25ab29tSW5IYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICB6b29tSW4oKTtcbiAgICAgICAgb25ab29tSW4/LigpO1xuICAgIH07XG4gICAgY29uc3Qgb25ab29tT3V0SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgem9vbU91dCgpO1xuICAgICAgICBvblpvb21PdXQ/LigpO1xuICAgIH07XG4gICAgY29uc3Qgb25GaXRWaWV3SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgZml0VmlldyhmaXRWaWV3T3B0aW9ucyk7XG4gICAgICAgIG9uRml0Vmlldz8uKCk7XG4gICAgfTtcbiAgICBjb25zdCBvblRvZ2dsZUludGVyYWN0aXZpdHkgPSAoKSA9PiB7XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHtcbiAgICAgICAgICAgIG5vZGVzRHJhZ2dhYmxlOiAhaXNJbnRlcmFjdGl2ZSxcbiAgICAgICAgICAgIG5vZGVzQ29ubmVjdGFibGU6ICFpc0ludGVyYWN0aXZlLFxuICAgICAgICAgICAgZWxlbWVudHNTZWxlY3RhYmxlOiAhaXNJbnRlcmFjdGl2ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIG9uSW50ZXJhY3RpdmVDaGFuZ2U/LighaXNJbnRlcmFjdGl2ZSk7XG4gICAgfTtcbiAgICBjb25zdCBvcmllbnRhdGlvbkNsYXNzID0gb3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJyA/ICdob3Jpem9udGFsJyA6ICd2ZXJ0aWNhbCc7XG4gICAgcmV0dXJuIChqc3hzKFBhbmVsLCB7IGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19jb250cm9scycsIG9yaWVudGF0aW9uQ2xhc3MsIGNsYXNzTmFtZV0pLCBwb3NpdGlvbjogcG9zaXRpb24sIHN0eWxlOiBzdHlsZSwgXCJkYXRhLXRlc3RpZFwiOiBcInJmX19jb250cm9sc1wiLCBcImFyaWEtbGFiZWxcIjogYXJpYUxhYmVsID8/IGFyaWFMYWJlbENvbmZpZ1snY29udHJvbHMuYXJpYUxhYmVsJ10sIGNoaWxkcmVuOiBbc2hvd1pvb20gJiYgKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtqc3goQ29udHJvbEJ1dHRvbiwgeyBvbkNsaWNrOiBvblpvb21JbkhhbmRsZXIsIGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19jb250cm9scy16b29taW5cIiwgdGl0bGU6IGFyaWFMYWJlbENvbmZpZ1snY29udHJvbHMuem9vbUluLmFyaWFMYWJlbCddLCBcImFyaWEtbGFiZWxcIjogYXJpYUxhYmVsQ29uZmlnWydjb250cm9scy56b29tSW4uYXJpYUxhYmVsJ10sIGRpc2FibGVkOiBtYXhab29tUmVhY2hlZCwgY2hpbGRyZW46IGpzeChQbHVzSWNvbiwge30pIH0pLCBqc3goQ29udHJvbEJ1dHRvbiwgeyBvbkNsaWNrOiBvblpvb21PdXRIYW5kbGVyLCBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fY29udHJvbHMtem9vbW91dFwiLCB0aXRsZTogYXJpYUxhYmVsQ29uZmlnWydjb250cm9scy56b29tT3V0LmFyaWFMYWJlbCddLCBcImFyaWEtbGFiZWxcIjogYXJpYUxhYmVsQ29uZmlnWydjb250cm9scy56b29tT3V0LmFyaWFMYWJlbCddLCBkaXNhYmxlZDogbWluWm9vbVJlYWNoZWQsIGNoaWxkcmVuOiBqc3goTWludXNJY29uLCB7fSkgfSldIH0pKSwgc2hvd0ZpdFZpZXcgJiYgKGpzeChDb250cm9sQnV0dG9uLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19jb250cm9scy1maXR2aWV3XCIsIG9uQ2xpY2s6IG9uRml0Vmlld0hhbmRsZXIsIHRpdGxlOiBhcmlhTGFiZWxDb25maWdbJ2NvbnRyb2xzLmZpdFZpZXcuYXJpYUxhYmVsJ10sIFwiYXJpYS1sYWJlbFwiOiBhcmlhTGFiZWxDb25maWdbJ2NvbnRyb2xzLmZpdFZpZXcuYXJpYUxhYmVsJ10sIGNoaWxkcmVuOiBqc3goRml0Vmlld0ljb24sIHt9KSB9KSksIHNob3dJbnRlcmFjdGl2ZSAmJiAoanN4KENvbnRyb2xCdXR0b24sIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2NvbnRyb2xzLWludGVyYWN0aXZlXCIsIG9uQ2xpY2s6IG9uVG9nZ2xlSW50ZXJhY3Rpdml0eSwgdGl0bGU6IGFyaWFMYWJlbENvbmZpZ1snY29udHJvbHMuaW50ZXJhY3RpdmUuYXJpYUxhYmVsJ10sIFwiYXJpYS1sYWJlbFwiOiBhcmlhTGFiZWxDb25maWdbJ2NvbnRyb2xzLmludGVyYWN0aXZlLmFyaWFMYWJlbCddLCBjaGlsZHJlbjogaXNJbnRlcmFjdGl2ZSA/IGpzeChVbmxvY2tJY29uLCB7fSkgOiBqc3goTG9ja0ljb24sIHt9KSB9KSksIGNoaWxkcmVuXSB9KSk7XG59XG5Db250cm9sc0NvbXBvbmVudC5kaXNwbGF5TmFtZSA9ICdDb250cm9scyc7XG4vKipcbiAqIFRoZSBgPENvbnRyb2xzIC8+YCBjb21wb25lbnQgcmVuZGVycyBhIHNtYWxsIHBhbmVsIHRoYXQgY29udGFpbnMgY29udmVuaWVudFxuICogYnV0dG9ucyB0byB6b29tIGluLCB6b29tIG91dCwgZml0IHRoZSB2aWV3LCBhbmQgbG9jayB0aGUgdmlld3BvcnQuXG4gKlxuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqYGBgdHN4XG4gKmltcG9ydCB7IFJlYWN0RmxvdywgQ29udHJvbHMgfSBmcm9tICdAeHlmbG93L3JlYWN0J1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRmxvdygpIHtcbiAqICByZXR1cm4gKFxuICogICAgPFJlYWN0RmxvdyBub2Rlcz17Wy4uLl19IGVkZ2VzPXtbLi4uXX0+XG4gKiAgICAgIDxDb250cm9scyAvPlxuICogICAgPC9SZWFjdEZsb3c+XG4gKiAgKVxuICp9XG4gKmBgYFxuICpcbiAqIEByZW1hcmtzIFRvIGV4dGVuZCBvciBjdXN0b21pc2UgdGhlIGNvbnRyb2xzLCB5b3UgY2FuIHVzZSB0aGUgW2A8Q29udHJvbEJ1dHRvbiAvPmBdKC9hcGktcmVmZXJlbmNlL2NvbXBvbmVudHMvY29udHJvbC1idXR0b24pIGNvbXBvbmVudFxuICpcbiAqL1xuY29uc3QgQ29udHJvbHMgPSBtZW1vKENvbnRyb2xzQ29tcG9uZW50KTtcblxuZnVuY3Rpb24gTWluaU1hcE5vZGVDb21wb25lbnQoeyBpZCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgc3R5bGUsIGNvbG9yLCBzdHJva2VDb2xvciwgc3Ryb2tlV2lkdGgsIGNsYXNzTmFtZSwgYm9yZGVyUmFkaXVzLCBzaGFwZVJlbmRlcmluZywgc2VsZWN0ZWQsIG9uQ2xpY2ssIH0pIHtcbiAgICBjb25zdCB7IGJhY2tncm91bmQsIGJhY2tncm91bmRDb2xvciB9ID0gc3R5bGUgfHwge307XG4gICAgY29uc3QgZmlsbCA9IChjb2xvciB8fCBiYWNrZ3JvdW5kIHx8IGJhY2tncm91bmRDb2xvcik7XG4gICAgcmV0dXJuIChqc3goXCJyZWN0XCIsIHsgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX21pbmltYXAtbm9kZScsIHsgc2VsZWN0ZWQgfSwgY2xhc3NOYW1lXSksIHg6IHgsIHk6IHksIHJ4OiBib3JkZXJSYWRpdXMsIHJ5OiBib3JkZXJSYWRpdXMsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQsIHN0eWxlOiB7XG4gICAgICAgICAgICBmaWxsLFxuICAgICAgICAgICAgc3Ryb2tlOiBzdHJva2VDb2xvcixcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgICB9LCBzaGFwZVJlbmRlcmluZzogc2hhcGVSZW5kZXJpbmcsIG9uQ2xpY2s6IG9uQ2xpY2sgPyAoZXZlbnQpID0+IG9uQ2xpY2soZXZlbnQsIGlkKSA6IHVuZGVmaW5lZCB9KSk7XG59XG5jb25zdCBNaW5pTWFwTm9kZSA9IG1lbW8oTWluaU1hcE5vZGVDb21wb25lbnQpO1xuXG5jb25zdCBzZWxlY3Rvck5vZGVJZHMgPSAocykgPT4gcy5ub2Rlcy5tYXAoKG5vZGUpID0+IG5vZGUuaWQpO1xuY29uc3QgZ2V0QXR0ckZ1bmN0aW9uID0gKGZ1bmMpID0+IGZ1bmMgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGZ1bmMgOiAoKSA9PiBmdW5jO1xuZnVuY3Rpb24gTWluaU1hcE5vZGVzKHsgbm9kZVN0cm9rZUNvbG9yLCBub2RlQ29sb3IsIG5vZGVDbGFzc05hbWUgPSAnJywgbm9kZUJvcmRlclJhZGl1cyA9IDUsIG5vZGVTdHJva2VXaWR0aCwgXG4vKlxuICogV2UgbmVlZCB0byByZW5hbWUgdGhlIHByb3AgdG8gYmUgYENhcGl0YWxDYXNlYCBzbyB0aGF0IEpTWCB3aWxsIHJlbmRlciBpdCBhc1xuICogYSBjb21wb25lbnQgcHJvcGVybHkuXG4gKi9cbm5vZGVDb21wb25lbnQ6IE5vZGVDb21wb25lbnQgPSBNaW5pTWFwTm9kZSwgb25DbGljaywgfSkge1xuICAgIGNvbnN0IG5vZGVJZHMgPSB1c2VTdG9yZShzZWxlY3Rvck5vZGVJZHMsIHNoYWxsb3cpO1xuICAgIGNvbnN0IG5vZGVDb2xvckZ1bmMgPSBnZXRBdHRyRnVuY3Rpb24obm9kZUNvbG9yKTtcbiAgICBjb25zdCBub2RlU3Ryb2tlQ29sb3JGdW5jID0gZ2V0QXR0ckZ1bmN0aW9uKG5vZGVTdHJva2VDb2xvcik7XG4gICAgY29uc3Qgbm9kZUNsYXNzTmFtZUZ1bmMgPSBnZXRBdHRyRnVuY3Rpb24obm9kZUNsYXNzTmFtZSk7XG4gICAgY29uc3Qgc2hhcGVSZW5kZXJpbmcgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhIXdpbmRvdy5jaHJvbWUgPyAnY3Jpc3BFZGdlcycgOiAnZ2VvbWV0cmljUHJlY2lzaW9uJztcbiAgICByZXR1cm4gKGpzeChGcmFnbWVudCwgeyBjaGlsZHJlbjogbm9kZUlkcy5tYXAoKG5vZGVJZCkgPT4gKFxuICAgICAgICAvKlxuICAgICAgICAgKiBUaGUgc3BsaXQgb2YgcmVzcG9uc2liaWxpdGllcyBiZXR3ZWVuIE1pbmlNYXBOb2RlcyBhbmRcbiAgICAgICAgICogTm9kZUNvbXBvbmVudFdyYXBwZXIgbWF5IGFwcGVhciB3ZWlyZC4gSG93ZXZlciwgaXTigJlzIGRlc2lnbmVkIHRvXG4gICAgICAgICAqIG1pbmltaXplIHRoZSBjb3N0IG9mIHVwZGF0ZXMgd2hlbiBpbmRpdmlkdWFsIG5vZGVzIGNoYW5nZS5cbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgZGV0YWlscywgc2VlIGEgc2ltaWxhciBjb21taXQgaW4gYE5vZGVSZW5kZXJlci9pbmRleC50c3hgLlxuICAgICAgICAgKi9cbiAgICAgICAganN4KE5vZGVDb21wb25lbnRXcmFwcGVyLCB7IGlkOiBub2RlSWQsIG5vZGVDb2xvckZ1bmM6IG5vZGVDb2xvckZ1bmMsIG5vZGVTdHJva2VDb2xvckZ1bmM6IG5vZGVTdHJva2VDb2xvckZ1bmMsIG5vZGVDbGFzc05hbWVGdW5jOiBub2RlQ2xhc3NOYW1lRnVuYywgbm9kZUJvcmRlclJhZGl1czogbm9kZUJvcmRlclJhZGl1cywgbm9kZVN0cm9rZVdpZHRoOiBub2RlU3Ryb2tlV2lkdGgsIE5vZGVDb21wb25lbnQ6IE5vZGVDb21wb25lbnQsIG9uQ2xpY2s6IG9uQ2xpY2ssIHNoYXBlUmVuZGVyaW5nOiBzaGFwZVJlbmRlcmluZyB9LCBub2RlSWQpKSkgfSkpO1xufVxuZnVuY3Rpb24gTm9kZUNvbXBvbmVudFdyYXBwZXJJbm5lcih7IGlkLCBub2RlQ29sb3JGdW5jLCBub2RlU3Ryb2tlQ29sb3JGdW5jLCBub2RlQ2xhc3NOYW1lRnVuYywgbm9kZUJvcmRlclJhZGl1cywgbm9kZVN0cm9rZVdpZHRoLCBzaGFwZVJlbmRlcmluZywgTm9kZUNvbXBvbmVudCwgb25DbGljaywgfSkge1xuICAgIGNvbnN0IHsgbm9kZSwgeCwgeSwgd2lkdGgsIGhlaWdodCB9ID0gdXNlU3RvcmUoKHMpID0+IHtcbiAgICAgICAgY29uc3QgeyBpbnRlcm5hbHMgfSA9IHMubm9kZUxvb2t1cC5nZXQoaWQpO1xuICAgICAgICBjb25zdCBub2RlID0gaW50ZXJuYWxzLnVzZXJOb2RlO1xuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IGludGVybmFscy5wb3NpdGlvbkFic29sdXRlO1xuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGdldE5vZGVEaW1lbnNpb25zKG5vZGUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICB5LFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgIH07XG4gICAgfSwgc2hhbGxvdyk7XG4gICAgaWYgKCFub2RlIHx8IG5vZGUuaGlkZGVuIHx8ICFub2RlSGFzRGltZW5zaW9ucyhub2RlKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChqc3goTm9kZUNvbXBvbmVudCwgeyB4OiB4LCB5OiB5LCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LCBzdHlsZTogbm9kZS5zdHlsZSwgc2VsZWN0ZWQ6ICEhbm9kZS5zZWxlY3RlZCwgY2xhc3NOYW1lOiBub2RlQ2xhc3NOYW1lRnVuYyhub2RlKSwgY29sb3I6IG5vZGVDb2xvckZ1bmMobm9kZSksIGJvcmRlclJhZGl1czogbm9kZUJvcmRlclJhZGl1cywgc3Ryb2tlQ29sb3I6IG5vZGVTdHJva2VDb2xvckZ1bmMobm9kZSksIHN0cm9rZVdpZHRoOiBub2RlU3Ryb2tlV2lkdGgsIHNoYXBlUmVuZGVyaW5nOiBzaGFwZVJlbmRlcmluZywgb25DbGljazogb25DbGljaywgaWQ6IG5vZGUuaWQgfSkpO1xufVxuY29uc3QgTm9kZUNvbXBvbmVudFdyYXBwZXIgPSBtZW1vKE5vZGVDb21wb25lbnRXcmFwcGVySW5uZXIpO1xudmFyIE1pbmlNYXBOb2RlcyQxID0gbWVtbyhNaW5pTWFwTm9kZXMpO1xuXG5jb25zdCBkZWZhdWx0V2lkdGggPSAyMDA7XG5jb25zdCBkZWZhdWx0SGVpZ2h0ID0gMTUwO1xuY29uc3QgZmlsdGVySGlkZGVuID0gKG5vZGUpID0+ICFub2RlLmhpZGRlbjtcbmNvbnN0IHNlbGVjdG9yJDEgPSAocykgPT4ge1xuICAgIGNvbnN0IHZpZXdCQiA9IHtcbiAgICAgICAgeDogLXMudHJhbnNmb3JtWzBdIC8gcy50cmFuc2Zvcm1bMl0sXG4gICAgICAgIHk6IC1zLnRyYW5zZm9ybVsxXSAvIHMudHJhbnNmb3JtWzJdLFxuICAgICAgICB3aWR0aDogcy53aWR0aCAvIHMudHJhbnNmb3JtWzJdLFxuICAgICAgICBoZWlnaHQ6IHMuaGVpZ2h0IC8gcy50cmFuc2Zvcm1bMl0sXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICB2aWV3QkIsXG4gICAgICAgIGJvdW5kaW5nUmVjdDogcy5ub2RlTG9va3VwLnNpemUgPiAwXG4gICAgICAgICAgICA/IGdldEJvdW5kc09mUmVjdHMoZ2V0SW50ZXJuYWxOb2Rlc0JvdW5kcyhzLm5vZGVMb29rdXAsIHsgZmlsdGVyOiBmaWx0ZXJIaWRkZW4gfSksIHZpZXdCQilcbiAgICAgICAgICAgIDogdmlld0JCLFxuICAgICAgICByZklkOiBzLnJmSWQsXG4gICAgICAgIHBhblpvb206IHMucGFuWm9vbSxcbiAgICAgICAgdHJhbnNsYXRlRXh0ZW50OiBzLnRyYW5zbGF0ZUV4dGVudCxcbiAgICAgICAgZmxvd1dpZHRoOiBzLndpZHRoLFxuICAgICAgICBmbG93SGVpZ2h0OiBzLmhlaWdodCxcbiAgICAgICAgYXJpYUxhYmVsQ29uZmlnOiBzLmFyaWFMYWJlbENvbmZpZyxcbiAgICB9O1xufTtcbmNvbnN0IEFSSUFfTEFCRUxfS0VZID0gJ3JlYWN0LWZsb3dfX21pbmltYXAtZGVzYyc7XG5mdW5jdGlvbiBNaW5pTWFwQ29tcG9uZW50KHsgc3R5bGUsIGNsYXNzTmFtZSwgbm9kZVN0cm9rZUNvbG9yLCBub2RlQ29sb3IsIG5vZGVDbGFzc05hbWUgPSAnJywgbm9kZUJvcmRlclJhZGl1cyA9IDUsIG5vZGVTdHJva2VXaWR0aCwgXG4vKlxuICogV2UgbmVlZCB0byByZW5hbWUgdGhlIHByb3AgdG8gYmUgYENhcGl0YWxDYXNlYCBzbyB0aGF0IEpTWCB3aWxsIHJlbmRlciBpdCBhc1xuICogYSBjb21wb25lbnQgcHJvcGVybHkuXG4gKi9cbm5vZGVDb21wb25lbnQsIGJnQ29sb3IsIG1hc2tDb2xvciwgbWFza1N0cm9rZUNvbG9yLCBtYXNrU3Ryb2tlV2lkdGgsIHBvc2l0aW9uID0gJ2JvdHRvbS1yaWdodCcsIG9uQ2xpY2ssIG9uTm9kZUNsaWNrLCBwYW5uYWJsZSA9IGZhbHNlLCB6b29tYWJsZSA9IGZhbHNlLCBhcmlhTGFiZWwsIGludmVyc2VQYW4sIHpvb21TdGVwID0gMTAsIG9mZnNldFNjYWxlID0gNSwgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCBzdmcgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgeyBib3VuZGluZ1JlY3QsIHZpZXdCQiwgcmZJZCwgcGFuWm9vbSwgdHJhbnNsYXRlRXh0ZW50LCBmbG93V2lkdGgsIGZsb3dIZWlnaHQsIGFyaWFMYWJlbENvbmZpZyB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkMSwgc2hhbGxvdyk7XG4gICAgY29uc3QgZWxlbWVudFdpZHRoID0gc3R5bGU/LndpZHRoID8/IGRlZmF1bHRXaWR0aDtcbiAgICBjb25zdCBlbGVtZW50SGVpZ2h0ID0gc3R5bGU/LmhlaWdodCA/PyBkZWZhdWx0SGVpZ2h0O1xuICAgIGNvbnN0IHNjYWxlZFdpZHRoID0gYm91bmRpbmdSZWN0LndpZHRoIC8gZWxlbWVudFdpZHRoO1xuICAgIGNvbnN0IHNjYWxlZEhlaWdodCA9IGJvdW5kaW5nUmVjdC5oZWlnaHQgLyBlbGVtZW50SGVpZ2h0O1xuICAgIGNvbnN0IHZpZXdTY2FsZSA9IE1hdGgubWF4KHNjYWxlZFdpZHRoLCBzY2FsZWRIZWlnaHQpO1xuICAgIGNvbnN0IHZpZXdXaWR0aCA9IHZpZXdTY2FsZSAqIGVsZW1lbnRXaWR0aDtcbiAgICBjb25zdCB2aWV3SGVpZ2h0ID0gdmlld1NjYWxlICogZWxlbWVudEhlaWdodDtcbiAgICBjb25zdCBvZmZzZXQgPSBvZmZzZXRTY2FsZSAqIHZpZXdTY2FsZTtcbiAgICBjb25zdCB4ID0gYm91bmRpbmdSZWN0LnggLSAodmlld1dpZHRoIC0gYm91bmRpbmdSZWN0LndpZHRoKSAvIDIgLSBvZmZzZXQ7XG4gICAgY29uc3QgeSA9IGJvdW5kaW5nUmVjdC55IC0gKHZpZXdIZWlnaHQgLSBib3VuZGluZ1JlY3QuaGVpZ2h0KSAvIDIgLSBvZmZzZXQ7XG4gICAgY29uc3Qgd2lkdGggPSB2aWV3V2lkdGggKyBvZmZzZXQgKiAyO1xuICAgIGNvbnN0IGhlaWdodCA9IHZpZXdIZWlnaHQgKyBvZmZzZXQgKiAyO1xuICAgIGNvbnN0IGxhYmVsbGVkQnkgPSBgJHtBUklBX0xBQkVMX0tFWX0tJHtyZklkfWA7XG4gICAgY29uc3Qgdmlld1NjYWxlUmVmID0gdXNlUmVmKDApO1xuICAgIGNvbnN0IG1pbmltYXBJbnN0YW5jZSA9IHVzZVJlZigpO1xuICAgIHZpZXdTY2FsZVJlZi5jdXJyZW50ID0gdmlld1NjYWxlO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChzdmcuY3VycmVudCAmJiBwYW5ab29tKSB7XG4gICAgICAgICAgICBtaW5pbWFwSW5zdGFuY2UuY3VycmVudCA9IFhZTWluaW1hcCh7XG4gICAgICAgICAgICAgICAgZG9tTm9kZTogc3ZnLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgcGFuWm9vbSxcbiAgICAgICAgICAgICAgICBnZXRUcmFuc2Zvcm06ICgpID0+IHN0b3JlLmdldFN0YXRlKCkudHJhbnNmb3JtLFxuICAgICAgICAgICAgICAgIGdldFZpZXdTY2FsZTogKCkgPT4gdmlld1NjYWxlUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbWluaW1hcEluc3RhbmNlLmN1cnJlbnQ/LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LCBbcGFuWm9vbV0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIG1pbmltYXBJbnN0YW5jZS5jdXJyZW50Py51cGRhdGUoe1xuICAgICAgICAgICAgdHJhbnNsYXRlRXh0ZW50LFxuICAgICAgICAgICAgd2lkdGg6IGZsb3dXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogZmxvd0hlaWdodCxcbiAgICAgICAgICAgIGludmVyc2VQYW4sXG4gICAgICAgICAgICBwYW5uYWJsZSxcbiAgICAgICAgICAgIHpvb21TdGVwLFxuICAgICAgICAgICAgem9vbWFibGUsXG4gICAgICAgIH0pO1xuICAgIH0sIFtwYW5uYWJsZSwgem9vbWFibGUsIGludmVyc2VQYW4sIHpvb21TdGVwLCB0cmFuc2xhdGVFeHRlbnQsIGZsb3dXaWR0aCwgZmxvd0hlaWdodF0pO1xuICAgIGNvbnN0IG9uU3ZnQ2xpY2sgPSBvbkNsaWNrXG4gICAgICAgID8gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBbeCwgeV0gPSBtaW5pbWFwSW5zdGFuY2UuY3VycmVudD8ucG9pbnRlcihldmVudCkgfHwgWzAsIDBdO1xuICAgICAgICAgICAgb25DbGljayhldmVudCwgeyB4LCB5IH0pO1xuICAgICAgICB9XG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9uU3ZnTm9kZUNsaWNrID0gb25Ob2RlQ2xpY2tcbiAgICAgICAgPyB1c2VDYWxsYmFjaygoZXZlbnQsIG5vZGVJZCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHN0b3JlLmdldFN0YXRlKCkubm9kZUxvb2t1cC5nZXQobm9kZUlkKS5pbnRlcm5hbHMudXNlck5vZGU7XG4gICAgICAgICAgICBvbk5vZGVDbGljayhldmVudCwgbm9kZSk7XG4gICAgICAgIH0sIFtdKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBfYXJpYUxhYmVsID0gYXJpYUxhYmVsID8/IGFyaWFMYWJlbENvbmZpZ1snbWluaW1hcC5hcmlhTGFiZWwnXTtcbiAgICByZXR1cm4gKGpzeChQYW5lbCwgeyBwb3NpdGlvbjogcG9zaXRpb24sIHN0eWxlOiB7XG4gICAgICAgICAgICAuLi5zdHlsZSxcbiAgICAgICAgICAgICctLXh5LW1pbmltYXAtYmFja2dyb3VuZC1jb2xvci1wcm9wcyc6IHR5cGVvZiBiZ0NvbG9yID09PSAnc3RyaW5nJyA/IGJnQ29sb3IgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnLS14eS1taW5pbWFwLW1hc2stYmFja2dyb3VuZC1jb2xvci1wcm9wcyc6IHR5cGVvZiBtYXNrQ29sb3IgPT09ICdzdHJpbmcnID8gbWFza0NvbG9yIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJy0teHktbWluaW1hcC1tYXNrLXN0cm9rZS1jb2xvci1wcm9wcyc6IHR5cGVvZiBtYXNrU3Ryb2tlQ29sb3IgPT09ICdzdHJpbmcnID8gbWFza1N0cm9rZUNvbG9yIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJy0teHktbWluaW1hcC1tYXNrLXN0cm9rZS13aWR0aC1wcm9wcyc6IHR5cGVvZiBtYXNrU3Ryb2tlV2lkdGggPT09ICdudW1iZXInID8gbWFza1N0cm9rZVdpZHRoICogdmlld1NjYWxlIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJy0teHktbWluaW1hcC1ub2RlLWJhY2tncm91bmQtY29sb3ItcHJvcHMnOiB0eXBlb2Ygbm9kZUNvbG9yID09PSAnc3RyaW5nJyA/IG5vZGVDb2xvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICctLXh5LW1pbmltYXAtbm9kZS1zdHJva2UtY29sb3ItcHJvcHMnOiB0eXBlb2Ygbm9kZVN0cm9rZUNvbG9yID09PSAnc3RyaW5nJyA/IG5vZGVTdHJva2VDb2xvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICctLXh5LW1pbmltYXAtbm9kZS1zdHJva2Utd2lkdGgtcHJvcHMnOiB0eXBlb2Ygbm9kZVN0cm9rZVdpZHRoID09PSAnbnVtYmVyJyA/IG5vZGVTdHJva2VXaWR0aCA6IHVuZGVmaW5lZCxcbiAgICAgICAgfSwgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX21pbmltYXAnLCBjbGFzc05hbWVdKSwgXCJkYXRhLXRlc3RpZFwiOiBcInJmX19taW5pbWFwXCIsIGNoaWxkcmVuOiBqc3hzKFwic3ZnXCIsIHsgd2lkdGg6IGVsZW1lbnRXaWR0aCwgaGVpZ2h0OiBlbGVtZW50SGVpZ2h0LCB2aWV3Qm94OiBgJHt4fSAke3l9ICR7d2lkdGh9ICR7aGVpZ2h0fWAsIGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19taW5pbWFwLXN2Z1wiLCByb2xlOiBcImltZ1wiLCBcImFyaWEtbGFiZWxsZWRieVwiOiBsYWJlbGxlZEJ5LCByZWY6IHN2Zywgb25DbGljazogb25TdmdDbGljaywgY2hpbGRyZW46IFtfYXJpYUxhYmVsICYmIGpzeChcInRpdGxlXCIsIHsgaWQ6IGxhYmVsbGVkQnksIGNoaWxkcmVuOiBfYXJpYUxhYmVsIH0pLCBqc3goTWluaU1hcE5vZGVzJDEsIHsgb25DbGljazogb25TdmdOb2RlQ2xpY2ssIG5vZGVDb2xvcjogbm9kZUNvbG9yLCBub2RlU3Ryb2tlQ29sb3I6IG5vZGVTdHJva2VDb2xvciwgbm9kZUJvcmRlclJhZGl1czogbm9kZUJvcmRlclJhZGl1cywgbm9kZUNsYXNzTmFtZTogbm9kZUNsYXNzTmFtZSwgbm9kZVN0cm9rZVdpZHRoOiBub2RlU3Ryb2tlV2lkdGgsIG5vZGVDb21wb25lbnQ6IG5vZGVDb21wb25lbnQgfSksIGpzeChcInBhdGhcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fbWluaW1hcC1tYXNrXCIsIGQ6IGBNJHt4IC0gb2Zmc2V0fSwke3kgLSBvZmZzZXR9aCR7d2lkdGggKyBvZmZzZXQgKiAyfXYke2hlaWdodCArIG9mZnNldCAqIDJ9aCR7LXdpZHRoIC0gb2Zmc2V0ICogMn16XG4gICAgICAgIE0ke3ZpZXdCQi54fSwke3ZpZXdCQi55fWgke3ZpZXdCQi53aWR0aH12JHt2aWV3QkIuaGVpZ2h0fWgkey12aWV3QkIud2lkdGh9emAsIGZpbGxSdWxlOiBcImV2ZW5vZGRcIiwgcG9pbnRlckV2ZW50czogXCJub25lXCIgfSldIH0pIH0pKTtcbn1cbk1pbmlNYXBDb21wb25lbnQuZGlzcGxheU5hbWUgPSAnTWluaU1hcCc7XG4vKipcbiAqIFRoZSBgPE1pbmlNYXAgLz5gIGNvbXBvbmVudCBjYW4gYmUgdXNlZCB0byByZW5kZXIgYW4gb3ZlcnZpZXcgb2YgeW91ciBmbG93LiBJdFxuICogcmVuZGVycyBlYWNoIG5vZGUgYXMgYW4gU1ZHIGVsZW1lbnQgYW5kIHZpc3VhbGl6ZXMgd2hlcmUgdGhlIGN1cnJlbnQgdmlld3BvcnQgaXNcbiAqIGluIHJlbGF0aW9uIHRvIHRoZSByZXN0IG9mIHRoZSBmbG93LlxuICpcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganN4XG4gKmltcG9ydCB7IFJlYWN0RmxvdywgTWluaU1hcCB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRmxvdygpIHtcbiAqICByZXR1cm4gKFxuICogICAgPFJlYWN0RmxvdyBub2Rlcz17Wy4uLl1dfSBlZGdlcz17Wy4uLl1dfT5cbiAqICAgICAgPE1pbmlNYXAgbm9kZVN0cm9rZVdpZHRoPXszfSAvPlxuICogICAgPC9SZWFjdEZsb3c+XG4gKiAgKTtcbiAqfVxuICpgYGBcbiAqL1xuY29uc3QgTWluaU1hcCA9IG1lbW8oTWluaU1hcENvbXBvbmVudCk7XG5cbmNvbnN0IHNjYWxlU2VsZWN0b3IgPSAoY2FsY3VsYXRlU2NhbGUpID0+IChzdG9yZSkgPT4gY2FsY3VsYXRlU2NhbGUgPyBgJHtNYXRoLm1heCgxIC8gc3RvcmUudHJhbnNmb3JtWzJdLCAxKX1gIDogdW5kZWZpbmVkO1xuY29uc3QgZGVmYXVsdFBvc2l0aW9ucyA9IHtcbiAgICBbUmVzaXplQ29udHJvbFZhcmlhbnQuTGluZV06ICdyaWdodCcsXG4gICAgW1Jlc2l6ZUNvbnRyb2xWYXJpYW50LkhhbmRsZV06ICdib3R0b20tcmlnaHQnLFxufTtcbmZ1bmN0aW9uIFJlc2l6ZUNvbnRyb2woeyBub2RlSWQsIHBvc2l0aW9uLCB2YXJpYW50ID0gUmVzaXplQ29udHJvbFZhcmlhbnQuSGFuZGxlLCBjbGFzc05hbWUsIHN0eWxlID0gdW5kZWZpbmVkLCBjaGlsZHJlbiwgY29sb3IsIG1pbldpZHRoID0gMTAsIG1pbkhlaWdodCA9IDEwLCBtYXhXaWR0aCA9IE51bWJlci5NQVhfVkFMVUUsIG1heEhlaWdodCA9IE51bWJlci5NQVhfVkFMVUUsIGtlZXBBc3BlY3RSYXRpbyA9IGZhbHNlLCByZXNpemVEaXJlY3Rpb24sIGF1dG9TY2FsZSA9IHRydWUsIHNob3VsZFJlc2l6ZSwgb25SZXNpemVTdGFydCwgb25SZXNpemUsIG9uUmVzaXplRW5kLCB9KSB7XG4gICAgY29uc3QgY29udGV4dE5vZGVJZCA9IHVzZU5vZGVJZCgpO1xuICAgIGNvbnN0IGlkID0gdHlwZW9mIG5vZGVJZCA9PT0gJ3N0cmluZycgPyBub2RlSWQgOiBjb250ZXh0Tm9kZUlkO1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCByZXNpemVDb250cm9sUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGlzSGFuZGxlQ29udHJvbCA9IHZhcmlhbnQgPT09IFJlc2l6ZUNvbnRyb2xWYXJpYW50LkhhbmRsZTtcbiAgICBjb25zdCBzY2FsZSA9IHVzZVN0b3JlKHVzZUNhbGxiYWNrKHNjYWxlU2VsZWN0b3IoaXNIYW5kbGVDb250cm9sICYmIGF1dG9TY2FsZSksIFtpc0hhbmRsZUNvbnRyb2wsIGF1dG9TY2FsZV0pLCBzaGFsbG93KTtcbiAgICBjb25zdCByZXNpemVyID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGNvbnRyb2xQb3NpdGlvbiA9IHBvc2l0aW9uID8/IGRlZmF1bHRQb3NpdGlvbnNbdmFyaWFudF07XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFyZXNpemVDb250cm9sUmVmLmN1cnJlbnQgfHwgIWlkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXNpemVyLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJlc2l6ZXIuY3VycmVudCA9IFhZUmVzaXplcih7XG4gICAgICAgICAgICAgICAgZG9tTm9kZTogcmVzaXplQ29udHJvbFJlZi5jdXJyZW50LFxuICAgICAgICAgICAgICAgIG5vZGVJZDogaWQsXG4gICAgICAgICAgICAgICAgZ2V0U3RvcmVJdGVtczogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IG5vZGVMb29rdXAsIHRyYW5zZm9ybSwgc25hcEdyaWQsIHNuYXBUb0dyaWQsIG5vZGVPcmlnaW4sIGRvbU5vZGUgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlTG9va3VwLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtLFxuICAgICAgICAgICAgICAgICAgICAgICAgc25hcEdyaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzbmFwVG9HcmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZU9yaWdpbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhbmVEb21Ob2RlOiBkb21Ob2RlLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U6IChjaGFuZ2UsIGNoaWxkQ2hhbmdlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHRyaWdnZXJOb2RlQ2hhbmdlcywgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCBub2RlT3JpZ2luIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGFuZ2VzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRQb3NpdGlvbiA9IHsgeDogY2hhbmdlLngsIHk6IGNoYW5nZS55IH07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2RlTG9va3VwLmdldChpZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlICYmIG5vZGUuZXhwYW5kUGFyZW50ICYmIG5vZGUucGFyZW50SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbiA9IG5vZGUub3JpZ2luID8/IG5vZGVPcmlnaW47XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3aWR0aCA9IGNoYW5nZS53aWR0aCA/PyBub2RlLm1lYXN1cmVkLndpZHRoID8/IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBoZWlnaHQgPSBjaGFuZ2UuaGVpZ2h0ID8/IG5vZGUubWVhc3VyZWQuaGVpZ2h0ID8/IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogbm9kZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRJZDogbm9kZS5wYXJlbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWN0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmV2YWx1YXRlQWJzb2x1dGVQb3NpdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBjaGFuZ2UueCA/PyBub2RlLnBvc2l0aW9uLngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBjaGFuZ2UueSA/PyBub2RlLnBvc2l0aW9uLnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHsgd2lkdGgsIGhlaWdodCB9LCBub2RlLnBhcmVudElkLCBub2RlTG9va3VwLCBvcmlnaW4pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyZW50RXhwYW5kQ2hhbmdlcyA9IGhhbmRsZUV4cGFuZFBhcmVudChbY2hpbGRdLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIG5vZGVPcmlnaW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKC4uLnBhcmVudEV4cGFuZENoYW5nZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHdoZW4gdGhlIHBhcmVudCB3YXMgZXhwYW5kZWQgYnkgdGhlIGNoaWxkIG5vZGUsIGl0cyBwb3NpdGlvbiB3aWxsIGJlIGNsYW1wZWQgYXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIDAsMCB3aGVuIG5vZGUgb3JpZ2luIGlzIDAsMCBhbmQgdG8gd2lkdGgsIGhlaWdodCBpZiBpdCdzIDEsMVxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0UG9zaXRpb24ueCA9IGNoYW5nZS54ID8gTWF0aC5tYXgob3JpZ2luWzBdICogd2lkdGgsIGNoYW5nZS54KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRQb3NpdGlvbi55ID0gY2hhbmdlLnkgPyBNYXRoLm1heChvcmlnaW5bMV0gKiBoZWlnaHQsIGNoYW5nZS55KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFBvc2l0aW9uLnggIT09IHVuZGVmaW5lZCAmJiBuZXh0UG9zaXRpb24ueSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbkNoYW5nZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncG9zaXRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7IC4uLm5leHRQb3NpdGlvbiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaChwb3NpdGlvbkNoYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZS53aWR0aCAhPT0gdW5kZWZpbmVkICYmIGNoYW5nZS5oZWlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2V0QXR0cmlidXRlcyA9ICFyZXNpemVEaXJlY3Rpb24gPyB0cnVlIDogcmVzaXplRGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkaW1lbnNpb25DaGFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2RpbWVuc2lvbnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc2l6aW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogY2hhbmdlLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGNoYW5nZS5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goZGltZW5zaW9uQ2hhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkQ2hhbmdlIG9mIGNoaWxkQ2hhbmdlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb25DaGFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uY2hpbGRDaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3Bvc2l0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2gocG9zaXRpb25DaGFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJOb2RlQ2hhbmdlcyhjaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uRW5kOiAoeyB3aWR0aCwgaGVpZ2h0IH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGltZW5zaW9uQ2hhbmdlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2RpbWVuc2lvbnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzaXppbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlLmdldFN0YXRlKCkudHJpZ2dlck5vZGVDaGFuZ2VzKFtkaW1lbnNpb25DaGFuZ2VdKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzaXplci5jdXJyZW50LnVwZGF0ZSh7XG4gICAgICAgICAgICBjb250cm9sUG9zaXRpb24sXG4gICAgICAgICAgICBib3VuZGFyaWVzOiB7XG4gICAgICAgICAgICAgICAgbWluV2lkdGgsXG4gICAgICAgICAgICAgICAgbWluSGVpZ2h0LFxuICAgICAgICAgICAgICAgIG1heFdpZHRoLFxuICAgICAgICAgICAgICAgIG1heEhlaWdodCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBrZWVwQXNwZWN0UmF0aW8sXG4gICAgICAgICAgICByZXNpemVEaXJlY3Rpb24sXG4gICAgICAgICAgICBvblJlc2l6ZVN0YXJ0LFxuICAgICAgICAgICAgb25SZXNpemUsXG4gICAgICAgICAgICBvblJlc2l6ZUVuZCxcbiAgICAgICAgICAgIHNob3VsZFJlc2l6ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICByZXNpemVyLmN1cnJlbnQ/LmRlc3Ryb3koKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIGNvbnRyb2xQb3NpdGlvbixcbiAgICAgICAgbWluV2lkdGgsXG4gICAgICAgIG1pbkhlaWdodCxcbiAgICAgICAgbWF4V2lkdGgsXG4gICAgICAgIG1heEhlaWdodCxcbiAgICAgICAga2VlcEFzcGVjdFJhdGlvLFxuICAgICAgICBvblJlc2l6ZVN0YXJ0LFxuICAgICAgICBvblJlc2l6ZSxcbiAgICAgICAgb25SZXNpemVFbmQsXG4gICAgICAgIHNob3VsZFJlc2l6ZSxcbiAgICBdKTtcbiAgICBjb25zdCBwb3NpdGlvbkNsYXNzTmFtZXMgPSBjb250cm9sUG9zaXRpb24uc3BsaXQoJy0nKTtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19yZXNpemUtY29udHJvbCcsICdub2RyYWcnLCAuLi5wb3NpdGlvbkNsYXNzTmFtZXMsIHZhcmlhbnQsIGNsYXNzTmFtZV0pLCByZWY6IHJlc2l6ZUNvbnRyb2xSZWYsIHN0eWxlOiB7XG4gICAgICAgICAgICAuLi5zdHlsZSxcbiAgICAgICAgICAgIHNjYWxlLFxuICAgICAgICAgICAgLi4uKGNvbG9yICYmIHsgW2lzSGFuZGxlQ29udHJvbCA/ICdiYWNrZ3JvdW5kQ29sb3InIDogJ2JvcmRlckNvbG9yJ106IGNvbG9yIH0pLFxuICAgICAgICB9LCBjaGlsZHJlbjogY2hpbGRyZW4gfSkpO1xufVxuLyoqXG4gKiBUbyBjcmVhdGUgeW91ciBvd24gcmVzaXppbmcgVUksIHlvdSBjYW4gdXNlIHRoZSBgTm9kZVJlc2l6ZUNvbnRyb2xgIGNvbXBvbmVudCB3aGVyZSB5b3UgY2FuIHBhc3MgY2hpbGRyZW4gKHN1Y2ggYXMgaWNvbnMpLlxuICogQHB1YmxpY1xuICpcbiAqL1xuY29uc3QgTm9kZVJlc2l6ZUNvbnRyb2wgPSBtZW1vKFJlc2l6ZUNvbnRyb2wpO1xuXG4vKipcbiAqIFRoZSBgPE5vZGVSZXNpemVyIC8+YCBjb21wb25lbnQgY2FuIGJlIHVzZWQgdG8gYWRkIGEgcmVzaXplIGZ1bmN0aW9uYWxpdHkgdG8geW91clxuICogbm9kZXMuIEl0IHJlbmRlcnMgZHJhZ2dhYmxlIGNvbnRyb2xzIGFyb3VuZCB0aGUgbm9kZSB0byByZXNpemUgaW4gYWxsIGRpcmVjdGlvbnMuXG4gKiBAcHVibGljXG4gKlxuICogQGV4YW1wbGVcbiAqYGBganN4XG4gKmltcG9ydCB7IG1lbW8gfSBmcm9tICdyZWFjdCc7XG4gKmltcG9ydCB7IEhhbmRsZSwgUG9zaXRpb24sIE5vZGVSZXNpemVyIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpmdW5jdGlvbiBSZXNpemFibGVOb2RlKHsgZGF0YSB9KSB7XG4gKiAgcmV0dXJuIChcbiAqICAgIDw+XG4gKiAgICAgIDxOb2RlUmVzaXplciBtaW5XaWR0aD17MTAwfSBtaW5IZWlnaHQ9ezMwfSAvPlxuICogICAgICA8SGFuZGxlIHR5cGU9XCJ0YXJnZXRcIiBwb3NpdGlvbj17UG9zaXRpb24uTGVmdH0gLz5cbiAqICAgICAgPGRpdiBzdHlsZT17eyBwYWRkaW5nOiAxMCB9fT57ZGF0YS5sYWJlbH08L2Rpdj5cbiAqICAgICAgPEhhbmRsZSB0eXBlPVwic291cmNlXCIgcG9zaXRpb249e1Bvc2l0aW9uLlJpZ2h0fSAvPlxuICogICAgPC8+XG4gKiAgKTtcbiAqfTtcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IG1lbW8oUmVzaXphYmxlTm9kZSk7XG4gKmBgYFxuICovXG5mdW5jdGlvbiBOb2RlUmVzaXplcih7IG5vZGVJZCwgaXNWaXNpYmxlID0gdHJ1ZSwgaGFuZGxlQ2xhc3NOYW1lLCBoYW5kbGVTdHlsZSwgbGluZUNsYXNzTmFtZSwgbGluZVN0eWxlLCBjb2xvciwgbWluV2lkdGggPSAxMCwgbWluSGVpZ2h0ID0gMTAsIG1heFdpZHRoID0gTnVtYmVyLk1BWF9WQUxVRSwgbWF4SGVpZ2h0ID0gTnVtYmVyLk1BWF9WQUxVRSwga2VlcEFzcGVjdFJhdGlvID0gZmFsc2UsIGF1dG9TY2FsZSA9IHRydWUsIHNob3VsZFJlc2l6ZSwgb25SZXNpemVTdGFydCwgb25SZXNpemUsIG9uUmVzaXplRW5kLCB9KSB7XG4gICAgaWYgKCFpc1Zpc2libGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW1hZX1JFU0laRVJfTElORV9QT1NJVElPTlMubWFwKChwb3NpdGlvbikgPT4gKGpzeChOb2RlUmVzaXplQ29udHJvbCwgeyBjbGFzc05hbWU6IGxpbmVDbGFzc05hbWUsIHN0eWxlOiBsaW5lU3R5bGUsIG5vZGVJZDogbm9kZUlkLCBwb3NpdGlvbjogcG9zaXRpb24sIHZhcmlhbnQ6IFJlc2l6ZUNvbnRyb2xWYXJpYW50LkxpbmUsIGNvbG9yOiBjb2xvciwgbWluV2lkdGg6IG1pbldpZHRoLCBtaW5IZWlnaHQ6IG1pbkhlaWdodCwgbWF4V2lkdGg6IG1heFdpZHRoLCBtYXhIZWlnaHQ6IG1heEhlaWdodCwgb25SZXNpemVTdGFydDogb25SZXNpemVTdGFydCwga2VlcEFzcGVjdFJhdGlvOiBrZWVwQXNwZWN0UmF0aW8sIGF1dG9TY2FsZTogYXV0b1NjYWxlLCBzaG91bGRSZXNpemU6IHNob3VsZFJlc2l6ZSwgb25SZXNpemU6IG9uUmVzaXplLCBvblJlc2l6ZUVuZDogb25SZXNpemVFbmQgfSwgcG9zaXRpb24pKSksIFhZX1JFU0laRVJfSEFORExFX1BPU0lUSU9OUy5tYXAoKHBvc2l0aW9uKSA9PiAoanN4KE5vZGVSZXNpemVDb250cm9sLCB7IGNsYXNzTmFtZTogaGFuZGxlQ2xhc3NOYW1lLCBzdHlsZTogaGFuZGxlU3R5bGUsIG5vZGVJZDogbm9kZUlkLCBwb3NpdGlvbjogcG9zaXRpb24sIGNvbG9yOiBjb2xvciwgbWluV2lkdGg6IG1pbldpZHRoLCBtaW5IZWlnaHQ6IG1pbkhlaWdodCwgbWF4V2lkdGg6IG1heFdpZHRoLCBtYXhIZWlnaHQ6IG1heEhlaWdodCwgb25SZXNpemVTdGFydDogb25SZXNpemVTdGFydCwga2VlcEFzcGVjdFJhdGlvOiBrZWVwQXNwZWN0UmF0aW8sIGF1dG9TY2FsZTogYXV0b1NjYWxlLCBzaG91bGRSZXNpemU6IHNob3VsZFJlc2l6ZSwgb25SZXNpemU6IG9uUmVzaXplLCBvblJlc2l6ZUVuZDogb25SZXNpemVFbmQgfSwgcG9zaXRpb24pKSldIH0pKTtcbn1cblxuY29uc3Qgc2VsZWN0b3IgPSAoc3RhdGUpID0+IHN0YXRlLmRvbU5vZGU/LnF1ZXJ5U2VsZWN0b3IoJy5yZWFjdC1mbG93X19yZW5kZXJlcicpO1xuZnVuY3Rpb24gTm9kZVRvb2xiYXJQb3J0YWwoeyBjaGlsZHJlbiB9KSB7XG4gICAgY29uc3Qgd3JhcHBlclJlZiA9IHVzZVN0b3JlKHNlbGVjdG9yKTtcbiAgICBpZiAoIXdyYXBwZXJSZWYpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIHdyYXBwZXJSZWYpO1xufVxuXG5jb25zdCBub2RlRXF1YWxpdHlGbiA9IChhLCBiKSA9PiBhPy5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS54ICE9PSBiPy5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS54IHx8XG4gICAgYT8uaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueSAhPT0gYj8uaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueSB8fFxuICAgIGE/Lm1lYXN1cmVkLndpZHRoICE9PSBiPy5tZWFzdXJlZC53aWR0aCB8fFxuICAgIGE/Lm1lYXN1cmVkLmhlaWdodCAhPT0gYj8ubWVhc3VyZWQuaGVpZ2h0IHx8XG4gICAgYT8uc2VsZWN0ZWQgIT09IGI/LnNlbGVjdGVkIHx8XG4gICAgYT8uaW50ZXJuYWxzLnogIT09IGI/LmludGVybmFscy56O1xuY29uc3Qgbm9kZXNFcXVhbGl0eUZuID0gKGEsIGIpID0+IHtcbiAgICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtrZXksIG5vZGVdIG9mIGEpIHtcbiAgICAgICAgaWYgKG5vZGVFcXVhbGl0eUZuKG5vZGUsIGIuZ2V0KGtleSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuY29uc3Qgc3RvcmVTZWxlY3RvciA9IChzdGF0ZSkgPT4gKHtcbiAgICB4OiBzdGF0ZS50cmFuc2Zvcm1bMF0sXG4gICAgeTogc3RhdGUudHJhbnNmb3JtWzFdLFxuICAgIHpvb206IHN0YXRlLnRyYW5zZm9ybVsyXSxcbiAgICBzZWxlY3RlZE5vZGVzQ291bnQ6IHN0YXRlLm5vZGVzLmZpbHRlcigobm9kZSkgPT4gbm9kZS5zZWxlY3RlZCkubGVuZ3RoLFxufSk7XG4vKipcbiAqIFRoaXMgY29tcG9uZW50IGNhbiByZW5kZXIgYSB0b29sYmFyIG9yIHRvb2x0aXAgdG8gb25lIHNpZGUgb2YgYSBjdXN0b20gbm9kZS4gVGhpc1xuICogdG9vbGJhciBkb2Vzbid0IHNjYWxlIHdpdGggdGhlIHZpZXdwb3J0IHNvIHRoYXQgdGhlIGNvbnRlbnQgaXMgYWx3YXlzIHZpc2libGUuXG4gKlxuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqIGBgYGpzeFxuICppbXBvcnQgeyBtZW1vIH0gZnJvbSAncmVhY3QnO1xuICppbXBvcnQgeyBIYW5kbGUsIFBvc2l0aW9uLCBOb2RlVG9vbGJhciB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZnVuY3Rpb24gQ3VzdG9tTm9kZSh7IGRhdGEgfSkge1xuICogIHJldHVybiAoXG4gKiAgICA8PlxuICogICAgICA8Tm9kZVRvb2xiYXIgaXNWaXNpYmxlPXtkYXRhLnRvb2xiYXJWaXNpYmxlfSBwb3NpdGlvbj17ZGF0YS50b29sYmFyUG9zaXRpb259PlxuICogICAgICAgIDxidXR0b24+ZGVsZXRlPC9idXR0b24+XG4gKiAgICAgICAgPGJ1dHRvbj5jb3B5PC9idXR0b24+XG4gKiAgICAgICAgPGJ1dHRvbj5leHBhbmQ8L2J1dHRvbj5cbiAqICAgICAgPC9Ob2RlVG9vbGJhcj5cbiAqXG4gKiAgICAgIDxkaXYgc3R5bGU9e3sgcGFkZGluZzogJzEwcHggMjBweCcgfX0+XG4gKiAgICAgICAge2RhdGEubGFiZWx9XG4gKiAgICAgIDwvZGl2PlxuICpcbiAqICAgICAgPEhhbmRsZSB0eXBlPVwidGFyZ2V0XCIgcG9zaXRpb249e1Bvc2l0aW9uLkxlZnR9IC8+XG4gKiAgICAgIDxIYW5kbGUgdHlwZT1cInNvdXJjZVwiIHBvc2l0aW9uPXtQb3NpdGlvbi5SaWdodH0gLz5cbiAqICAgIDwvPlxuICogICk7XG4gKn07XG4gKlxuICpleHBvcnQgZGVmYXVsdCBtZW1vKEN1c3RvbU5vZGUpO1xuICpgYGBcbiAqIEByZW1hcmtzIEJ5IGRlZmF1bHQsIHRoZSB0b29sYmFyIGlzIG9ubHkgdmlzaWJsZSB3aGVuIGEgbm9kZSBpcyBzZWxlY3RlZC4gSWYgbXVsdGlwbGVcbiAqIG5vZGVzIGFyZSBzZWxlY3RlZCBpdCB3aWxsIG5vdCBiZSB2aXNpYmxlIHRvIHByZXZlbnQgb3ZlcmxhcHBpbmcgdG9vbGJhcnMgb3JcbiAqIGNsdXR0ZXIuIFlvdSBjYW4gb3ZlcnJpZGUgdGhpcyBiZWhhdmlvciBieSBzZXR0aW5nIHRoZSBgaXNWaXNpYmxlYCBwcm9wIHRvIGB0cnVlYC5cbiAqL1xuZnVuY3Rpb24gTm9kZVRvb2xiYXIoeyBub2RlSWQsIGNoaWxkcmVuLCBjbGFzc05hbWUsIHN0eWxlLCBpc1Zpc2libGUsIHBvc2l0aW9uID0gUG9zaXRpb24uVG9wLCBvZmZzZXQgPSAxMCwgYWxpZ24gPSAnY2VudGVyJywgLi4ucmVzdCB9KSB7XG4gICAgY29uc3QgY29udGV4dE5vZGVJZCA9IHVzZU5vZGVJZCgpO1xuICAgIGNvbnN0IG5vZGVzU2VsZWN0b3IgPSB1c2VDYWxsYmFjaygoc3RhdGUpID0+IHtcbiAgICAgICAgY29uc3Qgbm9kZUlkcyA9IEFycmF5LmlzQXJyYXkobm9kZUlkKSA/IG5vZGVJZCA6IFtub2RlSWQgfHwgY29udGV4dE5vZGVJZCB8fCAnJ107XG4gICAgICAgIGNvbnN0IGludGVybmFsTm9kZXMgPSBub2RlSWRzLnJlZHVjZSgocmVzLCBpZCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHN0YXRlLm5vZGVMb29rdXAuZ2V0KGlkKTtcbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgcmVzLnNldChub2RlLmlkLCBub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0sIG5ldyBNYXAoKSk7XG4gICAgICAgIHJldHVybiBpbnRlcm5hbE5vZGVzO1xuICAgIH0sIFtub2RlSWQsIGNvbnRleHROb2RlSWRdKTtcbiAgICBjb25zdCBub2RlcyA9IHVzZVN0b3JlKG5vZGVzU2VsZWN0b3IsIG5vZGVzRXF1YWxpdHlGbik7XG4gICAgY29uc3QgeyB4LCB5LCB6b29tLCBzZWxlY3RlZE5vZGVzQ291bnQgfSA9IHVzZVN0b3JlKHN0b3JlU2VsZWN0b3IsIHNoYWxsb3cpO1xuICAgIC8vIGlmIGlzVmlzaWJsZSBpcyBub3Qgc2V0LCB3ZSBzaG93IHRoZSB0b29sYmFyIG9ubHkgaWYgaXRzIG5vZGUgaXMgc2VsZWN0ZWQgYW5kIG5vIG90aGVyIG5vZGUgaXMgc2VsZWN0ZWRcbiAgICBjb25zdCBpc0FjdGl2ZSA9IHR5cGVvZiBpc1Zpc2libGUgPT09ICdib29sZWFuJ1xuICAgICAgICA/IGlzVmlzaWJsZVxuICAgICAgICA6IG5vZGVzLnNpemUgPT09IDEgJiYgbm9kZXMudmFsdWVzKCkubmV4dCgpLnZhbHVlPy5zZWxlY3RlZCAmJiBzZWxlY3RlZE5vZGVzQ291bnQgPT09IDE7XG4gICAgaWYgKCFpc0FjdGl2ZSB8fCAhbm9kZXMuc2l6ZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgbm9kZVJlY3QgPSBnZXRJbnRlcm5hbE5vZGVzQm91bmRzKG5vZGVzKTtcbiAgICBjb25zdCBub2Rlc0FycmF5ID0gQXJyYXkuZnJvbShub2Rlcy52YWx1ZXMoKSk7XG4gICAgY29uc3QgekluZGV4ID0gTWF0aC5tYXgoLi4ubm9kZXNBcnJheS5tYXAoKG5vZGUpID0+IG5vZGUuaW50ZXJuYWxzLnogKyAxKSk7XG4gICAgY29uc3Qgd3JhcHBlclN0eWxlID0ge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgdHJhbnNmb3JtOiBnZXROb2RlVG9vbGJhclRyYW5zZm9ybShub2RlUmVjdCwgeyB4LCB5LCB6b29tIH0sIHBvc2l0aW9uLCBvZmZzZXQsIGFsaWduKSxcbiAgICAgICAgekluZGV4LFxuICAgICAgICAuLi5zdHlsZSxcbiAgICB9O1xuICAgIHJldHVybiAoanN4KE5vZGVUb29sYmFyUG9ydGFsLCB7IGNoaWxkcmVuOiBqc3goXCJkaXZcIiwgeyBzdHlsZTogd3JhcHBlclN0eWxlLCBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fbm9kZS10b29sYmFyJywgY2xhc3NOYW1lXSksIC4uLnJlc3QsIFwiZGF0YS1pZFwiOiBub2Rlc0FycmF5LnJlZHVjZSgoYWNjLCBub2RlKSA9PiBgJHthY2N9JHtub2RlLmlkfSBgLCAnJykudHJpbSgpLCBjaGlsZHJlbjogY2hpbGRyZW4gfSkgfSkpO1xufVxuXG5leHBvcnQgeyBCYWNrZ3JvdW5kLCBCYWNrZ3JvdW5kVmFyaWFudCwgQmFzZUVkZ2UsIEJlemllckVkZ2UsIENvbnRyb2xCdXR0b24sIENvbnRyb2xzLCBFZGdlTGFiZWxSZW5kZXJlciwgRWRnZVRleHQsIEhhbmRsZSwgTWluaU1hcCwgTm9kZVJlc2l6ZUNvbnRyb2wsIE5vZGVSZXNpemVyLCBOb2RlVG9vbGJhciwgUGFuZWwsIGluZGV4IGFzIFJlYWN0RmxvdywgUmVhY3RGbG93UHJvdmlkZXIsIFNpbXBsZUJlemllckVkZ2UsIFNtb290aFN0ZXBFZGdlLCBTdGVwRWRnZSwgU3RyYWlnaHRFZGdlLCBWaWV3cG9ydFBvcnRhbCwgYXBwbHlFZGdlQ2hhbmdlcywgYXBwbHlOb2RlQ2hhbmdlcywgZ2V0U2ltcGxlQmV6aWVyUGF0aCwgaXNFZGdlLCBpc05vZGUsIHVzZUNvbm5lY3Rpb24sIHVzZUVkZ2VzLCB1c2VFZGdlc1N0YXRlLCB1c2VIYW5kbGVDb25uZWN0aW9ucywgdXNlSW50ZXJuYWxOb2RlLCB1c2VLZXlQcmVzcywgdXNlTm9kZUNvbm5lY3Rpb25zLCB1c2VOb2RlSWQsIHVzZU5vZGVzLCB1c2VOb2Rlc0RhdGEsIHVzZU5vZGVzSW5pdGlhbGl6ZWQsIHVzZU5vZGVzU3RhdGUsIHVzZU9uU2VsZWN0aW9uQ2hhbmdlLCB1c2VPblZpZXdwb3J0Q2hhbmdlLCB1c2VSZWFjdEZsb3csIHVzZVN0b3JlLCB1c2VTdG9yZUFwaSwgdXNlVXBkYXRlTm9kZUludGVybmFscywgdXNlVmlld3BvcnQgfTtcbiJdLCJuYW1lcyI6WyJqc3hzIiwiRnJhZ21lbnQiLCJqc3giLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZU1lbW8iLCJmb3J3YXJkUmVmIiwidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VDYWxsYmFjayIsIm1lbW8iLCJjYyIsImVycm9yTWVzc2FnZXMiLCJtZXJnZUFyaWFMYWJlbENvbmZpZyIsImluZmluaXRlRXh0ZW50IiwiaXNJbnB1dERPTU5vZGUiLCJnZXRWaWV3cG9ydEZvckJvdW5kcyIsInBvaW50VG9SZW5kZXJlclBvaW50IiwicmVuZGVyZXJQb2ludFRvUG9pbnQiLCJpc05vZGVCYXNlIiwiaXNFZGdlQmFzZSIsImdldEVsZW1lbnRzVG9SZW1vdmUiLCJpc1JlY3RPYmplY3QiLCJub2RlVG9SZWN0IiwiZ2V0T3ZlcmxhcHBpbmdBcmVhIiwiZ2V0Tm9kZXNCb3VuZHMiLCJ3aXRoUmVzb2x2ZXJzIiwiZXZhbHVhdGVBYnNvbHV0ZVBvc2l0aW9uIiwiZ2V0RGltZW5zaW9ucyIsIlhZUGFuWm9vbSIsIlBhbk9uU2Nyb2xsTW9kZSIsIlNlbGVjdGlvbk1vZGUiLCJnZXRFdmVudFBvc2l0aW9uIiwiZ2V0Tm9kZXNJbnNpZGUiLCJhcmVTZXRzRXF1YWwiLCJYWURyYWciLCJzbmFwUG9zaXRpb24iLCJjYWxjdWxhdGVOb2RlUG9zaXRpb24iLCJQb3NpdGlvbiIsIkNvbm5lY3Rpb25Nb2RlIiwiaXNNb3VzZUV2ZW50IiwiWFlIYW5kbGUiLCJnZXRIb3N0Rm9yRWxlbWVudCIsImFkZEVkZ2UiLCJnZXRJbnRlcm5hbE5vZGVzQm91bmRzIiwiaXNOdW1lcmljIiwibm9kZUhhc0RpbWVuc2lvbnMiLCJnZXROb2RlRGltZW5zaW9ucyIsImVsZW1lbnRTZWxlY3Rpb25LZXlzIiwiaXNFZGdlVmlzaWJsZSIsIk1hcmtlclR5cGUiLCJjcmVhdGVNYXJrZXJJZHMiLCJnZXRCZXppZXJFZGdlQ2VudGVyIiwiZ2V0U21vb3RoU3RlcFBhdGgiLCJnZXRTdHJhaWdodFBhdGgiLCJnZXRCZXppZXJQYXRoIiwiZ2V0RWRnZVBvc2l0aW9uIiwiZ2V0RWxldmF0ZWRFZGdlWkluZGV4IiwiZ2V0TWFya2VySWQiLCJnZXRDb25uZWN0aW9uU3RhdHVzIiwiQ29ubmVjdGlvbkxpbmVUeXBlIiwidXBkYXRlQ29ubmVjdGlvbkxvb2t1cCIsImFkb3B0VXNlck5vZGVzIiwiaW5pdGlhbENvbm5lY3Rpb24iLCJkZXZXYXJuIiwiZGVmYXVsdEFyaWFMYWJlbENvbmZpZyIsInVwZGF0ZU5vZGVJbnRlcm5hbHMiLCJ1cGRhdGVBYnNvbHV0ZVBvc2l0aW9ucyIsImhhbmRsZUV4cGFuZFBhcmVudCIsInBhbkJ5IiwiZml0Vmlld3BvcnQiLCJpc01hY09zIiwiYXJlQ29ubmVjdGlvbk1hcHNFcXVhbCIsImhhbmRsZUNvbm5lY3Rpb25DaGFuZ2UiLCJzaGFsbG93Tm9kZURhdGEiLCJYWU1pbmltYXAiLCJnZXRCb3VuZHNPZlJlY3RzIiwiUmVzaXplQ29udHJvbFZhcmlhbnQiLCJYWVJlc2l6ZXIiLCJYWV9SRVNJWkVSX0xJTkVfUE9TSVRJT05TIiwiWFlfUkVTSVpFUl9IQU5ETEVfUE9TSVRJT05TIiwiZ2V0Tm9kZVRvb2xiYXJUcmFuc2Zvcm0iLCJnZXRDb25uZWN0ZWRFZGdlcyIsImdldEVkZ2VDZW50ZXIiLCJnZXRJbmNvbWVycyIsImdldE91dGdvZXJzIiwicmVjb25uZWN0RWRnZSIsInVzZVN0b3JlV2l0aEVxdWFsaXR5Rm4iLCJjcmVhdGVXaXRoRXF1YWxpdHlGbiIsInNoYWxsb3ciLCJjcmVhdGVQb3J0YWwiLCJTdG9yZUNvbnRleHQiLCJQcm92aWRlciQxIiwiUHJvdmlkZXIiLCJ6dXN0YW5kRXJyb3JNZXNzYWdlIiwidXNlU3RvcmUiLCJzZWxlY3RvciIsImVxdWFsaXR5Rm4iLCJzdG9yZSIsIkVycm9yIiwidXNlU3RvcmVBcGkiLCJnZXRTdGF0ZSIsInNldFN0YXRlIiwic3Vic2NyaWJlIiwic3R5bGUiLCJkaXNwbGF5IiwiYXJpYUxpdmVTdHlsZSIsInBvc2l0aW9uIiwid2lkdGgiLCJoZWlnaHQiLCJtYXJnaW4iLCJib3JkZXIiLCJwYWRkaW5nIiwib3ZlcmZsb3ciLCJjbGlwIiwiY2xpcFBhdGgiLCJBUklBX05PREVfREVTQ19LRVkiLCJBUklBX0VER0VfREVTQ19LRVkiLCJBUklBX0xJVkVfTUVTU0FHRSIsImFyaWFMaXZlU2VsZWN0b3IiLCJzIiwiYXJpYUxpdmVNZXNzYWdlIiwiYXJpYUxhYmVsQ29uZmlnU2VsZWN0b3IiLCJhcmlhTGFiZWxDb25maWciLCJBcmlhTGl2ZU1lc3NhZ2UiLCJyZklkIiwiaWQiLCJjaGlsZHJlbiIsIkExMXlEZXNjcmlwdGlvbnMiLCJkaXNhYmxlS2V5Ym9hcmRBMTF5Iiwic2VsZWN0b3IkbiIsInVzZXJTZWxlY3Rpb25BY3RpdmUiLCJQYW5lbCIsImNsYXNzTmFtZSIsInJlc3QiLCJyZWYiLCJwb2ludGVyRXZlbnRzIiwicG9zaXRpb25DbGFzc2VzIiwic3BsaXQiLCJkaXNwbGF5TmFtZSIsIkF0dHJpYnV0aW9uIiwicHJvT3B0aW9ucyIsImhpZGVBdHRyaWJ1dGlvbiIsImhyZWYiLCJ0YXJnZXQiLCJyZWwiLCJzZWxlY3RvciRtIiwic2VsZWN0ZWROb2RlcyIsInNlbGVjdGVkRWRnZXMiLCJub2RlIiwibm9kZUxvb2t1cCIsInNlbGVjdGVkIiwicHVzaCIsImludGVybmFscyIsInVzZXJOb2RlIiwiZWRnZSIsImVkZ2VMb29rdXAiLCJzZWxlY3RJZCIsIm9iaiIsImFyZUVxdWFsIiwiYSIsImIiLCJtYXAiLCJTZWxlY3Rpb25MaXN0ZW5lcklubmVyIiwib25TZWxlY3Rpb25DaGFuZ2UiLCJwYXJhbXMiLCJub2RlcyIsImVkZ2VzIiwib25TZWxlY3Rpb25DaGFuZ2VIYW5kbGVycyIsImZvckVhY2giLCJmbiIsImNoYW5nZVNlbGVjdG9yIiwiU2VsZWN0aW9uTGlzdGVuZXIiLCJzdG9yZUhhc1NlbGVjdGlvbkNoYW5nZUhhbmRsZXJzIiwiZGVmYXVsdE5vZGVPcmlnaW4iLCJkZWZhdWx0Vmlld3BvcnQiLCJ4IiwieSIsInpvb20iLCJyZWFjdEZsb3dGaWVsZHNUb1RyYWNrIiwiZmllbGRzVG9UcmFjayIsInNlbGVjdG9yJGwiLCJzZXROb2RlcyIsInNldEVkZ2VzIiwic2V0TWluWm9vbSIsInNldE1heFpvb20iLCJzZXRUcmFuc2xhdGVFeHRlbnQiLCJzZXROb2RlRXh0ZW50IiwicmVzZXQiLCJzZXREZWZhdWx0Tm9kZXNBbmRFZGdlcyIsInNldFBhbmVDbGlja0Rpc3RhbmNlIiwiaW5pdFByZXZWYWx1ZXMiLCJ0cmFuc2xhdGVFeHRlbnQiLCJub2RlT3JpZ2luIiwibWluWm9vbSIsIm1heFpvb20iLCJlbGVtZW50c1NlbGVjdGFibGUiLCJub1BhbkNsYXNzTmFtZSIsInBhbmVDbGlja0Rpc3RhbmNlIiwiU3RvcmVVcGRhdGVyIiwicHJvcHMiLCJkZWZhdWx0Tm9kZXMiLCJkZWZhdWx0RWRnZXMiLCJwcmV2aW91c0ZpZWxkcyIsImN1cnJlbnQiLCJmaWVsZE5hbWUiLCJmaWVsZFZhbHVlIiwicHJldmlvdXNGaWVsZFZhbHVlIiwiZml0Vmlld1F1ZXVlZCIsImZpdFZpZXdPcHRpb25zIiwiZ2V0TWVkaWFRdWVyeSIsIndpbmRvdyIsIm1hdGNoTWVkaWEiLCJ1c2VDb2xvck1vZGVDbGFzcyIsImNvbG9yTW9kZSIsImNvbG9yTW9kZUNsYXNzIiwic2V0Q29sb3JNb2RlQ2xhc3MiLCJtZWRpYVF1ZXJ5IiwidXBkYXRlQ29sb3JNb2RlQ2xhc3MiLCJtYXRjaGVzIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJkZWZhdWx0RG9jIiwiZG9jdW1lbnQiLCJ1c2VLZXlQcmVzcyIsImtleUNvZGUiLCJvcHRpb25zIiwiYWN0SW5zaWRlSW5wdXRXaXRoTW9kaWZpZXIiLCJrZXlQcmVzc2VkIiwic2V0S2V5UHJlc3NlZCIsIm1vZGlmaWVyUHJlc3NlZCIsInByZXNzZWRLZXlzIiwiU2V0Iiwia2V5Q29kZXMiLCJrZXlzVG9XYXRjaCIsImtleUNvZGVBcnIiLCJBcnJheSIsImlzQXJyYXkiLCJrZXlzIiwiZmlsdGVyIiwia2MiLCJyZXBsYWNlIiwia2V5c0ZsYXQiLCJyZWR1Y2UiLCJyZXMiLCJpdGVtIiwiY29uY2F0IiwiZG93bkhhbmRsZXIiLCJldmVudCIsImN0cmxLZXkiLCJtZXRhS2V5Iiwic2hpZnRLZXkiLCJhbHRLZXkiLCJwcmV2ZW50QWN0aW9uIiwia2V5T3JDb2RlIiwidXNlS2V5T3JDb2RlIiwiY29kZSIsImFkZCIsImlzTWF0Y2hpbmdLZXkiLCJjb21wb3NlZFBhdGgiLCJpc0ludGVyYWN0aXZlRWxlbWVudCIsIm5vZGVOYW1lIiwicHJldmVudERlZmF1bHQiLCJ1cEhhbmRsZXIiLCJjbGVhciIsImRlbGV0ZSIsImtleSIsInJlc2V0SGFuZGxlciIsImlzVXAiLCJsZW5ndGgiLCJzaXplIiwic29tZSIsImV2ZXJ5IiwiayIsImhhcyIsImV2ZW50Q29kZSIsImluY2x1ZGVzIiwidXNlVmlld3BvcnRIZWxwZXIiLCJ6b29tSW4iLCJwYW5ab29tIiwic2NhbGVCeSIsImR1cmF0aW9uIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ6b29tT3V0Iiwiem9vbVRvIiwiem9vbUxldmVsIiwic2NhbGVUbyIsImdldFpvb20iLCJ0cmFuc2Zvcm0iLCJzZXRWaWV3cG9ydCIsInZpZXdwb3J0IiwidFgiLCJ0WSIsInRab29tIiwiZ2V0Vmlld3BvcnQiLCJzZXRDZW50ZXIiLCJmaXRCb3VuZHMiLCJib3VuZHMiLCJlYXNlIiwiaW50ZXJwb2xhdGUiLCJzY3JlZW5Ub0Zsb3dQb3NpdGlvbiIsImNsaWVudFBvc2l0aW9uIiwic25hcEdyaWQiLCJzbmFwVG9HcmlkIiwiZG9tTm9kZSIsImRvbVgiLCJkb21ZIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiY29ycmVjdGVkUG9zaXRpb24iLCJfc25hcEdyaWQiLCJfc25hcFRvR3JpZCIsImZsb3dUb1NjcmVlblBvc2l0aW9uIiwiZmxvd1Bvc2l0aW9uIiwicmVuZGVyZXJQb3NpdGlvbiIsImFwcGx5Q2hhbmdlcyIsImNoYW5nZXMiLCJlbGVtZW50cyIsInVwZGF0ZWRFbGVtZW50cyIsImNoYW5nZXNNYXAiLCJNYXAiLCJhZGRJdGVtQ2hhbmdlcyIsImNoYW5nZSIsInR5cGUiLCJzZXQiLCJlbGVtZW50Q2hhbmdlcyIsImdldCIsImVsZW1lbnQiLCJ1cGRhdGVkRWxlbWVudCIsImFwcGx5Q2hhbmdlIiwiaW5kZXgiLCJ1bmRlZmluZWQiLCJzcGxpY2UiLCJkcmFnZ2luZyIsImRpbWVuc2lvbnMiLCJtZWFzdXJlZCIsInNldEF0dHJpYnV0ZXMiLCJyZXNpemluZyIsImFwcGx5Tm9kZUNoYW5nZXMiLCJhcHBseUVkZ2VDaGFuZ2VzIiwiY3JlYXRlU2VsZWN0aW9uQ2hhbmdlIiwiZ2V0U2VsZWN0aW9uQ2hhbmdlcyIsIml0ZW1zIiwic2VsZWN0ZWRJZHMiLCJtdXRhdGVJdGVtIiwid2lsbEJlU2VsZWN0ZWQiLCJnZXRFbGVtZW50c0RpZmZDaGFuZ2VzIiwibG9va3VwIiwiaXRlbXNMb29rdXAiLCJlbnRyaWVzIiwibG9va3VwSXRlbSIsInN0b3JlSXRlbSIsIm5leHROb2RlIiwiZWxlbWVudFRvUmVtb3ZlQ2hhbmdlIiwiaXNOb2RlIiwiaXNFZGdlIiwiZml4ZWRGb3J3YXJkUmVmIiwicmVuZGVyIiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsInVzZVF1ZXVlIiwicnVuUXVldWUiLCJzZXJpYWwiLCJzZXRTZXJpYWwiLCJCaWdJbnQiLCJxdWV1ZSIsImNyZWF0ZVF1ZXVlIiwibiIsInF1ZXVlSXRlbXMiLCJjYiIsIkJhdGNoQ29udGV4dCIsIkJhdGNoUHJvdmlkZXIiLCJub2RlUXVldWVIYW5kbGVyIiwiaGFzRGVmYXVsdE5vZGVzIiwib25Ob2Rlc0NoYW5nZSIsIm5leHQiLCJwYXlsb2FkIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibm9kZVF1ZXVlIiwiZWRnZVF1ZXVlSGFuZGxlciIsImhhc0RlZmF1bHRFZGdlcyIsIm9uRWRnZXNDaGFuZ2UiLCJlZGdlUXVldWUiLCJ2YWx1ZSIsInVzZUJhdGNoQ29udGV4dCIsImJhdGNoQ29udGV4dCIsInNlbGVjdG9yJGsiLCJ1c2VSZWFjdEZsb3ciLCJ2aWV3cG9ydEhlbHBlciIsInZpZXdwb3J0SW5pdGlhbGl6ZWQiLCJnZW5lcmFsSGVscGVyIiwiZ2V0SW50ZXJuYWxOb2RlIiwiZ2V0Tm9kZVJlY3QiLCJub2RlVG9Vc2UiLCJwYXJlbnRJZCIsIm5vZGVXaXRoUG9zaXRpb24iLCJ1cGRhdGVOb2RlIiwibm9kZVVwZGF0ZSIsInByZXZOb2RlcyIsInVwZGF0ZUVkZ2UiLCJlZGdlVXBkYXRlIiwicHJldkVkZ2VzIiwibmV4dEVkZ2UiLCJnZXROb2RlcyIsImdldE5vZGUiLCJnZXRFZGdlcyIsImUiLCJnZXRFZGdlIiwiYWRkTm9kZXMiLCJuZXdOb2RlcyIsImFkZEVkZ2VzIiwibmV3RWRnZXMiLCJ0b09iamVjdCIsImRlbGV0ZUVsZW1lbnRzIiwibm9kZXNUb1JlbW92ZSIsImVkZ2VzVG9SZW1vdmUiLCJvbk5vZGVzRGVsZXRlIiwib25FZGdlc0RlbGV0ZSIsInRyaWdnZXJOb2RlQ2hhbmdlcyIsInRyaWdnZXJFZGdlQ2hhbmdlcyIsIm9uRGVsZXRlIiwib25CZWZvcmVEZWxldGUiLCJtYXRjaGluZ05vZGVzIiwibWF0Y2hpbmdFZGdlcyIsImhhc01hdGNoaW5nRWRnZXMiLCJoYXNNYXRjaGluZ05vZGVzIiwiZWRnZUNoYW5nZXMiLCJub2RlQ2hhbmdlcyIsImRlbGV0ZWROb2RlcyIsImRlbGV0ZWRFZGdlcyIsImdldEludGVyc2VjdGluZ05vZGVzIiwibm9kZU9yUmVjdCIsInBhcnRpYWxseSIsImlzUmVjdCIsIm5vZGVSZWN0IiwiaGFzTm9kZXNPcHRpb24iLCJpbnRlcm5hbE5vZGUiLCJwb3NpdGlvbkFic29sdXRlIiwiY3Vyck5vZGVSZWN0Iiwib3ZlcmxhcHBpbmdBcmVhIiwicGFydGlhbGx5VmlzaWJsZSIsImlzTm9kZUludGVyc2VjdGluZyIsImFyZWEiLCJ1cGRhdGVOb2RlRGF0YSIsImRhdGFVcGRhdGUiLCJuZXh0RGF0YSIsImRhdGEiLCJ1cGRhdGVFZGdlRGF0YSIsImdldEhhbmRsZUNvbm5lY3Rpb25zIiwibm9kZUlkIiwiZnJvbSIsImNvbm5lY3Rpb25Mb29rdXAiLCJ2YWx1ZXMiLCJnZXROb2RlQ29ubmVjdGlvbnMiLCJoYW5kbGVJZCIsImZpdFZpZXciLCJmaXRWaWV3UmVzb2x2ZXIiLCJwcm9taXNlIiwid2luJDEiLCJ1c2VHbG9iYWxLZXlIYW5kbGVyIiwiZGVsZXRlS2V5Q29kZSIsIm11bHRpU2VsZWN0aW9uS2V5Q29kZSIsImRlbGV0ZUtleVByZXNzZWQiLCJtdWx0aVNlbGVjdGlvbktleVByZXNzZWQiLCJub2Rlc1NlbGVjdGlvbkFjdGl2ZSIsIm11bHRpU2VsZWN0aW9uQWN0aXZlIiwidXNlUmVzaXplSGFuZGxlciIsInVwZGF0ZURpbWVuc2lvbnMiLCJvbkVycm9yIiwicmVzaXplT2JzZXJ2ZXIiLCJSZXNpemVPYnNlcnZlciIsIm9ic2VydmUiLCJ1bm9ic2VydmUiLCJjb250YWluZXJTdHlsZSIsInRvcCIsImxlZnQiLCJzZWxlY3RvciRqIiwibGliIiwiWm9vbVBhbmUiLCJvblBhbmVDb250ZXh0TWVudSIsInpvb21PblNjcm9sbCIsInpvb21PblBpbmNoIiwicGFuT25TY3JvbGwiLCJwYW5PblNjcm9sbFNwZWVkIiwicGFuT25TY3JvbGxNb2RlIiwiRnJlZSIsInpvb21PbkRvdWJsZUNsaWNrIiwicGFuT25EcmFnIiwiem9vbUFjdGl2YXRpb25LZXlDb2RlIiwicHJldmVudFNjcm9sbGluZyIsIm5vV2hlZWxDbGFzc05hbWUiLCJvblZpZXdwb3J0Q2hhbmdlIiwiaXNDb250cm9sbGVkVmlld3BvcnQiLCJ6b29tUGFuZSIsInpvb21BY3RpdmF0aW9uS2V5UHJlc3NlZCIsIm9uVHJhbnNmb3JtQ2hhbmdlIiwib25EcmFnZ2luZ0NoYW5nZSIsInBhbmVEcmFnZ2luZyIsIm9uUGFuWm9vbVN0YXJ0IiwidnAiLCJvblZpZXdwb3J0Q2hhbmdlU3RhcnQiLCJvbk1vdmVTdGFydCIsIm9uUGFuWm9vbSIsIm9uTW92ZSIsIm9uUGFuWm9vbUVuZCIsIm9uVmlld3BvcnRDaGFuZ2VFbmQiLCJvbk1vdmVFbmQiLCJjbG9zZXN0IiwiZGVzdHJveSIsInVwZGF0ZSIsInNlbGVjdG9yJGkiLCJ1c2VyU2VsZWN0aW9uUmVjdCIsIlVzZXJTZWxlY3Rpb24iLCJpc0FjdGl2ZSIsIndyYXBIYW5kbGVyIiwiaGFuZGxlciIsImNvbnRhaW5lclJlZiIsInNlbGVjdG9yJGgiLCJjb25uZWN0aW9uSW5Qcm9ncmVzcyIsImNvbm5lY3Rpb24iLCJpblByb2dyZXNzIiwiUGFuZSIsImlzU2VsZWN0aW5nIiwic2VsZWN0aW9uS2V5UHJlc3NlZCIsInNlbGVjdGlvbk1vZGUiLCJGdWxsIiwic2VsZWN0aW9uT25EcmFnIiwib25TZWxlY3Rpb25TdGFydCIsIm9uU2VsZWN0aW9uRW5kIiwib25QYW5lQ2xpY2siLCJvblBhbmVTY3JvbGwiLCJvblBhbmVNb3VzZUVudGVyIiwib25QYW5lTW91c2VNb3ZlIiwib25QYW5lTW91c2VMZWF2ZSIsImhhc0FjdGl2ZVNlbGVjdGlvbiIsImNvbnRhaW5lciIsImNvbnRhaW5lckJvdW5kcyIsInNlbGVjdGVkTm9kZUlkcyIsInNlbGVjdGVkRWRnZUlkcyIsInNlbGVjdGlvbkluUHJvZ3Jlc3MiLCJzZWxlY3Rpb25TdGFydGVkIiwib25DbGljayIsInJlc2V0U2VsZWN0ZWRFbGVtZW50cyIsIm9uQ29udGV4dE1lbnUiLCJvbldoZWVsIiwib25Qb2ludGVyRG93biIsImJ1dHRvbiIsInNldFBvaW50ZXJDYXB0dXJlIiwicG9pbnRlcklkIiwibmF0aXZlRXZlbnQiLCJzdGFydFgiLCJzdGFydFkiLCJvblBvaW50ZXJNb3ZlIiwiZGVmYXVsdEVkZ2VPcHRpb25zIiwibW91c2VYIiwibW91c2VZIiwibmV4dFVzZXJTZWxlY3RSZWN0IiwiTWF0aCIsImFicyIsInByZXZTZWxlY3RlZE5vZGVJZHMiLCJwcmV2U2VsZWN0ZWRFZGdlSWRzIiwiUGFydGlhbCIsImVkZ2VzU2VsZWN0YWJsZSIsInNlbGVjdGFibGUiLCJjb25uZWN0aW9ucyIsImVkZ2VJZCIsIm9uUG9pbnRlclVwIiwicmVsZWFzZVBvaW50ZXJDYXB0dXJlIiwiZHJhZ2dhYmxlIiwic2VsZWN0aW9uIiwib25Qb2ludGVyRW50ZXIiLCJvblBvaW50ZXJMZWF2ZSIsImhhbmRsZU5vZGVDbGljayIsInVuc2VsZWN0Iiwibm9kZVJlZiIsImFkZFNlbGVjdGVkTm9kZXMiLCJ1bnNlbGVjdE5vZGVzQW5kRWRnZXMiLCJibHVyIiwidXNlRHJhZyIsImRpc2FibGVkIiwibm9EcmFnQ2xhc3NOYW1lIiwiaGFuZGxlU2VsZWN0b3IiLCJpc1NlbGVjdGFibGUiLCJub2RlQ2xpY2tEaXN0YW5jZSIsInNldERyYWdnaW5nIiwieHlEcmFnIiwiZ2V0U3RvcmVJdGVtcyIsIm9uTm9kZU1vdXNlRG93biIsIm9uRHJhZ1N0YXJ0Iiwib25EcmFnU3RvcCIsInNlbGVjdGVkQW5kRHJhZ2dhYmxlIiwibm9kZXNEcmFnZ2FibGUiLCJ1c2VNb3ZlU2VsZWN0ZWROb2RlcyIsIm1vdmVTZWxlY3RlZE5vZGVzIiwibm9kZUV4dGVudCIsInVwZGF0ZU5vZGVQb3NpdGlvbnMiLCJub2RlVXBkYXRlcyIsImlzU2VsZWN0ZWQiLCJ4VmVsbyIsInlWZWxvIiwieERpZmYiLCJkaXJlY3Rpb24iLCJmYWN0b3IiLCJ5RGlmZiIsIm5leHRQb3NpdGlvbiIsIk5vZGVJZENvbnRleHQiLCJDb25zdW1lciIsInVzZU5vZGVJZCIsInNlbGVjdG9yJGciLCJjb25uZWN0T25DbGljayIsImNvbm5lY3RpbmdTZWxlY3RvciIsInN0YXRlIiwiY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGUiLCJjbGlja0hhbmRsZSIsImNvbm5lY3Rpb25Nb2RlIiwiZnJvbUhhbmRsZSIsInRvSGFuZGxlIiwiaXNWYWxpZCIsImNvbm5lY3RpbmdUbyIsImNvbm5lY3RpbmdGcm9tIiwiY2xpY2tDb25uZWN0aW5nIiwiaXNQb3NzaWJsZUVuZEhhbmRsZSIsIlN0cmljdCIsImNvbm5lY3Rpb25JblByb2Nlc3MiLCJjbGlja0Nvbm5lY3Rpb25JblByb2Nlc3MiLCJ2YWxpZCIsIkhhbmRsZUNvbXBvbmVudCIsIlRvcCIsImlzVmFsaWRDb25uZWN0aW9uIiwiaXNDb25uZWN0YWJsZSIsImlzQ29ubmVjdGFibGVTdGFydCIsImlzQ29ubmVjdGFibGVFbmQiLCJvbkNvbm5lY3QiLCJvbk1vdXNlRG93biIsIm9uVG91Y2hTdGFydCIsImlzVGFyZ2V0Iiwib25Db25uZWN0RXh0ZW5kZWQiLCJvbkNvbm5lY3RBY3Rpb24iLCJlZGdlUGFyYW1zIiwiaXNNb3VzZVRyaWdnZXJlZCIsImN1cnJlbnRTdG9yZSIsImF1dG9QYW5PbkNvbm5lY3QiLCJjb25uZWN0aW9uUmFkaXVzIiwiZmxvd0lkIiwiY2FuY2VsQ29ubmVjdGlvbiIsIm9uQ29ubmVjdFN0YXJ0Iiwib25Db25uZWN0RW5kIiwidXBkYXRlQ29ubmVjdGlvbiIsImdldFRyYW5zZm9ybSIsImdldEZyb21IYW5kbGUiLCJhdXRvUGFuU3BlZWQiLCJvbkNsaWNrQ29ubmVjdFN0YXJ0Iiwib25DbGlja0Nvbm5lY3RFbmQiLCJpc1ZhbGlkQ29ubmVjdGlvblN0b3JlIiwiY29ubmVjdGlvblN0YXRlIiwiaGFuZGxlVHlwZSIsImRvYyIsImlzVmFsaWRDb25uZWN0aW9uSGFuZGxlciIsImhhbmRsZSIsImZyb21Ob2RlSWQiLCJmcm9tSGFuZGxlSWQiLCJmcm9tVHlwZSIsImNvbm5lY3Rpb25DbG9uZSIsInN0cnVjdHVyZWRDbG9uZSIsInRvUG9zaXRpb24iLCJzb3VyY2UiLCJjb25uZWN0YWJsZSIsImNvbm5lY3RhYmxlc3RhcnQiLCJjb25uZWN0YWJsZWVuZCIsImNsaWNrY29ubmVjdGluZyIsImNvbm5lY3Rpbmdmcm9tIiwiY29ubmVjdGluZ3RvIiwiY29ubmVjdGlvbmluZGljYXRvciIsIkhhbmRsZSIsIklucHV0Tm9kZSIsInNvdXJjZVBvc2l0aW9uIiwiQm90dG9tIiwibGFiZWwiLCJEZWZhdWx0Tm9kZSIsInRhcmdldFBvc2l0aW9uIiwiR3JvdXBOb2RlIiwiT3V0cHV0Tm9kZSIsImFycm93S2V5RGlmZnMiLCJBcnJvd1VwIiwiQXJyb3dEb3duIiwiQXJyb3dMZWZ0IiwiQXJyb3dSaWdodCIsImJ1aWx0aW5Ob2RlVHlwZXMiLCJpbnB1dCIsImRlZmF1bHQiLCJvdXRwdXQiLCJncm91cCIsImdldE5vZGVJbmxpbmVTdHlsZURpbWVuc2lvbnMiLCJoYW5kbGVCb3VuZHMiLCJpbml0aWFsV2lkdGgiLCJpbml0aWFsSGVpZ2h0Iiwic2VsZWN0b3IkZiIsInRyYW5zZm9ybVN0cmluZyIsIk5vZGVzU2VsZWN0aW9uIiwib25TZWxlY3Rpb25Db250ZXh0TWVudSIsImZvY3VzIiwicHJldmVudFNjcm9sbCIsIm9uS2V5RG93biIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsInRhYkluZGV4Iiwid2luIiwic2VsZWN0b3IkZSIsIkZsb3dSZW5kZXJlckNvbXBvbmVudCIsInNlbGVjdGlvbktleUNvZGUiLCJwYW5BY3RpdmF0aW9uS2V5Q29kZSIsIl9wYW5PblNjcm9sbCIsIl9wYW5PbkRyYWciLCJwYW5BY3RpdmF0aW9uS2V5UHJlc3NlZCIsIl9zZWxlY3Rpb25PbkRyYWciLCJGbG93UmVuZGVyZXIiLCJzZWxlY3RvciRkIiwib25seVJlbmRlclZpc2libGUiLCJ1c2VWaXNpYmxlTm9kZUlkcyIsIm5vZGVJZHMiLCJzZWxlY3RvciRjIiwidXNlUmVzaXplT2JzZXJ2ZXIiLCJ1cGRhdGVzIiwiZW50cnkiLCJnZXRBdHRyaWJ1dGUiLCJub2RlRWxlbWVudCIsImZvcmNlIiwiZGlzY29ubmVjdCIsInVzZU5vZGVPYnNlcnZlciIsIm5vZGVUeXBlIiwiaGFzRGltZW5zaW9ucyIsIm9ic2VydmVkTm9kZSIsInByZXZTb3VyY2VQb3NpdGlvbiIsInByZXZUYXJnZXRQb3NpdGlvbiIsInByZXZUeXBlIiwiaXNJbml0aWFsaXplZCIsImhpZGRlbiIsInR5cGVDaGFuZ2VkIiwic291cmNlUG9zQ2hhbmdlZCIsInRhcmdldFBvc0NoYW5nZWQiLCJOb2RlV3JhcHBlciIsIm9uTW91c2VFbnRlciIsIm9uTW91c2VNb3ZlIiwib25Nb3VzZUxlYXZlIiwib25Eb3VibGVDbGljayIsIm5vZGVzQ29ubmVjdGFibGUiLCJub2Rlc0ZvY3VzYWJsZSIsIm5vZGVUeXBlcyIsImlzUGFyZW50IiwicGFyZW50TG9va3VwIiwiTm9kZUNvbXBvbmVudCIsImlzRHJhZ2dhYmxlIiwiaXNGb2N1c2FibGUiLCJmb2N1c2FibGUiLCJkcmFnSGFuZGxlIiwibm9kZURpbWVuc2lvbnMiLCJpbmxpbmVEaW1lbnNpb25zIiwiaGFzUG9pbnRlckV2ZW50cyIsIm9uTW91c2VFbnRlckhhbmRsZXIiLCJvbk1vdXNlTW92ZUhhbmRsZXIiLCJvbk1vdXNlTGVhdmVIYW5kbGVyIiwib25Db250ZXh0TWVudUhhbmRsZXIiLCJvbkRvdWJsZUNsaWNrSGFuZGxlciIsIm9uU2VsZWN0Tm9kZUhhbmRsZXIiLCJzZWxlY3ROb2Rlc09uRHJhZyIsIm5vZGVEcmFnVGhyZXNob2xkIiwidG9Mb3dlckNhc2UiLCJvbkZvY3VzIiwiYXV0b1Bhbk9uTm9kZUZvY3VzIiwid2l0aGluVmlld3BvcnQiLCJwYXJlbnQiLCJ6SW5kZXgiLCJ6IiwidmlzaWJpbGl0eSIsInJvbGUiLCJhcmlhUm9sZSIsImFyaWFMYWJlbCIsImRvbUF0dHJpYnV0ZXMiLCJwb3NpdGlvbkFic29sdXRlWCIsInBvc2l0aW9uQWJzb2x1dGVZIiwiZGVsZXRhYmxlIiwic2VsZWN0b3IkYiIsIk5vZGVSZW5kZXJlckNvbXBvbmVudCIsIm9ubHlSZW5kZXJWaXNpYmxlRWxlbWVudHMiLCJvbk5vZGVDbGljayIsIm9uTm9kZU1vdXNlRW50ZXIiLCJvbk5vZGVNb3VzZU1vdmUiLCJvbk5vZGVNb3VzZUxlYXZlIiwib25Ob2RlQ29udGV4dE1lbnUiLCJvbk5vZGVEb3VibGVDbGljayIsIk5vZGVSZW5kZXJlciIsInVzZVZpc2libGVFZGdlSWRzIiwiZWRnZUlkcyIsInZpc2libGVFZGdlSWRzIiwic291cmNlTm9kZSIsInRhcmdldE5vZGUiLCJBcnJvd1N5bWJvbCIsImNvbG9yIiwic3Ryb2tlV2lkdGgiLCJzdHJva2UiLCJzdHJva2VMaW5lY2FwIiwic3Ryb2tlTGluZWpvaW4iLCJmaWxsIiwicG9pbnRzIiwiQXJyb3dDbG9zZWRTeW1ib2wiLCJNYXJrZXJTeW1ib2xzIiwiQXJyb3ciLCJBcnJvd0Nsb3NlZCIsInVzZU1hcmtlclN5bWJvbCIsInN5bWJvbCIsInN5bWJvbEV4aXN0cyIsIk1hcmtlciIsIm1hcmtlclVuaXRzIiwib3JpZW50IiwiU3ltYm9sIiwibWFya2VyV2lkdGgiLCJtYXJrZXJIZWlnaHQiLCJ2aWV3Qm94IiwicmVmWCIsInJlZlkiLCJNYXJrZXJEZWZpbml0aW9ucyIsImRlZmF1bHRDb2xvciIsIm1hcmtlcnMiLCJkZWZhdWx0TWFya2VyU3RhcnQiLCJtYXJrZXJTdGFydCIsImRlZmF1bHRNYXJrZXJFbmQiLCJtYXJrZXJFbmQiLCJtYXJrZXIiLCJNYXJrZXJEZWZpbml0aW9ucyQxIiwiRWRnZVRleHRDb21wb25lbnQiLCJsYWJlbFN0eWxlIiwibGFiZWxTaG93QmciLCJsYWJlbEJnU3R5bGUiLCJsYWJlbEJnUGFkZGluZyIsImxhYmVsQmdCb3JkZXJSYWRpdXMiLCJlZGdlVGV4dEJib3giLCJzZXRFZGdlVGV4dEJib3giLCJlZGdlVGV4dENsYXNzZXMiLCJlZGdlVGV4dFJlZiIsInRleHRCYm94IiwiZ2V0QkJveCIsInJ4IiwicnkiLCJkeSIsIkVkZ2VUZXh0IiwiQmFzZUVkZ2UiLCJwYXRoIiwibGFiZWxYIiwibGFiZWxZIiwiaW50ZXJhY3Rpb25XaWR0aCIsImQiLCJzdHJva2VPcGFjaXR5IiwiZ2V0Q29udHJvbCIsInBvcyIsIngxIiwieTEiLCJ4MiIsInkyIiwiTGVmdCIsIlJpZ2h0IiwiZ2V0U2ltcGxlQmV6aWVyUGF0aCIsInNvdXJjZVgiLCJzb3VyY2VZIiwidGFyZ2V0WCIsInRhcmdldFkiLCJzb3VyY2VDb250cm9sWCIsInNvdXJjZUNvbnRyb2xZIiwidGFyZ2V0Q29udHJvbFgiLCJ0YXJnZXRDb250cm9sWSIsIm9mZnNldFgiLCJvZmZzZXRZIiwiY3JlYXRlU2ltcGxlQmV6aWVyRWRnZSIsIl9pZCIsImlzSW50ZXJuYWwiLCJTaW1wbGVCZXppZXJFZGdlIiwiU2ltcGxlQmV6aWVyRWRnZUludGVybmFsIiwiY3JlYXRlU21vb3RoU3RlcEVkZ2UiLCJwYXRoT3B0aW9ucyIsImJvcmRlclJhZGl1cyIsIm9mZnNldCIsIlNtb290aFN0ZXBFZGdlIiwiU21vb3RoU3RlcEVkZ2VJbnRlcm5hbCIsImNyZWF0ZVN0ZXBFZGdlIiwiU3RlcEVkZ2UiLCJTdGVwRWRnZUludGVybmFsIiwiY3JlYXRlU3RyYWlnaHRFZGdlIiwiU3RyYWlnaHRFZGdlIiwiU3RyYWlnaHRFZGdlSW50ZXJuYWwiLCJjcmVhdGVCZXppZXJFZGdlIiwiY3VydmF0dXJlIiwiQmV6aWVyRWRnZSIsIkJlemllckVkZ2VJbnRlcm5hbCIsImJ1aWx0aW5FZGdlVHlwZXMiLCJzdHJhaWdodCIsInN0ZXAiLCJzbW9vdGhzdGVwIiwic2ltcGxlYmV6aWVyIiwibnVsbFBvc2l0aW9uIiwic2hpZnRYIiwic2hpZnQiLCJzaGlmdFkiLCJFZGdlVXBkYXRlckNsYXNzTmFtZSIsIkVkZ2VBbmNob3IiLCJjZW50ZXJYIiwiY2VudGVyWSIsInJhZGl1cyIsIm9uTW91c2VPdXQiLCJjeCIsImN5IiwiciIsIkVkZ2VVcGRhdGVBbmNob3JzIiwiaXNSZWNvbm5lY3RhYmxlIiwicmVjb25uZWN0UmFkaXVzIiwib25SZWNvbm5lY3QiLCJvblJlY29ubmVjdFN0YXJ0Iiwib25SZWNvbm5lY3RFbmQiLCJzZXRSZWNvbm5lY3RpbmciLCJzZXRVcGRhdGVIb3ZlciIsImhhbmRsZUVkZ2VVcGRhdGVyIiwib3Bwb3NpdGVIYW5kbGUiLCJfb25SZWNvbm5lY3RFbmQiLCJldnQiLCJvbkNvbm5lY3RFZGdlIiwiZWRnZVVwZGF0ZXJUeXBlIiwib25SZWNvbm5lY3RTb3VyY2VNb3VzZURvd24iLCJ0YXJnZXRIYW5kbGUiLCJvblJlY29ubmVjdFRhcmdldE1vdXNlRG93biIsInNvdXJjZUhhbmRsZSIsIm9uUmVjb25uZWN0TW91c2VFbnRlciIsIm9uUmVjb25uZWN0TW91c2VPdXQiLCJFZGdlV3JhcHBlciIsImVkZ2VzRm9jdXNhYmxlIiwiZWRnZXNSZWNvbm5lY3RhYmxlIiwiZWRnZVR5cGVzIiwiZWRnZVR5cGUiLCJFZGdlQ29tcG9uZW50IiwicmVjb25uZWN0YWJsZSIsImVkZ2VSZWYiLCJ1cGRhdGVIb3ZlciIsInJlY29ubmVjdGluZyIsImVkZ2VQb3NpdGlvbiIsImVsZXZhdGVPblNlbGVjdCIsImVsZXZhdGVFZGdlc09uU2VsZWN0IiwibWFya2VyU3RhcnRVcmwiLCJtYXJrZXJFbmRVcmwiLCJvbkVkZ2VDbGljayIsImFkZFNlbGVjdGVkRWRnZXMiLCJvbkVkZ2VEb3VibGVDbGljayIsIm9uRWRnZUNvbnRleHRNZW51Iiwib25FZGdlTW91c2VFbnRlciIsIm9uRWRnZU1vdXNlTW92ZSIsIm9uRWRnZU1vdXNlTGVhdmUiLCJhbmltYXRlZCIsImluYWN0aXZlIiwidXBkYXRpbmciLCJzb3VyY2VIYW5kbGVJZCIsInRhcmdldEhhbmRsZUlkIiwic2VsZWN0b3IkYSIsIkVkZ2VSZW5kZXJlckNvbXBvbmVudCIsImRlZmF1bHRNYXJrZXJDb2xvciIsIkVkZ2VSZW5kZXJlciIsInNlbGVjdG9yJDkiLCJWaWV3cG9ydCIsInVzZU9uSW5pdEhhbmRsZXIiLCJvbkluaXQiLCJyZkluc3RhbmNlIiwic2V0VGltZW91dCIsInNlbGVjdG9yJDgiLCJzeW5jVmlld3BvcnQiLCJ1c2VWaWV3cG9ydFN5bmMiLCJzdG9yZVNlbGVjdG9yJDEiLCJ0byIsImdldFNlbGVjdG9yIiwiY29ubmVjdGlvblNlbGVjdG9yIiwiY29tYmluZWRTZWxlY3RvciIsInVzZUNvbm5lY3Rpb24iLCJzZWxlY3RvciQ3IiwiQ29ubmVjdGlvbkxpbmVXcmFwcGVyIiwiY29tcG9uZW50IiwicmVuZGVyQ29ubmVjdGlvbiIsIkNvbm5lY3Rpb25MaW5lIiwiQ3VzdG9tQ29tcG9uZW50IiwiQmV6aWVyIiwiZnJvbU5vZGUiLCJmcm9tUG9zaXRpb24iLCJ0b05vZGUiLCJjb25uZWN0aW9uTGluZVR5cGUiLCJjb25uZWN0aW9uTGluZVN0eWxlIiwiZnJvbVgiLCJmcm9tWSIsInRvWCIsInRvWSIsImNvbm5lY3Rpb25TdGF0dXMiLCJwYXRoUGFyYW1zIiwiU2ltcGxlQmV6aWVyIiwiU3RlcCIsIlNtb290aFN0ZXAiLCJlbXB0eVR5cGVzIiwidXNlTm9kZU9yRWRnZVR5cGVzV2FybmluZyIsIm5vZGVPckVkZ2VUeXBlcyIsInR5cGVzUmVmIiwicHJvY2VzcyIsInVzZWRLZXlzIiwidXNlU3R5bGVzTG9hZGVkV2FybmluZyIsImNoZWNrZWQiLCJwYW5lIiwicXVlcnlTZWxlY3RvciIsImdldENvbXB1dGVkU3R5bGUiLCJHcmFwaFZpZXdDb21wb25lbnQiLCJjb25uZWN0aW9uTGluZUNvbXBvbmVudCIsImNvbm5lY3Rpb25MaW5lQ29udGFpbmVyU3R5bGUiLCJHcmFwaFZpZXciLCJnZXRJbml0aWFsU3RhdGUiLCJzdG9yZUVkZ2VzIiwic3RvcmVOb2RlcyIsInN0b3JlTm9kZU9yaWdpbiIsInN0b3JlTm9kZUV4dGVudCIsIm5vZGVzSW5pdGlhbGl6ZWQiLCJlbGV2YXRlTm9kZXNPblNlbGVjdCIsImF1dG9QYW5Pbk5vZGVEcmFnIiwiZGVidWciLCJjcmVhdGVTdG9yZSIsInJlc29sdmVGaXRWaWV3IiwiY2hlY2tFcXVhbGl0eSIsInVwZGF0ZWRJbnRlcm5hbHMiLCJjb25zb2xlIiwibG9nIiwibm9kZURyYWdJdGVtcyIsInBhcmVudEV4cGFuZENoaWxkcmVuIiwiZHJhZ0l0ZW0iLCJleHBhbmRQYXJlbnQiLCJtYXgiLCJyZWN0IiwicGFyZW50RXhwYW5kQ2hhbmdlcyIsInVwZGF0ZWROb2RlcyIsInVwZGF0ZWRFZGdlcyIsImNoYW5nZWRFZGdlcyIsIm5vZGVzVG9VbnNlbGVjdCIsImVkZ2VzVG9VbnNlbGVjdCIsInNldFNjYWxlRXh0ZW50IiwiY2xpY2tEaXN0YW5jZSIsInNldENsaWNrRGlzdGFuY2UiLCJuZXh0Tm9kZUV4dGVudCIsImRlbHRhIiwibmV4dFpvb20iLCJpcyIsIlJlYWN0Rmxvd1Byb3ZpZGVyIiwiaW5pdGlhbE5vZGVzIiwiaW5pdGlhbEVkZ2VzIiwiaW5pdGlhbE1pblpvb20iLCJpbml0aWFsTWF4Wm9vbSIsImluaXRpYWxGaXRWaWV3T3B0aW9ucyIsIldyYXBwZXIiLCJpc1dyYXBwZWQiLCJ3cmFwcGVyU3R5bGUiLCJSZWFjdEZsb3ciLCJvbk5vZGVEcmFnU3RhcnQiLCJvbk5vZGVEcmFnIiwib25Ob2RlRHJhZ1N0b3AiLCJvblNlbGVjdGlvbkRyYWdTdGFydCIsIm9uU2VsZWN0aW9uRHJhZyIsIm9uU2VsZWN0aW9uRHJhZ1N0b3AiLCJkZWZhdWx0Vmlld3BvcnQkMSIsImF0dHJpYnV0aW9uUG9zaXRpb24iLCJvblNjcm9sbCIsImNvbG9yTW9kZUNsYXNzTmFtZSIsIndyYXBwZXJPblNjcm9sbCIsImN1cnJlbnRUYXJnZXQiLCJzY3JvbGxUbyIsImJlaGF2aW9yIiwic2VsZWN0b3IkNiIsIkVkZ2VMYWJlbFJlbmRlcmVyIiwiZWRnZUxhYmVsUmVuZGVyZXIiLCJzZWxlY3RvciQ1IiwiVmlld3BvcnRQb3J0YWwiLCJ2aWV3UG9ydGFsRGl2IiwidXNlVXBkYXRlTm9kZUludGVybmFscyIsInVwZGF0ZUlkcyIsInVwZGF0ZUlkIiwidHJpZ2dlckZpdFZpZXciLCJub2Rlc1NlbGVjdG9yIiwidXNlTm9kZXMiLCJlZGdlc1NlbGVjdG9yIiwidXNlRWRnZXMiLCJ2aWV3cG9ydFNlbGVjdG9yIiwidXNlVmlld3BvcnQiLCJ1c2VOb2Rlc1N0YXRlIiwibmRzIiwidXNlRWRnZXNTdGF0ZSIsImVkcyIsInVzZU9uVmlld3BvcnRDaGFuZ2UiLCJvblN0YXJ0Iiwib25DaGFuZ2UiLCJvbkVuZCIsInVzZU9uU2VsZWN0aW9uQ2hhbmdlIiwibmV4dE9uU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnMiLCJuZXh0SGFuZGxlcnMiLCJzZWxlY3RvciQ0IiwiaW5jbHVkZUhpZGRlbk5vZGVzIiwidXNlTm9kZXNJbml0aWFsaXplZCIsImluaXRpYWxpemVkIiwidXNlSGFuZGxlQ29ubmVjdGlvbnMiLCJvbkRpc2Nvbm5lY3QiLCJ3YXJuIiwiX25vZGVJZCIsImN1cnJlbnROb2RlSWQiLCJwcmV2Q29ubmVjdGlvbnMiLCJfY29ubmVjdGlvbnMiLCJlcnJvcjAxNCIsInVzZU5vZGVDb25uZWN0aW9ucyIsInVzZU5vZGVzRGF0YSIsIm5vZGVzRGF0YSIsImlzQXJyYXlPZklkcyIsIl9ub2RlSWRzIiwidXNlSW50ZXJuYWxOb2RlIiwiTGluZVBhdHRlcm4iLCJsaW5lV2lkdGgiLCJ2YXJpYW50IiwiRG90UGF0dGVybiIsIkJhY2tncm91bmRWYXJpYW50IiwiZGVmYXVsdFNpemUiLCJEb3RzIiwiTGluZXMiLCJDcm9zcyIsInNlbGVjdG9yJDMiLCJwYXR0ZXJuSWQiLCJCYWNrZ3JvdW5kQ29tcG9uZW50IiwiZ2FwIiwiYmdDb2xvciIsInBhdHRlcm5DbGFzc05hbWUiLCJwYXR0ZXJuU2l6ZSIsImlzRG90cyIsImlzQ3Jvc3MiLCJnYXBYWSIsInNjYWxlZEdhcCIsInNjYWxlZFNpemUiLCJvZmZzZXRYWSIsInBhdHRlcm5EaW1lbnNpb25zIiwic2NhbGVkT2Zmc2V0IiwiX3BhdHRlcm5JZCIsInBhdHRlcm5Vbml0cyIsInBhdHRlcm5UcmFuc2Zvcm0iLCJCYWNrZ3JvdW5kIiwiUGx1c0ljb24iLCJ4bWxucyIsIk1pbnVzSWNvbiIsIkZpdFZpZXdJY29uIiwiTG9ja0ljb24iLCJVbmxvY2tJY29uIiwiQ29udHJvbEJ1dHRvbiIsInNlbGVjdG9yJDIiLCJpc0ludGVyYWN0aXZlIiwibWluWm9vbVJlYWNoZWQiLCJtYXhab29tUmVhY2hlZCIsIkNvbnRyb2xzQ29tcG9uZW50Iiwic2hvd1pvb20iLCJzaG93Rml0VmlldyIsInNob3dJbnRlcmFjdGl2ZSIsIm9uWm9vbUluIiwib25ab29tT3V0Iiwib25GaXRWaWV3Iiwib25JbnRlcmFjdGl2ZUNoYW5nZSIsIm9yaWVudGF0aW9uIiwib25ab29tSW5IYW5kbGVyIiwib25ab29tT3V0SGFuZGxlciIsIm9uRml0Vmlld0hhbmRsZXIiLCJvblRvZ2dsZUludGVyYWN0aXZpdHkiLCJvcmllbnRhdGlvbkNsYXNzIiwidGl0bGUiLCJDb250cm9scyIsIk1pbmlNYXBOb2RlQ29tcG9uZW50Iiwic3Ryb2tlQ29sb3IiLCJzaGFwZVJlbmRlcmluZyIsImJhY2tncm91bmQiLCJiYWNrZ3JvdW5kQ29sb3IiLCJNaW5pTWFwTm9kZSIsInNlbGVjdG9yTm9kZUlkcyIsImdldEF0dHJGdW5jdGlvbiIsImZ1bmMiLCJGdW5jdGlvbiIsIk1pbmlNYXBOb2RlcyIsIm5vZGVTdHJva2VDb2xvciIsIm5vZGVDb2xvciIsIm5vZGVDbGFzc05hbWUiLCJub2RlQm9yZGVyUmFkaXVzIiwibm9kZVN0cm9rZVdpZHRoIiwibm9kZUNvbXBvbmVudCIsIm5vZGVDb2xvckZ1bmMiLCJub2RlU3Ryb2tlQ29sb3JGdW5jIiwibm9kZUNsYXNzTmFtZUZ1bmMiLCJjaHJvbWUiLCJOb2RlQ29tcG9uZW50V3JhcHBlciIsIk5vZGVDb21wb25lbnRXcmFwcGVySW5uZXIiLCJNaW5pTWFwTm9kZXMkMSIsImRlZmF1bHRXaWR0aCIsImRlZmF1bHRIZWlnaHQiLCJmaWx0ZXJIaWRkZW4iLCJzZWxlY3RvciQxIiwidmlld0JCIiwiYm91bmRpbmdSZWN0IiwiZmxvd1dpZHRoIiwiZmxvd0hlaWdodCIsIkFSSUFfTEFCRUxfS0VZIiwiTWluaU1hcENvbXBvbmVudCIsIm1hc2tDb2xvciIsIm1hc2tTdHJva2VDb2xvciIsIm1hc2tTdHJva2VXaWR0aCIsInBhbm5hYmxlIiwiem9vbWFibGUiLCJpbnZlcnNlUGFuIiwiem9vbVN0ZXAiLCJvZmZzZXRTY2FsZSIsInN2ZyIsImVsZW1lbnRXaWR0aCIsImVsZW1lbnRIZWlnaHQiLCJzY2FsZWRXaWR0aCIsInNjYWxlZEhlaWdodCIsInZpZXdTY2FsZSIsInZpZXdXaWR0aCIsInZpZXdIZWlnaHQiLCJsYWJlbGxlZEJ5Iiwidmlld1NjYWxlUmVmIiwibWluaW1hcEluc3RhbmNlIiwiZ2V0Vmlld1NjYWxlIiwib25TdmdDbGljayIsInBvaW50ZXIiLCJvblN2Z05vZGVDbGljayIsIl9hcmlhTGFiZWwiLCJmaWxsUnVsZSIsIk1pbmlNYXAiLCJzY2FsZVNlbGVjdG9yIiwiY2FsY3VsYXRlU2NhbGUiLCJkZWZhdWx0UG9zaXRpb25zIiwiTGluZSIsIlJlc2l6ZUNvbnRyb2wiLCJtaW5XaWR0aCIsIm1pbkhlaWdodCIsIm1heFdpZHRoIiwiTnVtYmVyIiwiTUFYX1ZBTFVFIiwibWF4SGVpZ2h0Iiwia2VlcEFzcGVjdFJhdGlvIiwicmVzaXplRGlyZWN0aW9uIiwiYXV0b1NjYWxlIiwic2hvdWxkUmVzaXplIiwib25SZXNpemVTdGFydCIsIm9uUmVzaXplIiwib25SZXNpemVFbmQiLCJjb250ZXh0Tm9kZUlkIiwicmVzaXplQ29udHJvbFJlZiIsImlzSGFuZGxlQ29udHJvbCIsInNjYWxlIiwicmVzaXplciIsImNvbnRyb2xQb3NpdGlvbiIsInBhbmVEb21Ob2RlIiwiY2hpbGRDaGFuZ2VzIiwib3JpZ2luIiwiY2hpbGQiLCJwb3NpdGlvbkNoYW5nZSIsImRpbWVuc2lvbkNoYW5nZSIsImNoaWxkQ2hhbmdlIiwiYm91bmRhcmllcyIsInBvc2l0aW9uQ2xhc3NOYW1lcyIsIk5vZGVSZXNpemVDb250cm9sIiwiTm9kZVJlc2l6ZXIiLCJpc1Zpc2libGUiLCJoYW5kbGVDbGFzc05hbWUiLCJoYW5kbGVTdHlsZSIsImxpbmVDbGFzc05hbWUiLCJsaW5lU3R5bGUiLCJOb2RlVG9vbGJhclBvcnRhbCIsIndyYXBwZXJSZWYiLCJub2RlRXF1YWxpdHlGbiIsIm5vZGVzRXF1YWxpdHlGbiIsInN0b3JlU2VsZWN0b3IiLCJzZWxlY3RlZE5vZGVzQ291bnQiLCJOb2RlVG9vbGJhciIsImFsaWduIiwiaW50ZXJuYWxOb2RlcyIsIm5vZGVzQXJyYXkiLCJhY2MiLCJ0cmltIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@xyflow+react@12.7.1_@types+react@18.3.23_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@xyflow/react/dist/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@xyflow+react@12.7.1_@types+react@18.3.23_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@xyflow/react/dist/style.css":
/*!************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@xyflow+react@12.7.1_@types+react@18.3.23_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@xyflow/react/dist/style.css ***!
  \************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"111582f0e218\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHh5ZmxvdytyZWFjdEAxMi43LjFfQHR5cGVzK3JlYWN0QDE4LjMuMjNfcmVhY3QtZG9tQDE5LjEuMF9yZWFjdEAxOS4xLjBfX3JlYWN0QDE5LjEuMC9ub2RlX21vZHVsZXMvQHh5Zmxvdy9yZWFjdC9kaXN0L3N0eWxlLmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLEtBQVUsRUFBRSxFQUF1QiIsInNvdXJjZXMiOlsiL1VzZXJzL293ZW4vcmVwb3MvZ3VtbnV0L2Jlc3Bva2UtbWluZC1nYXJkZW4vbm9kZV9tb2R1bGVzLy5wbnBtL0B4eWZsb3crcmVhY3RAMTIuNy4xX0B0eXBlcytyZWFjdEAxOC4zLjIzX3JlYWN0LWRvbUAxOS4xLjBfcmVhY3RAMTkuMS4wX19yZWFjdEAxOS4xLjAvbm9kZV9tb2R1bGVzL0B4eWZsb3cvcmVhY3QvZGlzdC9zdHlsZS5jc3MiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCIxMTE1ODJmMGUyMThcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@xyflow+react@12.7.1_@types+react@18.3.23_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@xyflow/react/dist/style.css\n");

/***/ })

};
;